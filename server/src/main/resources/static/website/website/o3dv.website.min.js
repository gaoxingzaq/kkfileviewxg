var OV = (() => {
	var $i = Object.defineProperty;
	var ho = Object.getOwnPropertyDescriptor;
	var uo = Object.getOwnPropertyNames;
	var mo = Object.prototype.hasOwnProperty;
	var fo = (o, e) => {
			for (var t in e) $i(o, t, {
				get: e[t],
				enumerable: !0
			})
		},
		co = (o, e, t, i) => {
			if (e && typeof e == "object" || typeof e == "function")
				for (let r of uo(e)) !mo.call(o, r) && r !== t && $i(o, r, {
					get: () => e[r],
					enumerable: !(i = ho(e, r)) || i.enumerable
				});
			return o
		};
	var po = o => co($i({}, "__esModule", {
		value: !0
	}), o);
	var Ao = {};
	fo(Ao, {
		CreateHeaderButton: () => Eo,
		SetWebsiteEventHandler: () => bo,
		StartEmbed: () => wo,
		StartWebsite: () => So
	});
	var gi = null,
		bn = new Set;

	function er(o) {
		gi = o
	}

	function tr(o) {
		return gi === null ? null : gi + "/" + o
	}

	function xe(o) {
		return new Promise((e, t) => {
			if (gi === null) {
				t();
				return
			}
			if (bn.has(o)) {
				e();
				return
			}
			let i = document.createElement("script");
			i.type = "text/javascript", i.src = tr(o), i.onload = () => {
				bn.add(o), e()
			}, i.onerror = () => {
				t()
			}, document.head.appendChild(i)
		})
	}
	var Sn = 57.29577951308232,
		Lt = .017453292519943;

	function Yt(o) {
		return Math.abs(o) < 1e-8
	}

	function xi(o, e) {
		return e - o > 1e-8
	}

	function wn(o, e) {
		return o - e > 1e-8
	}

	function Ci(o, e) {
		return e - o > -1e-8
	}

	function vi(o, e) {
		return o - e > -1e-8
	}

	function J(o, e) {
		return Math.abs(e - o) < 1e-8
	}

	function ir(o, e, t) {
		return Math.abs(e - o) < t
	}

	function ze(o) {
		return o > 1e-8
	}

	function pt(o) {
		return o < -1e-8
	}
	var G = {
		X: 1,
		Y: 2,
		Z: 3
	};
	var O = class {
		constructor(e, t) {
			this.x = e, this.y = t
		}
		Clone() {
			return new O(this.x, this.y)
		}
	};

	function gt(o, e) {
		return J(o.x, e.x) && J(o.y, e.y)
	}

	function rr(o, e) {
		return new O(o.x - e.x, o.y - e.y)
	}

	function nr(o, e) {
		return Math.sqrt((o.x - e.x) * (o.x - e.x) + (o.y - e.y) * (o.y - e.y))
	}

	function he(o) {
		return Math.round(parseFloat(o))
	}

	function En(o) {
		let e = he(o.paddingLeft) + he(o.paddingRight),
			t = he(o.borderLeftWidth) + he(o.borderRightWidth),
			i = he(o.marginLeft) + he(o.marginRight);
		return e + t + i
	}

	function An(o) {
		let e = he(o.paddingTop) + he(o.paddingBottom),
			t = he(o.borderTopWidth) + he(o.borderBottomWidth),
			i = he(o.marginTop) + he(o.marginBottom);
		return e + t + i
	}

	function Dn(o, e, t) {
		let i = getComputedStyle(o),
			r = e - En(i),
			n = t - An(i);
		return {
			width: r,
			height: n
		}
	}

	function xt(o, e, t) {
		if (o.getBoundingClientRect) {
			let i = o.getBoundingClientRect();
			e -= i.left, t -= i.top
		}
		return window.pageXOffset && window.pageYOffset && (e += window.pageXOffset, t += window.pageYOffset), new O(e, t)
	}

	function nt(o, e, t) {
		let i = document.createElement(o);
		return e && (i.className = e), t && (i.innerHTML = t), i
	}

	function X(o, e, t, i) {
		let r = nt(e, t, i);
		return o.appendChild(r), r
	}

	function v(o, e, t) {
		return X(o, "div", e, t)
	}

	function Ce(o) {
		for (; o.firstChild;) o.removeChild(o.firstChild)
	}

	function Ct(o, e) {
		e.parentNode.insertBefore(o, e)
	}

	function Gn(o, e) {
		e.parentNode.insertBefore(o, e.nextSibling)
	}

	function L(o, e) {
		e ? o.style.display = "block" : o.style.display = "none"
	}

	function Ii(o) {
		return o.offsetParent !== null
	}

	function Bt(o, e) {
		o.style.width = e.toString() + "px"
	}

	function ve(o, e) {
		o.style.height = e.toString() + "px"
	}

	function Ot(o) {
		let e = getComputedStyle(o);
		return o.offsetWidth + he(e.marginLeft) + he(e.marginRight)
	}

	function Ke(o) {
		let e = getComputedStyle(o);
		return o.offsetHeight + he(e.marginTop) + he(e.marginBottom)
	}

	function _n(o, e) {
		let t = getComputedStyle(o);
		Bt(o, e - En(t))
	}

	function st(o, e) {
		let t = getComputedStyle(o);
		ve(o, e - An(t))
	}

	function Ie(o, e) {
		return nt("div", o, e)
	}
	var D = class {
		constructor(e, t, i) {
			this.r = e, this.g = t, this.b = i
		}
		Set(e, t, i) {
			this.r = e, this.g = t, this.b = i
		}
		Clone() {
			return new D(this.r, this.g, this.b)
		}
	};

	function De(o) {
		return parseInt(Math.round(o * 255), 10)
	}

	function Ne(o, e, t) {
		return new D(De(o), De(e), De(t))
	}

	function ot(o) {
		return o < .04045 ? o * .0773993808 : Math.pow(o * .9478672986 + .0521327014, 2.4)
	}

	function Kt(o) {
		return o < .0031308 ? o * 12.92 : 1.055 * Math.pow(o, .41666) - .055
	}

	function ie(o) {
		let e = parseInt(o, 10)
			.toString(16);
		for (; e.length < 2;) e = "0" + e;
		return e
	}

	function ue(o) {
		let e = ie(o.r),
			t = ie(o.g),
			i = ie(o.b);
		return e + t + i
	}

	function Pn(o) {
		return new D(o[0], o[1], o[2])
	}

	function vt(o, e) {
		return o.r === e.r && o.g === e.g && o.b === e.b
	}

	function re(o) {
		return new TextDecoder("utf-8")
			.decode(o)
	}

	function Ti(o) {
		return new TextEncoder()
			.encode(o)
			.buffer
	}

	function Jt(o) {
		let e = "data:";
		if (!o.startsWith(e)) return null;
		let t = o.indexOf(";");
		if (t === -1) return null;
		let i = o.indexOf(",");
		if (i === -1) return null;
		let r = o.substring(e.length, e.length + t - 5),
			n = atob(o.substring(i + 1)),
			s = new ArrayBuffer(n.length),
			l = new Uint8Array(s);
		for (let a = 0; a < n.length; a++) l[a] = n.charCodeAt(a);
		return {
			mimeType: r,
			buffer: s
		}
	}

	function kt(o) {
		if (o == null) return "";
		let e = o.split("/");
		return e.length === 0 ? "" : e[e.length - 1]
	}

	function It(o) {
		let e = new Blob([o]);
		return URL.createObjectURL(e)
	}

	function sr(o, e) {
		let t = new Blob([o], {
			type: e
		});
		return URL.createObjectURL(t)
	}

	function Fn(o) {
		URL.revokeObjectURL(o)
	}

	function Rn(o, e) {
		let t = null,
			i = n => {
				n.preventDefault();
				let s = n.clientX - t;
				e.onSplit(s)
			},
			r = () => {
				document.removeEventListener("mousemove", i), document.removeEventListener("mouseup", r), document.removeEventListener("mouseleave", r), t = null
			};
		o.addEventListener("mousedown", n => {
			t = n.clientX, e.onSplitStart(), document.addEventListener("mousemove", i), document.addEventListener("mouseup", r), document.addEventListener("mouseleave", r)
		})
	}

	function or(o, e) {
		return o.length > 0 ? o : e
	}

	function Nn(o) {
		return or(o, "No Name")
	}

	function Mi(o) {
		return or(o, "No Name")
	}

	function yi(o) {
		return or(o, "No Name")
	}

	function lr() {
		return window.matchMedia("(hover: hover)")
			.matches
	}

	function Vn(o) {
		window.matchMedia("(max-width: 800px)")
			.addEventListener("change", o)
	}

	function Ln() {
		return window.matchMedia("(max-width: 800px)")
			.matches
	}

	function bi(o, e) {
		function t(r, n) {
			let s = window.innerWidth,
				l = r.getBoundingClientRect(),
				a = r.offsetWidth,
				h = r.offsetHeight,
				u = n.offsetWidth,
				d = 10,
				m = l.left + a / 2 - u / 2;
			return m + u > s - d && (m = s - u - d), m < d && (m = d), m = Math.max(m, 0), {
				left: m,
				top: l.top + h + d
			}
		}
		if (!lr()) return;
		let i = null;
		o.addEventListener("mouseover", () => {
			i = v(document.body, "ov_tooltip", e);
			let r = t(o, i);
			i.style.left = r.left + "px", i.style.top = r.top + "px"
		}), o.addEventListener("mouseout", () => {
			i.remove()
		})
	}

	function Bn(o) {
		let e = document.createElement("input");
		e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.setAttribute("value", o), document.body.appendChild(e), e.select(), document.execCommand("copy"), document.body.removeChild(e)
	}

	function ar(o, e) {
		let t = document.createElement("a");
		t.href = o, t.download = e, document.body.appendChild(t), t.click(), document.body.removeChild(t)
	}

	function hr(o, e) {
		let t = It(o);
		ar(t, e)
	}

	function Zt(o, e) {
		let t = Ie("ov_svg_icon");
		return e && t.classList.add(e), X(t, "i", "icon icon-" + o), t
	}

	function ne(o, e, t) {
		let i = Zt(e, t);
		return o.appendChild(i), i
	}

	function Je(o, e) {
		let t = o.firstChild;
		t.className = "icon icon-" + e
	}

	function Si(o) {
		let e = "#" + ue(o),
			t = new D(Math.max(0, o.r - 50), Math.max(0, o.g - 50), Math.max(0, o.b - 50)),
			i = "#" + ue(t),
			r = Ie("ov_color_circle");
		return r.style.background = e, r.style.border = "1px solid " + i, r
	}

	function On(o) {
		return o.r * .299 + o.g * .587 + o.b * .114 > 186
	}

	function wi(o, e, t, i) {
		let r = null;
		Rn(o, {
			onSplitStart: () => {
				r = Ot(e)
			},
			onSplit: n => {
				let a = 0;
				t ? a = r - n : a = r + n, a < 280 ? a = 280 : a > 450 && (a = 450), _n(e, a), i()
			}
		})
	}

	function kn(o, e) {
		async function t(n, s) {
			let l = n.createReader();
			return new Promise((a, h) => {
				l.readEntries(async u => {
					for (let d of u) d.isFile ? s.push(d) : d.isDirectory && await t(d, s);
					a()
				}, u => {
					h(u)
				})
			})
		}
		async function i(n, s) {
			let l = [];
			for (let h of n) h.isFile ? l.push(h) : h.isDirectory && await t(h, l);
			let a = await Promise.all(l.map(h => new Promise((u, d) => {
				h.file(m => {
					u(m)
				}, m => {
					d(m)
				})
			})));
			s(a)
		}
		let r = null;
		if (DataTransferItem && (DataTransferItem.prototype.getAsEntry ? r = DataTransferItem.prototype.getAsEntry : DataTransferItem.prototype.webkitGetAsEntry && (r = DataTransferItem.prototype.webkitGetAsEntry)), r !== null) {
			let n = [];
			for (let s of o.items) {
				let l = r.call(s);
				l !== null && n.push(l)
			}
			i(n, s => {
				e(s)
			})
		} else e(o.files)
	}

	function Ei(o, e, t, i, r) {
		let n = X(o, "label");
		n.setAttribute("for", e);
		let s = X(n, "input", "ov_checkbox");
		return s.setAttribute("type", "checkbox"), s.setAttribute("id", e), s.checked = i, X(n, "span", null, t), r && s.addEventListener("change", r), s
	}

	function Un(o, e, t, i, r, n) {
		let s = X(o, "label");
		s.setAttribute("for", e);
		let l = X(s, "input", "ov_radio_button");
		return l.setAttribute("type", "radio"), l.setAttribute("id", e), l.setAttribute("name", t), l.checked = r, X(s, "span", null, i), n && l.addEventListener("change", n), l
	}

	function Hn(o, e, t) {
		let i = X(o, "input", "ov_slider");
		return i.setAttribute("type", "range"), i.setAttribute("min", e.toString()), i.setAttribute("max", t.toString()), i
	}

	function ur(o, e, t, i) {
		let r = v(o, "ov_select_container"),
			n = X(r, "select", "ov_select");
		for (let s of e) X(n, "option", null, s);
		return n.selectedIndex = t, i && n.addEventListener("change", () => {
			i(n.selectedIndex)
		}), n
	}

	function dr(o, e) {
		function t(l, a) {
			a ? l.classList.add("on") : l.classList.remove("on")
		}
		let i = !1,
			r = null,
			n = "ov_toggle";
		e && (n += " " + e);
		let s = v(o, n);
		return v(s, "ov_toggle_slider"), s.addEventListener("click", () => {
			i = !i, t(s, i), r && r()
		}), {
			element: s,
			GetStatus: () => i,
			SetStatus: l => {
				i = l, t(s, i)
			},
			OnChange: l => {
				r = l
			}
		}
	}
	var Ai = null;

	function zn(o) {
		Ai = o
	}

function te(o,e,t){Ai?.(o,e,t)}var T=class{constructor(e,t,i){this.x=e,this.y=t,this.z=i}
		Length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		}
		MultiplyScalar(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		}
		Normalize() {
			let e = this.Length();
			return e > 0 && this.MultiplyScalar(1 / e), this
		}
		Offset(e, t) {
			let i = e.Clone()
				.Normalize();
			return this.x += i.x * t, this.y += i.y * t, this.z += i.z * t, this
		}
		Rotate(e, t, i) {
			let r = e.Clone()
				.Normalize(),
				n = r.x,
				s = r.y,
				l = r.z,
				a = this.x - i.x,
				h = this.y - i.y,
				u = this.z - i.z,
				d = Math.sin(t),
				m = Math.cos(t);
			return this.x = -n * (-n * a - s * h - l * u) * (1 - m) + a * m + (-l * h + s * u) * d, this.y = -s * (-n * a - s * h - l * u) * (1 - m) + h * m + (l * a - n * u) * d, this.z = -l * (-n * a - s * h - l * u) * (1 - m) + u * m + (-s * a + n * h) * d, this.x += i.x, this.y += i.y, this.z += i.z, this
		}
		Clone() {
			return new T(this.x, this.y, this.z)
		}
	};

	function Ve(o, e) {
		return J(o.x, e.x) && J(o.y, e.y) && J(o.z, e.z)
	}

	function Wn(o, e) {
		return new T(o.x + e.x, o.y + e.y, o.z + e.z)
	}

	function oe(o, e) {
		return new T(o.x - e.x, o.y - e.y, o.z - e.z)
	}

	function Le(o, e) {
		return Math.sqrt((o.x - e.x) * (o.x - e.x) + (o.y - e.y) * (o.y - e.y) + (o.z - e.z) * (o.z - e.z))
	}

	function mr(o, e) {
		return o.x * e.x + o.y * e.y + o.z * e.z
	}

	function jn(o, e) {
		let t = o.Clone()
			.Normalize(),
			i = e.Clone()
			.Normalize();
		if (Ve(t, i)) return 0;
		let r = mr(t, i);
		return Math.acos(r)
	}

	function Ze(o, e) {
		let t = new T(0, 0, 0);
		return t.x = o.y * e.z - o.z * e.y, t.y = o.z * e.x - o.x * e.z, t.z = o.x * e.y - o.y * e.x, t
	}

	function Di(o, e, t) {
		return Math.sqrt(o * o + e * e + t * t)
	}

	function Qe(o) {
		return new T(o[0], o[1], o[2])
	}
	var $e = class {
		constructor(e, t, i) {
			this.eye = e, this.center = t, this.up = i
		}
		Clone() {
			return new $e(this.eye.Clone(), this.center.Clone(), this.up.Clone())
		}
	};

	function qn(o, e) {
		return Ve(o.eye, e.eye) && Ve(o.center, e.center) && Ve(o.up, e.up)
	}
	var de = {
			IntegerToString(o) {
				return o.toString()
			},
			StringToInteger(o) {
				return parseInt(o, 10)
			},
			NumberToString(o) {
				let e = 5;
				return o.toFixed(e)
			},
			StringToNumber(o) {
				return parseFloat(o)
			},
			ModelUrlsToString: function(o) {
				return o === null ? null : o.join(",")
			},
			StringToModelUrls: function(o) {
				return o === null || o.length === 0 ? null : o.split(",")
			},
			CameraToString: function(o) {
				return o === null ? null : [this.NumberToString(o.eye.x), this.NumberToString(o.eye.y), this.NumberToString(o.eye.z), this.NumberToString(o.center.x), this.NumberToString(o.center.y), this.NumberToString(o.center.z), this.NumberToString(o.up.x), this.NumberToString(o.up.y), this.NumberToString(o.up.z)].join(",")
			},
			StringToCamera: function(o) {
				if (o === null || o.length === 0) return null;
				let e = o.split(",");
				return e.length !== 9 ? null : new $e(new T(this.StringToNumber(e[0]), this.StringToNumber(e[1]), this.StringToNumber(e[2])), new T(this.StringToNumber(e[3]), this.StringToNumber(e[4]), this.StringToNumber(e[5])), new T(this.StringToNumber(e[6]), this.StringToNumber(e[7]), this.StringToNumber(e[8])))
			},
			ColorToString: function(o) {
				return o === null ? null : [this.IntegerToString(o.r), this.IntegerToString(o.g), this.IntegerToString(o.b)].join(",")
			},
			StringToColor: function(o) {
				if (o === null || o.length === 0) return null;
				let e = o.split(",");
				return e.length !== 3 ? null : new D(this.StringToInteger(e[0]), this.StringToInteger(e[1]), this.StringToInteger(e[2]))
			},
			EnvironmentSettingsToString(o) {
				return o === null ? null : [o.environmentMapName, o.backgroundIsEnvMap ? "on" : "off"].join(",")
			},
			StringToEnvironmentSettings: function(o) {
				if (o === null || o.length === 0) return null;
				let e = o.split(",");
				return e.length !== 2 ? null : {
					environmentMapName: e[0],
					backgroundIsEnvMap: e[1] === "on"
				}
			},
			EdgeSettingsToString: function(o) {
				return o === null ? null : [o.showEdges ? "on" : "off", this.ColorToString(o.edgeColor), this.IntegerToString(o.edgeThreshold)].join(",")
			},
			StringToEdgeSettings: function(o) {
				if (o === null || o.length === 0) return null;
				let e = o.split(",");
				return e.length !== 5 ? null : {
					showEdges: e[0] === "on",
					edgeColor: new D(this.StringToInteger(e[1]), this.StringToInteger(e[2]), this.StringToInteger(e[3])),
					edgeThreshold: this.StringToInteger(e[4])
				}
			}
		},
		Xn = class {
			constructor(e) {
				this.separator = e, this.paramList = ""
			}
			AddModelUrls(e) {
				return this.AddUrlPart("model", de.ModelUrlsToString(e)), this
			}
			AddCamera(e) {
				return this.AddUrlPart("camera", de.CameraToString(e)), this
			}
			AddEnvironmentSettings(e) {
				return this.AddUrlPart("envsettings", de.EnvironmentSettingsToString(e)), this
			}
			AddBackgroundColor(e) {
				return this.AddUrlPart("backgroundcolor", de.ColorToString(e)), this
			}
			AddDefaultColor(e) {
				return this.AddUrlPart("defaultcolor", de.ColorToString(e)), this
			}
			AddEdgeSettings(e) {
				return this.AddUrlPart("edgesettings", de.EdgeSettingsToString(e)), this
			}
			AddUrlPart(e, t) {
				e === null || t === null || (this.paramList.length > 0 && (this.paramList += this.separator), this.paramList += e + "=" + t)
			}
			GetParameterList() {
				return this.paramList
			}
		},
		Yn = class {
			constructor(e, t) {
				this.separator = t, this.paramList = e
			}
			GetModelUrls() {
				if (this.paramList.indexOf("=") === -1) return this.paramList.split(",");
				let e = this.GetKeywordParams("model");
				return de.StringToModelUrls(e)
			}
			GetCamera() {
				let e = this.GetKeywordParams("camera");
				return de.StringToCamera(e)
			}
			GetEnvironmentSettings() {
				let e = this.GetKeywordParams("envsettings");
				return de.StringToEnvironmentSettings(e)
			}
			GetBackgroundColor() {
				let e = this.GetKeywordParams("backgroundcolor");
				return de.StringToColor(e)
			}
			GetDefaultColor() {
				let e = this.GetKeywordParams("defaultcolor");
				return de.StringToColor(e)
			}
			GetEdgeSettings() {
				let e = this.GetKeywordParams("edgesettings");
				return de.StringToEdgeSettings(e)
			}
			GetKeywordParams(e) {
				if (this.paramList === null || this.paramList.length === 0) return null;
				let t = e + "=",
					i = this.paramList.split(this.separator);
				for (let r = 0; r < i.length; r++) {
					let n = i[r];
					if (n.startsWith(t)) return n.substring(t.length)
				}
				return null
			}
		};

	function Gi() {
		return new Xn("$")
	}

	function Tt(o) {
		return new Yn(o, "$")
	}

	function _i(o) {
		let e = Gi();
		return e.AddModelUrls(o), e.GetParameterList()
	}
	var Z = {
			Url: 1,
			File: 2,
			Decompressed: 3
		},
		R = {
			Text: 1,
			Binary: 2
		};

	function $(o) {
		let e = o.lastIndexOf("/");
		e === -1 && (e = o.lastIndexOf("\\"));
		let t = o;
		e !== -1 && (t = o.substring(e + 1));
		let i = t.indexOf("?");
		return i !== -1 && (t = t.substring(0, i)), decodeURI(t)
	}

	function Be(o) {
		let e = $(o),
			t = e.lastIndexOf(".");
		return t === -1 ? "" : e.substring(t + 1)
			.toLowerCase()
	}

	function Kn(o, e) {
		return new Promise((t, i) => {
			let r = new XMLHttpRequest;
			if (r.open("GET", o, !0), e === R.Text) r.responseType = "text";
			else if (e === R.Binary) r.responseType = "arraybuffer";
			else {
				i();
				return
			}
			r.onload = function() {
				r.status === 200 ? t(r.response) : i()
			}, r.onerror = function() {
				i()
			}, r.send(null)
		})
	}

	function Jn(o, e) {
		return new Promise((t, i) => {
			let r = new FileReader;
			r.onloadend = function(n) {
				n.target.readyState === FileReader.DONE && t(n.target.result)
			}, r.onerror = function() {
				i()
			}, e === R.Text ? r.readAsText(o) : e === R.Binary ? r.readAsArrayBuffer(o) : i()
		})
	}

	function Pi(o) {
		for (let e = 0; e < o.length; e++) {
			let t = o[e];
			if (t.search(/www\.dropbox\.com/u) !== -1) {
				t = t.replace("www.dropbox.com", "dl.dropbox.com");
				let i = t.indexOf("?");
				i !== -1 && (t = t.substring(0, i)), o[e] = t
			} else if (t.search(/github\.com/u) !== -1) {
				t = t.replace("github.com", "raw.githubusercontent.com"), t = t.replace("/blob", "");
				let i = t.indexOf("?");
				i !== -1 && (t = t.substring(0, i)), o[e] = t
			}
		}
	}
	var fr = class {
		constructor() {
			this.count = null, this.current = null, this.callbacks = null
		}
		Run(e, t) {
			this.count = e, this.current = 0, this.callbacks = t, e === 0 ? this.TaskReady() : this.RunOnce()
		}
		RunBatch(e, t, i) {
			let r = 0;
			e > 0 && (r = parseInt((e - 1) / t, 10) + 1), this.Run(r, {
				runTask: (n, s) => {
					let l = n * t,
						a = Math.min((n + 1) * t, e) - 1;
					i.runTask(l, a, s)
				},
				onReady: i.onReady
			})
		}
		RunOnce() {
			setTimeout(() => {
				this.callbacks.runTask(this.current, this.TaskReady.bind(this))
			}, 0)
		}
		TaskReady() {
			this.current += 1, this.current < this.count ? this.RunOnce() : this.callbacks.onReady && this.callbacks.onReady()
		}
	};

	function Mt(o) {
		setTimeout(() => {
			o()
		}, 0)
	}

	function Zn(o, e) {
		new fr()
			.Run(o, e)
	}

	function Qn(o, e, t) {
		new fr()
			.RunBatch(o, e, t)
	}

	function $n(o) {
		function e(t) {
			t() && setTimeout(() => {
				e(t)
			}, 1)
		}
		e(o)
	}
	var Fi = class {
			constructor(e, t) {
				this.source = t, t === Z.Url ? (this.fileUrl = e, this.fileObject = null, this.name = $(e), this.extension = Be(e)) : t === Z.File ? (this.fileUrl = null, this.fileObject = e, this.name = $(e.name), this.extension = Be(e.name)) : t === Z.Decompressed && (this.fileUrl = null, this.fileObject = null, this.name = $(e), this.extension = Be(e)), this.content = null
			}
			SetContent(e) {
				this.content = e
			}
		},
		Ri = class {
			constructor() {
				this.files = []
			}
			FillFromFileUrls(e) {
				this.Fill(e, Z.Url)
			}
			FillFromFileObjects(e) {
				this.Fill(e, Z.File)
			}
			ExtendFromFileList(e) {
				for (let t = 0; t < e.length; t++) {
					let i = e[t];
					this.ContainsFileByPath(i.name) || this.files.push(i)
				}
			}
			GetFiles() {
				return this.files
			}
			GetContent(e) {
				Zn(this.files.length, {
					runTask: (t, i) => {
						this.GetFileContent(this.files[t], i)
					},
					onReady: e
				})
			}
			ContainsFileByPath(e) {
				return this.FindFileByPath(e) !== null
			}
			FindFileByPath(e) {
				let t = $(e)
					.toLowerCase();
				for (let i = 0; i < this.files.length; i++) {
					let r = this.files[i];
					if (r.name.toLowerCase() === t) return r
				}
				return null
			}
			IsOnlyUrlSource() {
				if (this.files.length === 0) return !1;
				for (let e = 0; e < this.files.length; e++) {
					let t = this.files[e];
					if (t.source !== Z.Url && t.source !== Z.Decompressed) return !1
				}
				return !0
			}
			Fill(e, t) {
				this.files = [];
				for (let i = 0; i < e.length; i++) {
					let r = e[i],
						n = new Fi(r, t);
					this.AddFile(n)
				}
			}
			AddFile(e) {
				this.files.push(e)
			}
			GetFileContent(e, t) {
				if (e.content !== null) {
					t();
					return
				}
				let i = null;
				if (e.source === Z.Url) i = Kn(e.fileUrl, R.Binary);
				else if (e.source === Z.File) i = Jn(e.fileObject, R.Binary);
				else {
					t();
					return
				}
				i.then(r => {
						e.SetContent(r)
					})
					.catch(() => {})
					.finally(() => {
						t()
					})
			}
		};
	var ye = class {
		constructor(e, t, i, r) {
			this.x = e, this.y = t, this.z = i, this.w = r
		}
	};

	function Ut(o) {
		return new ye(o[0], o[1], o[2], o[3])
	}

	function es(o, e) {
		let t = e / 2,
			i = Math.sin(t);
		return new ye(o.x * i, o.y * i, o.z * i, Math.cos(t))
	}
	var We = class {
		constructor(e, t, i, r) {
			this.x = e, this.y = t, this.z = i, this.w = r
		}
		Clone() {
			return new We(this.x, this.y, this.z, this.w)
		}
	};
	var U = class {
		constructor(e) {
			this.matrix = null, e != null && (this.matrix = e)
		}
		IsValid() {
			return this.matrix !== null
		}
		Set(e) {
			return this.matrix = e, this
		}
		Get() {
			return this.matrix
		}
		Clone() {
			let e = [this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7], this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11], this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]];
			return new U(e)
		}
		CreateIdentity() {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this
		}
		IsIdentity() {
			let e = new U()
				.CreateIdentity()
				.Get();
			for (let t = 0; t < 16; t++)
				if (!J(this.matrix[t], e[t])) return !1;
			return !0
		}
		CreateTranslation(e, t, i) {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1], this
		}
		CreateRotation(e, t, i, r) {
			let n = e + e,
				s = t + t,
				l = i + i,
				a = e * n,
				h = e * s,
				u = e * l,
				d = t * s,
				m = t * l,
				f = i * l,
				p = r * n,
				c = r * s,
				g = r * l;
			return this.matrix = [1 - (d + f), h + g, u - c, 0, h - g, 1 - (a + f), m + p, 0, u + c, m - p, 1 - (a + d), 0, 0, 0, 0, 1], this
		}
		CreateRotationAxisAngle(e, t) {
			let i = es(e, t);
			return this.CreateRotation(i.x, i.y, i.z, i.w)
		}
		CreateScale(e, t, i) {
			return this.matrix = [e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1], this
		}
		ComposeTRS(e, t, i) {
			let r = e.x,
				n = e.y,
				s = e.z,
				l = t.x,
				a = t.y,
				h = t.z,
				u = t.w,
				d = i.x,
				m = i.y,
				f = i.z,
				p = l + l,
				c = a + a,
				g = h + h,
				x = l * p,
				C = l * c,
				M = l * g,
				I = a * c,
				b = a * g,
				w = h * g,
				y = u * p,
				E = u * c,
				S = u * g;
			return this.matrix = [(1 - (I + w)) * d, (C + S) * d, (M - E) * d, 0, (C - S) * m, (1 - (x + w)) * m, (b + y) * m, 0, (M + E) * f, (b - y) * f, (1 - (x + I)) * f, 0, r, n, s, 1], this
		}
		DecomposeTRS() {
			let e = new T(this.matrix[12], this.matrix[13], this.matrix[14]),
				t = Di(this.matrix[0], this.matrix[1], this.matrix[2]),
				i = Di(this.matrix[4], this.matrix[5], this.matrix[6]),
				r = Di(this.matrix[8], this.matrix[9], this.matrix[10]),
				n = this.Determinant();
			pt(n) && (t *= -1);
			let s = new T(t, i, r),
				l = this.matrix[0] / t,
				a = this.matrix[4] / i,
				h = this.matrix[8] / r,
				u = this.matrix[1] / t,
				d = this.matrix[5] / i,
				m = this.matrix[9] / r,
				f = this.matrix[2] / t,
				p = this.matrix[6] / i,
				c = this.matrix[10] / r,
				g = null,
				x = l + d + c;
			if (x > 0) {
				let C = Math.sqrt(x + 1) * 2;
				g = new ye((p - m) / C, (h - f) / C, (u - a) / C, .25 * C)
			} else if (l > d && l > c) {
				let C = Math.sqrt(1 + l - d - c) * 2;
				g = new ye(.25 * C, (a + u) / C, (h + f) / C, (p - m) / C)
			} else if (d > c) {
				let C = Math.sqrt(1 + d - l - c) * 2;
				g = new ye((a + u) / C, .25 * C, (m + p) / C, (h - f) / C)
			} else {
				let C = Math.sqrt(1 + c - l - d) * 2;
				g = new ye((h + f) / C, (m + p) / C, .25 * C, (u - a) / C)
			}
			return {
				translation: e,
				rotation: g,
				scale: s
			}
		}
		Determinant() {
			let e = this.matrix[0],
				t = this.matrix[1],
				i = this.matrix[2],
				r = this.matrix[3],
				n = this.matrix[4],
				s = this.matrix[5],
				l = this.matrix[6],
				a = this.matrix[7],
				h = this.matrix[8],
				u = this.matrix[9],
				d = this.matrix[10],
				m = this.matrix[11],
				f = this.matrix[12],
				p = this.matrix[13],
				c = this.matrix[14],
				g = this.matrix[15],
				x = e * s - t * n,
				C = e * l - i * n,
				M = e * a - r * n,
				I = t * l - i * s,
				b = t * a - r * s,
				w = i * a - r * l,
				y = h * p - u * f,
				E = h * c - d * f,
				S = h * g - m * f,
				A = u * c - d * p,
				k = u * g - m * p,
				F = d * g - m * c;
			return x * F - C * k + M * A + I * S - b * E + w * y
		}
		Invert() {
			let e = this.matrix[0],
				t = this.matrix[1],
				i = this.matrix[2],
				r = this.matrix[3],
				n = this.matrix[4],
				s = this.matrix[5],
				l = this.matrix[6],
				a = this.matrix[7],
				h = this.matrix[8],
				u = this.matrix[9],
				d = this.matrix[10],
				m = this.matrix[11],
				f = this.matrix[12],
				p = this.matrix[13],
				c = this.matrix[14],
				g = this.matrix[15],
				x = e * s - t * n,
				C = e * l - i * n,
				M = e * a - r * n,
				I = t * l - i * s,
				b = t * a - r * s,
				w = i * a - r * l,
				y = h * p - u * f,
				E = h * c - d * f,
				S = h * g - m * f,
				A = u * c - d * p,
				k = u * g - m * p,
				F = d * g - m * c,
				N = x * F - C * k + M * A + I * S - b * E + w * y;
			if (J(N, 0)) return null;
			let V = [(s * F - l * k + a * A) / N, (i * k - t * F - r * A) / N, (p * w - c * b + g * I) / N, (d * b - u * w - m * I) / N, (l * S - n * F - a * E) / N, (e * F - i * S + r * E) / N, (c * M - f * w - g * C) / N, (h * w - d * M + m * C) / N, (n * k - s * S + a * y) / N, (t * S - e * k - r * y) / N, (f * b - p * M + g * x) / N, (u * M - h * b - m * x) / N, (s * E - n * A - l * y) / N, (e * A - t * E + i * y) / N, (p * C - f * I - c * x) / N, (h * I - u * C + d * x) / N];
			return new U(V)
		}
		Transpose() {
			let e = [this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12], this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13], this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14], this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]];
			return new U(e)
		}
		InvertTranspose() {
			let e = this.Invert();
			return e === null ? null : e.Transpose()
		}
		MultiplyVector(e) {
			let t = e.x,
				i = e.y,
				r = e.z,
				n = e.w,
				s = this.matrix[0],
				l = this.matrix[1],
				a = this.matrix[2],
				h = this.matrix[3],
				u = this.matrix[4],
				d = this.matrix[5],
				m = this.matrix[6],
				f = this.matrix[7],
				p = this.matrix[8],
				c = this.matrix[9],
				g = this.matrix[10],
				x = this.matrix[11],
				C = this.matrix[12],
				M = this.matrix[13],
				I = this.matrix[14],
				b = this.matrix[15];
			return new We(t * s + i * u + r * p + n * C, t * l + i * d + r * c + n * M, t * a + i * m + r * g + n * I, t * h + i * f + r * x + n * b)
		}
		MultiplyMatrix(e) {
			let t = this.matrix[0],
				i = this.matrix[1],
				r = this.matrix[2],
				n = this.matrix[3],
				s = this.matrix[4],
				l = this.matrix[5],
				a = this.matrix[6],
				h = this.matrix[7],
				u = this.matrix[8],
				d = this.matrix[9],
				m = this.matrix[10],
				f = this.matrix[11],
				p = this.matrix[12],
				c = this.matrix[13],
				g = this.matrix[14],
				x = this.matrix[15],
				C = e.matrix[0],
				M = e.matrix[1],
				I = e.matrix[2],
				b = e.matrix[3],
				w = e.matrix[4],
				y = e.matrix[5],
				E = e.matrix[6],
				S = e.matrix[7],
				A = e.matrix[8],
				k = e.matrix[9],
				F = e.matrix[10],
				N = e.matrix[11],
				V = e.matrix[12],
				ae = e.matrix[13],
				H = e.matrix[14],
				Me = e.matrix[15],
				He = [t * C + i * w + r * A + n * V, t * M + i * y + r * k + n * ae, t * I + i * E + r * F + n * H, t * b + i * S + r * N + n * Me, s * C + l * w + a * A + h * V, s * M + l * y + a * k + h * ae, s * I + l * E + a * F + h * H, s * b + l * S + a * N + h * Me, u * C + d * w + m * A + f * V, u * M + d * y + m * k + f * ae, u * I + d * E + m * F + f * H, u * b + d * S + m * N + f * Me, p * C + c * w + g * A + x * V, p * M + c * y + g * k + x * ae, p * I + c * E + g * F + x * H, p * b + c * S + g * N + x * Me];
			return new U(He)
		}
	};
	var q = class {
		constructor(e) {
			e != null ? this.matrix = e : (this.matrix = new U, this.matrix.CreateIdentity())
		}
		SetMatrix(e) {
			return this.matrix = e, this
		}
		GetMatrix() {
			return this.matrix
		}
		IsIdentity() {
			return this.matrix.IsIdentity()
		}
		AppendMatrix(e) {
			return this.matrix = this.matrix.MultiplyMatrix(e), this
		}
		Append(e) {
			return this.AppendMatrix(e.GetMatrix()), this
		}
		TransformCoord3D(e) {
			let t = new We(e.x, e.y, e.z, 1),
				i = this.matrix.MultiplyVector(t);
			return new T(i.x, i.y, i.z)
		}
		Clone() {
			let e = this.matrix.Clone();
			return new q(e)
		}
	};
	var Oe = class {
		constructor() {
			this.name = null, this.url = null, this.buffer = null, this.offset = new O(0, 0), this.scale = new O(1, 1), this.rotation = 0
		}
		IsValid() {
			return this.name !== null && this.url !== null && this.buffer !== null
		}
		HasTransformation() {
			return !gt(this.offset, new O(0, 0)) || !gt(this.scale, new O(1, 1)) || !J(this.rotation, 0)
		}
		IsEqual(e) {
			return !(this.name !== e.name || this.url !== e.url || !gt(this.offset, e.offset) || !gt(this.scale, e.scale) || !J(this.rotation, e.rotation))
		}
	};

	function Ht(o, e) {
		return o === null && e === null ? !0 : o === null || e === null ? !1 : o.IsEqual(e)
	}
	var K = {
			Phong: 1,
			Physical: 2
		},
		ts = class {
			constructor(e) {
				this.type = e, this.isDefault = !1, this.name = "", this.color = new D(0, 0, 0), this.vertexColors = !1
			}
			IsEqual(e) {
				return !(this.type !== e.type || this.isDefault !== e.isDefault || this.name !== e.name || !vt(this.color, e.color) || this.vertexColors !== e.vertexColors)
			}
		},
		cr = class extends ts {
			constructor(e) {
				super(e);
				this.emissive = new D(0, 0, 0), this.opacity = 1, this.transparent = !1, this.diffuseMap = null, this.bumpMap = null, this.normalMap = null, this.emissiveMap = null, this.alphaTest = 0, this.multiplyDiffuseMap = !1
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !vt(this.emissive, e.emissive) || !J(this.opacity, e.opacity) || this.transparent !== e.transparent || !Ht(this.diffuseMap, e.diffuseMap) || !Ht(this.bumpMap, e.bumpMap) || !Ht(this.normalMap, e.normalMap) || !Ht(this.emissiveMap, e.emissiveMap) || !J(this.alphaTest, e.alphaTest) || this.multiplyDiffuseMap !== e.multiplyDiffuseMap)
			}
			EnumerateTextureMaps(e) {
				this.diffuseMap !== null && e(this.diffuseMap), this.bumpMap !== null && e(this.bumpMap), this.normalMap !== null && e(this.normalMap), this.emissiveMap !== null && e(this.emissiveMap)
			}
		},
		Q = class extends cr {
			constructor() {
				super(K.Phong);
				this.ambient = new D(0, 0, 0), this.specular = new D(0, 0, 0), this.shininess = 0, this.specularMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !vt(this.ambient, e.ambient) || !vt(this.specular, e.specular) || !J(this.shininess, e.shininess) || !Ht(this.specularMap, e.specularMap))
			}
			EnumerateTextureMaps(e) {
				super.EnumerateTextureMaps(e), this.specularMap !== null && e(this.specularMap)
			}
		},
		yt = class extends cr {
			constructor() {
				super(K.Physical);
				this.metalness = 0, this.roughness = 1, this.metalnessMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !J(this.metalness, e.metalness) || !J(this.roughness, e.roughness) || !Ht(this.metalnessMap, e.metalnessMap))
			}
			EnumerateTextureMaps(e) {
				super.EnumerateTextureMaps(e), this.metalnessMap !== null && e(this.metalnessMap)
			}
		};
	var lt = {
		Empty: 0,
		TriangleMesh: 1
	};

	function zt(o) {
		return o.TriangleCount() > 0 ? lt.TriangleMesh : lt.Empty
	}

	function Qt(o, e, t) {
		let i = oe(e, o),
			r = oe(t, o),
			n = Ze(i, r);
		return n.Normalize(), n
	}

	function at(o, e) {
		if (!e.IsIdentity()) {
			for (let t = 0; t < o.VertexCount(); t++) {
				let i = o.GetVertex(t),
					r = e.TransformCoord3D(i);
				i.x = r.x, i.y = r.y, i.z = r.z
			}
			if (o.NormalCount() > 0) {
				let t = e.GetMatrix()
					.InvertTranspose();
				if (t !== null) {
					let i = new q(t);
					for (let r = 0; r < o.NormalCount(); r++) {
						let n = o.GetNormal(r),
							s = i.TransformCoord3D(n);
						n.x = s.x, n.y = s.y, n.z = s.z
					}
				}
			}
		}
	}

	function is(o) {
		for (let e = 0; e < o.TriangleCount(); e++) {
			let t = o.GetTriangle(e),
				i = t.v1;
			t.v1 = t.v2, t.v2 = i
		}
	}
	var Ni = class {
			constructor(e, t) {
				this.min = e, this.max = t
			}
			GetMin() {
				return this.min
			}
			GetMax() {
				return this.max
			}
			GetCenter() {
				return new T((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, (this.min.z + this.max.z) / 2)
			}
		},
		pr = class {
			constructor() {
				this.box = new Ni(new T(1 / 0, 1 / 0, 1 / 0), new T(-1 / 0, -1 / 0, -1 / 0)), this.isValid = !1
			}
			GetBox() {
				return this.isValid ? this.box : null
			}
			AddPoint(e) {
				this.box.min.x = Math.min(this.box.min.x, e.x), this.box.min.y = Math.min(this.box.min.y, e.y), this.box.min.z = Math.min(this.box.min.z, e.z), this.box.max.x = Math.max(this.box.max.x, e.x), this.box.max.y = Math.max(this.box.max.y, e.y), this.box.max.z = Math.max(this.box.max.z, e.z), this.isValid = !0
			}
		};
	var Vi = class {
			constructor(e, t) {
				this.boundingBox = e, this.level = t, this.pointItems = [], this.childNodes = []
			}
			AddPoint(e, t, i) {
				let r = this.FindNodeForPoint(e);
				if (r === null || r.FindPointDirectly(e) !== null) return !1;
				if (r.pointItems.length < i.maxPointsPerNode || r.level >= i.maxTreeDepth) return r.AddPointDirectly(e, t), !0; {
					r.CreateChildNodes();
					let n = r.pointItems;
					r.pointItems = [];
					for (let s = 0; s < n.length; s++) {
						let l = n[s];
						if (!r.AddPoint(l.point, l.data, i)) return !1
					}
					return r.AddPoint(e, t, i)
				}
			}
			FindPoint(e) {
				let t = this.FindNodeForPoint(e);
				return t === null ? null : t.FindPointDirectly(e)
			}
			AddPointDirectly(e, t) {
				this.pointItems.push({
					point: e,
					data: t
				})
			}
			FindPointDirectly(e) {
				for (let t = 0; t < this.pointItems.length; t++) {
					let i = this.pointItems[t];
					if (Ve(e, i.point)) return i.data
				}
				return null
			}
			FindNodeForPoint(e) {
				if (!this.IsPointInBounds(e)) return null;
				if (this.childNodes.length === 0) return this;
				for (let t = 0; t < this.childNodes.length; t++) {
					let r = this.childNodes[t].FindNodeForPoint(e);
					if (r !== null) return r
				}
				return null
			}
			CreateChildNodes() {
				function e(l, a, h, u, d, m, f) {
					let p = new Ni(new T(a, h, u), new T(a + d, h + m, u + f));
					l.childNodes.push(new Vi(p, l.level + 1))
				}
				let t = this.boundingBox.min,
					i = this.boundingBox.GetCenter(),
					r = (this.boundingBox.max.x - this.boundingBox.min.x) / 2,
					n = (this.boundingBox.max.y - this.boundingBox.min.y) / 2,
					s = (this.boundingBox.max.z - this.boundingBox.min.z) / 2;
				e(this, t.x, t.y, t.z, r, n, s), e(this, i.x, t.y, t.z, r, n, s), e(this, t.x, i.y, t.z, r, n, s), e(this, i.x, i.y, t.z, r, n, s), e(this, t.x, t.y, i.z, r, n, s), e(this, i.x, t.y, i.z, r, n, s), e(this, t.x, i.y, i.z, r, n, s), e(this, i.x, i.y, i.z, r, n, s)
			}
			IsPointInBounds(e) {
				return vi(e.x, this.boundingBox.min.x) && vi(e.y, this.boundingBox.min.y) && vi(e.z, this.boundingBox.min.z) && Ci(e.x, this.boundingBox.max.x) && Ci(e.y, this.boundingBox.max.y) && Ci(e.z, this.boundingBox.max.z)
			}
		},
		gr = class {
			constructor(e, t) {
				this.options = {
					maxPointsPerNode: 10,
					maxTreeDepth: 10
				}, t !== void 0 && (t.maxPointsPerNode !== void 0 && (this.options.maxPointsPerNode = t.maxPointsPerNode), t.maxTreeDepth !== void 0 && (this.options.maxTreeDepth = t.maxTreeDepth)), this.rootNode = new Vi(e, 0)
			}
			AddPoint(e, t) {
				return this.rootNode.AddPoint(e, t, this.options)
			}
			FindPoint(e) {
				return this.rootNode.FindPoint(e)
			}
		};
	var rs = class {
			constructor() {
				this.edges = [], this.triangles = []
			}
		},
		ns = class {
			constructor(e, t) {
				this.vertex1 = e, this.vertex2 = t, this.triangles = []
			}
		},
		ss = class {
			constructor(e, t) {
				this.edge = e, this.reversed = t
			}
		},
		os = class {
			constructor() {
				this.triEdge1 = null, this.triEdge2 = null, this.triEdge3 = null
			}
		},
		xr = class {
			constructor() {
				this.vertices = [], this.edges = [], this.triangleEdges = [], this.triangles = [], this.edgeStartToEndVertexMap = new Map
			}
			AddVertex() {
				return this.vertices.push(new rs), this.vertices.length - 1
			}
			AddTriangle(e, t, i) {
				function r(h, u, d) {
					h[u].triangles.push(d)
				}

				function n(h, u, d, m) {
					let f = h[d],
						p = u[m];
					f.edges.push(p.edge)
				}

				function s(h, u, d, m) {
					let f = u[d];
					h[f.edge].triangles.push(m)
				}
				let l = this.triangles.length,
					a = new os;
				a.triEdge1 = this.AddTriangleEdge(e, t), a.triEdge2 = this.AddTriangleEdge(t, i), a.triEdge3 = this.AddTriangleEdge(i, e), r(this.vertices, e, l), r(this.vertices, t, l), r(this.vertices, i, l), n(this.vertices, this.triangleEdges, e, a.triEdge1), n(this.vertices, this.triangleEdges, t, a.triEdge2), n(this.vertices, this.triangleEdges, i, a.triEdge3), s(this.edges, this.triangleEdges, a.triEdge1, l), s(this.edges, this.triangleEdges, a.triEdge2, l), s(this.edges, this.triangleEdges, a.triEdge3, l), this.triangles.push(a)
			}
			AddTriangleEdge(e, t) {
				let i = e,
					r = t,
					n = !1;
				t < e && (i = t, r = e, n = !0);
				let s = this.AddEdge(i, r);
				return this.triangleEdges.push(new ss(s, n)), this.triangleEdges.length - 1
			}
			AddEdge(e, t) {
				this.edgeStartToEndVertexMap.has(e) || this.edgeStartToEndVertexMap.set(e, []);
				let i = this.edgeStartToEndVertexMap.get(e);
				for (let n = 0; n < i.length; n++) {
					let s = i[n];
					if (s.endVertex === t) return s.edgeIndex
				}
				let r = this.edges.length;
				return i.push({
					endVertex: t,
					edgeIndex: r
				}), this.edges.push(new ns(e, t)), r
			}
		};

	function Li(o) {
		let e = !0;
		return o.EnumerateMeshInstances(t => {
			zt(t) !== lt.Empty && (e = !1)
		}), e
	}

	function Cr(o) {
		let e = new pr;
		return o.EnumerateVertices(t => {
			e.AddPoint(t)
		}), e.GetBox()
	}

	function go(o) {
		function e(n, s, l) {
			let a = s.FindPoint(n);
			return a === null && (a = l.AddVertex(), s.AddPoint(n, a)), a
		}
		let t = Cr(o),
			i = new gr(t),
			r = new xr;
		return o.EnumerateTriangleVertices((n, s, l) => {
			let a = e(n, i, r),
				h = e(s, i, r),
				u = e(l, i, r);
			r.AddTriangle(a, h, u)
		}), r
	}

	function ls(o) {
		function e(i, r, n) {
			let s = i.triangles[r],
				l = i.triangleEdges[s.triEdge1],
				a = i.triangleEdges[s.triEdge2],
				h = i.triangleEdges[s.triEdge3];
			return l.edge === n ? l.reversed : a.edge === n ? a.reversed : h.edge === n ? h.reversed : null
		}
		let t = go(o);
		for (let i = 0; i < t.edges.length; i++) {
			let r = t.edges[i],
				n = r.triangles.length;
			if (n === 0 || n % 2 !== 0) return !1;
			let s = 0;
			for (let l = 0; l < r.triangles.length; l++) {
				let a = r.triangles[l];
				e(t, a, i) ? s += 1 : s -= 1
			}
			if (s !== 0) return !1
		}
		return !0
	}

	function as(o) {
		for (let e = 0; e < o.MaterialCount(); e++) {
			let t = o.GetMaterial(e);
			if (t.isDefault && !t.vertexColors) return !0
		}
		return !1
	}

	function vr(o, e) {
		for (let t = 0; t < o.MaterialCount(); t++) {
			let i = o.GetMaterial(t);
			i.isDefault && (i.color = e)
		}
	}
	var P = {
			Text: 1,
			Integer: 2,
			Number: 3,
			Boolean: 4,
			Percent: 5,
			Color: 6
		},
		B = class {
			constructor(e, t, i) {
				this.type = e, this.name = t, this.value = i
			}
		},
		Ge = class {
			constructor(e) {
				this.name = e, this.properties = []
			}
			PropertyCount() {
				return this.properties.length
			}
			AddProperty(e) {
				this.properties.push(e)
			}
			GetProperty(e) {
				return this.properties[e]
			}
		};
	var hs = class {
			constructor() {}
			VertexCount() {
				return 0
			}
			VertexColorCount() {
				return 0
			}
			NormalCount() {
				return 0
			}
			TextureUVCount() {
				return 0
			}
			TriangleCount() {
				return 0
			}
			EnumerateVertices(e) {}
			EnumerateTriangleVertexIndices(e) {}
			EnumerateTriangleVertices(e) {}
		},
		bt = class extends hs {
			constructor() {
				super();
				this.name = "", this.propertyGroups = []
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			PropertyGroupCount() {
				return this.propertyGroups.length
			}
			AddPropertyGroup(e) {
				return this.propertyGroups.push(e), this.propertyGroups.length - 1
			}
			GetPropertyGroup(e) {
				return this.propertyGroups[e]
			}
		};
	var Y = class extends bt {
		constructor() {
			super();
			this.vertices = [], this.vertexColors = [], this.normals = [], this.uvs = [], this.triangles = []
		}
		VertexCount() {
			return this.vertices.length
		}
		VertexColorCount() {
			return this.vertexColors.length
		}
		NormalCount() {
			return this.normals.length
		}
		TextureUVCount() {
			return this.uvs.length
		}
		TriangleCount() {
			return this.triangles.length
		}
		AddVertex(e) {
			return this.vertices.push(e), this.vertices.length - 1
		}
		SetVertex(e, t) {
			this.vertices[e] = t
		}
		GetVertex(e) {
			return this.vertices[e]
		}
		AddVertexColor(e) {
			return this.vertexColors.push(e), this.vertexColors.length - 1
		}
		SetVertexColor(e, t) {
			this.vertexColors[e] = t
		}
		GetVertexColor(e) {
			return this.vertexColors[e]
		}
		AddNormal(e) {
			return this.normals.push(e), this.normals.length - 1
		}
		SetNormal(e, t) {
			this.normals[e] = t
		}
		GetNormal(e) {
			return this.normals[e]
		}
		AddTextureUV(e) {
			return this.uvs.push(e), this.uvs.length - 1
		}
		SetTextureUV(e, t) {
			this.uvs[e] = t
		}
		GetTextureUV(e) {
			return this.uvs[e]
		}
		AddTriangle(e) {
			return this.triangles.push(e), this.triangles.length - 1
		}
		GetTriangle(e) {
			return this.triangles[e]
		}
		EnumerateVertices(e) {
			for (let t of this.vertices) e(t)
		}
		EnumerateTriangleVertexIndices(e) {
			for (let t of this.triangles) e(t.v0, t.v1, t.v2)
		}
		EnumerateTriangleVertices(e) {
			for (let t of this.triangles) {
				let i = this.vertices[t.v0],
					r = this.vertices[t.v1],
					n = this.vertices[t.v2];
				e(i, r, n)
			}
		}
		Clone() {
			let e = new Y;
			e.SetName(this.GetName());
			for (let t = 0; t < this.VertexCount(); t++) {
				let i = this.GetVertex(t);
				e.AddVertex(i.Clone())
			}
			for (let t = 0; t < this.VertexColorCount(); t++) {
				let i = this.GetVertexColor(t);
				e.AddVertexColor(i.Clone())
			}
			for (let t = 0; t < this.NormalCount(); t++) {
				let i = this.GetNormal(t);
				e.AddNormal(i.Clone())
			}
			for (let t = 0; t < this.TextureUVCount(); t++) {
				let i = this.GetTextureUV(t);
				e.AddTextureUV(i.Clone())
			}
			for (let t = 0; t < this.TriangleCount(); t++) {
				let i = this.GetTriangle(t);
				e.AddTriangle(i.Clone())
			}
			return e
		}
	};
	var z = class {
		constructor(e, t, i) {
			this.v0 = e, this.v1 = t, this.v2 = i, this.c0 = null, this.c1 = null, this.c2 = null, this.n0 = null, this.n1 = null, this.n2 = null, this.u0 = null, this.u1 = null, this.u2 = null, this.mat = null, this.curve = null
		}
		HasVertices() {
			return this.v0 !== null && this.v1 !== null && this.v2 !== null
		}
		HasVertexColors() {
			return this.c0 !== null && this.c1 !== null && this.c2 !== null
		}
		HasNormals() {
			return this.n0 !== null && this.n1 !== null && this.n2 !== null
		}
		HasTextureUVs() {
			return this.u0 !== null && this.u1 !== null && this.u2 !== null
		}
		SetVertices(e, t, i) {
			return this.v0 = e, this.v1 = t, this.v2 = i, this
		}
		SetVertexColors(e, t, i) {
			return this.c0 = e, this.c1 = t, this.c2 = i, this
		}
		SetNormals(e, t, i) {
			return this.n0 = e, this.n1 = t, this.n2 = i, this
		}
		SetTextureUVs(e, t, i) {
			return this.u0 = e, this.u1 = t, this.u2 = i, this
		}
		SetMaterial(e) {
			return this.mat = e, this
		}
		SetCurve(e) {
			return this.curve = e, this
		}
		Clone() {
			let e = new z(this.v0, this.v1, this.v2);
			return e.SetVertexColors(this.c0, this.c1, this.c2), e.SetNormals(this.n0, this.n1, this.n2), e.SetTextureUVs(this.u0, this.u1, this.u2), e.SetMaterial(this.mat), e.SetCurve(this.curve), e
		}
	};

	function us() {
		let o = document.createElement("canvas");
		document.body.appendChild(o);
		let e = {
				canvas: o,
				antialias: !0
			},
			t = new THREE.WebGLRenderer(e);
		t.setClearColor("#ffffff", 1), t.setSize(10, 10);
		let i = new THREE.Scene,
			r = new THREE.AmbientLight(8947848);
		i.add(r);
		let n = new THREE.DirectionalLight(8947848);
		n.position.set(0, 0, 1), i.add(n);
		let s = new THREE.PerspectiveCamera(45, 1, .1, 1e3);
		s.position.set(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(new THREE.Vector3(0, 0, 0)), i.add(s);
		let l = new THREE.PlaneGeometry(1, 1),
			a = new THREE.Mesh(l, new THREE.MeshPhongMaterial({
				color: 13369344
			}));
		i.add(a), t.render(i, s);
		let h = t.getContext(),
			u = new Uint8Array(4);
		h.readPixels(5, 5, 1, 1, h.RGBA, h.UNSIGNED_BYTE, u), document.body.removeChild(o);
		let d = 50;
		return u[0] < d && u[1] < d && u[2] < d
	}
	var me = {
		Phong: 1,
		Physical: 2
	};

	function ds(o) {
		let e = 0,
			t = 0;
		for (let i = 0; i < o.MaterialCount(); i++) {
			let r = o.GetMaterial(i);
			r.type === K.Phong ? e += 1 : r.type === K.Physical && (t += 1)
		}
		return e >= t ? me.Phong : me.Physical
	}

	function Bi(o) {
		return Ne(o.r, o.g, o.b)
	}

	function _e(o) {
		return new THREE.Color(o.r / 255, o.g / 255, o.b / 255)
	}

	function St(o, e) {
		let t = new Y,
			i = o.attributes.position.array,
			r = o.attributes.position.itemSize || 3;
		for (let h = 0; h < i.length; h += r) {
			let u = i[h],
				d = i[h + 1],
				m = i[h + 2];
			t.AddVertex(new T(u, d, m))
		}
		let n = o.attributes.color !== void 0;
		if (n) {
			let h = o.attributes.color.array,
				u = o.attributes.color.itemSize || 3;
			for (let d = 0; d < h.length; d += u) {
				let m = new THREE.Color(h[d], h[d + 1], h[d + 2]);
				t.AddVertexColor(Bi(m))
			}
		}
		let s = o.attributes.normal !== void 0;
		if (s) {
			let h = o.attributes.normal.array,
				u = o.attributes.normal.itemSize || 3;
			for (let d = 0; d < h.length; d += u) {
				let m = h[d],
					f = h[d + 1],
					p = h[d + 2];
				t.AddNormal(new T(m, f, p))
			}
		}
		let l = o.attributes.uv !== void 0;
		if (l) {
			let h = o.attributes.uv.array,
				u = o.attributes.uv.itemSize || 2;
			for (let d = 0; d < h.length; d += u) {
				let m = h[d],
					f = h[d + 1];
				t.AddTextureUV(new O(m, f))
			}
		}
		let a = null;
		if (o.index !== null) a = o.index.array;
		else {
			a = [];
			for (let h = 0; h < i.length / 3; h++) a.push(h)
		}
		for (let h = 0; h < a.length; h += 3) {
			let u = a[h],
				d = a[h + 1],
				m = a[h + 2],
				f = new z(u, d, m);
			n && f.SetVertexColors(u, d, m), s && f.SetNormals(u, d, m), l && f.SetTextureUVs(u, d, m), e !== null && f.SetMaterial(e), t.AddTriangle(f)
		}
		return t
	}
	var ht = class {
			constructor(e, t) {
				this.nodeId = e, this.meshIndex = t
			}
			IsEqual(e) {
				return this.nodeId === e.nodeId && this.meshIndex === e.meshIndex
			}
			GetKey() {
				return this.nodeId.toString() + ":" + this.meshIndex.toString()
			}
		},
		Oi = class extends bt {
			constructor(e, t, i) {
				super();
				this.id = e, this.node = t, this.mesh = i
			}
			GetId() {
				return this.id
			}
			GetTransformation() {
				return this.node.GetWorldTransformation()
			}
			GetMesh() {
				return this.mesh
			}
			VertexCount() {
				return this.mesh.VertexCount()
			}
			VertexColorCount() {
				return this.mesh.VertexColorCount()
			}
			NormalCount() {
				return this.mesh.NormalCount()
			}
			TextureUVCount() {
				return this.mesh.TextureUVCount()
			}
			TriangleCount() {
				return this.mesh.TriangleCount()
			}
			EnumerateVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateVertices(e) : this.mesh.EnumerateVertices(i => {
					let r = t.TransformCoord3D(i);
					e(r)
				})
			}
			EnumerateTriangleVertexIndices(e) {
				this.mesh.EnumerateTriangleVertexIndices(e)
			}
			EnumerateTriangleVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateTriangleVertices(e) : this.mesh.EnumerateTriangleVertices((i, r, n) => {
					let s = t.TransformCoord3D(i),
						l = t.TransformCoord3D(r),
						a = t.TransformCoord3D(n);
					e(s, l, a)
				})
			}
			PropertyGroupCount() {
				return this.mesh.PropertyGroupCount()
			}
			AddPropertyGroup(e) {
				return this.mesh.AddPropertyGroup(e)
			}
			GetPropertyGroup(e) {
				return this.mesh.GetPropertyGroup(e)
			}
			GetTransformedMesh() {
				let e = this.node.GetWorldTransformation(),
					t = this.mesh.Clone();
				return at(t, e), t
			}
		};
	var ms = class {
			constructor() {
				this.nextId = 0
			}
			GenerateId() {
				let e = this.nextId;
				return this.nextId += 1, e
			}
		},
		fe = {
			GroupNode: 0,
			MeshNode: 1
		},
		be = class {
			constructor() {
				this.type = fe.GroupNode, this.name = "", this.parent = null, this.transformation = new q, this.childNodes = [], this.meshIndices = [], this.idGenerator = new ms, this.id = this.idGenerator.GenerateId()
			}
			IsEmpty() {
				return this.childNodes.length === 0 && this.meshIndices.length === 0
			}
			GetType() {
				return this.type
			}
			SetType(e) {
				this.type = e
			}
			GetId() {
				return this.id
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			HasParent() {
				return this.parent !== null
			}
			GetParent() {
				return this.parent
			}
			GetTransformation() {
				return this.transformation
			}
			GetWorldTransformation() {
				let e = this.transformation.Clone(),
					t = this.parent;
				for (; t !== null;) e.Append(t.transformation), t = t.parent;
				return e
			}
			SetTransformation(e) {
				this.transformation = e
			}
			AddChildNode(e) {
				return e.parent = this, e.idGenerator = this.idGenerator, e.id = e.idGenerator.GenerateId(), this.childNodes.push(e), this.childNodes.length - 1
			}
			RemoveChildNode(e) {
				e.parent = null;
				let t = this.childNodes.indexOf(e);
				this.childNodes.splice(t, 1)
			}
			GetChildNodes() {
				return this.childNodes
			}
			ChildNodeCount() {
				return this.childNodes.length
			}
			GetChildNode(e) {
				return this.childNodes[e]
			}
			AddMeshIndex(e) {
				return this.meshIndices.push(e), this.meshIndices.length - 1
			}
			MeshIndexCount() {
				return this.meshIndices.length
			}
			GetMeshIndex(e) {
				return this.meshIndices[e]
			}
			GetMeshIndices() {
				return this.meshIndices
			}
			Enumerate(e) {
				e(this);
				for (let t of this.childNodes) t.Enumerate(e)
			}
			EnumerateChildren(e) {
				for (let t of this.childNodes) e(t), t.EnumerateChildren(e)
			}
			EnumerateMeshIndices(e) {
				for (let t of this.meshIndices) e(t);
				for (let t of this.childNodes) t.EnumerateMeshIndices(e)
			}
		};
	var Ir = class extends bt {
		constructor() {
			super();
			this.root = new be, this.materials = [], this.meshes = []
		}
		GetRootNode() {
			return this.root
		}
		MaterialCount() {
			return this.materials.length
		}
		MeshCount() {
			return this.meshes.length
		}
		MeshInstanceCount() {
			let e = 0;
			return this.root.Enumerate(t => {
				e += t.MeshIndexCount()
			}), e
		}
		VertexCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexCount()
			}), e
		}
		VertexColorCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexColorCount()
			}), e
		}
		NormalCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.NormalCount()
			}), e
		}
		TextureUVCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TextureUVCount()
			}), e
		}
		TriangleCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TriangleCount()
			}), e
		}
		AddMaterial(e) {
			return this.materials.push(e), this.materials.length - 1
		}
		GetMaterial(e) {
			return this.materials[e]
		}
		AddMesh(e) {
			return this.meshes.push(e), this.meshes.length - 1
		}
		AddMeshToRootNode(e) {
			let t = this.AddMesh(e);
			return this.root.AddMeshIndex(t), t
		}
		RemoveMesh(e) {
			this.meshes.splice(e, 1), this.root.Enumerate(t => {
				for (let i = 0; i < t.meshIndices.length; i++) t.meshIndices[i] === e ? (t.meshIndices.splice(i, 1), i -= 1) : t.meshIndices[i] > e && (t.meshIndices[i] -= 1)
			})
		}
		GetMesh(e) {
			return this.meshes[e]
		}
		GetMeshInstance(e) {
			let t = null;
			if (this.root.Enumerate(s => {
					s.GetId() === e.nodeId && (t = s)
				}), t === null || t.GetMeshIndices()
				.indexOf(e.meshIndex) === -1) return null;
			let r = this.GetMesh(e.meshIndex),
				n = new ht(t.GetId(), e.meshIndex);
			return new Oi(n, t, r)
		}
		EnumerateMeshes(e) {
			for (let t of this.meshes) e(t)
		}
		EnumerateMeshInstances(e) {
			this.root.Enumerate(t => {
				for (let i of t.GetMeshIndices()) {
					let r = new ht(t.GetId(), i),
						n = this.GetMesh(i),
						s = new Oi(r, t, n);
					e(s)
				}
			})
		}
		EnumerateTransformedMeshes(e) {
			this.EnumerateMeshInstances(t => {
				let i = t.GetTransformedMesh();
				e(i)
			})
		}
		EnumerateVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateVertices(e)
			})
		}
		EnumerateTriangleVertexIndices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertexIndices(e)
			})
		}
		EnumerateTriangleVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertices(e)
			})
		}
	};

	function Wt(o) {
		return o != null
	}

	function je(o,e){return o??e}

	function ki(o, e) {
		if (!!Wt(o))
			for (let t of Object.keys(o)) Wt(o[t]) && (e[t] = o[t])
	}
	var fs = class {
		constructor(e) {
			this.params = {
				getDefaultMaterialColor: () => new D(0, 0, 0)
			}, ki(e, this.params), this.defaultMaterialIndex = null
		}
		Finalize(e) {
			this.Reset(), this.FinalizeMeshes(e), this.FinalizeMaterials(e), this.FinalizeNodes(e)
		}
		FinalizeMaterials(e) {
			if (!(e.VertexColorCount() > 0)) return;
			let i = new Map;
			for (let r = 0; r < e.MeshCount(); r++) {
				let n = e.GetMesh(r);
				for (let s = 0; s < n.TriangleCount(); s++) {
					let l = n.GetTriangle(s),
						a = l.HasVertexColors();
					i.has(l.mat) ? a || i.set(l.mat, !1) : i.set(l.mat, a)
				}
			}
			for (let [r, n] of i) {
				let s = e.GetMaterial(r);
				s.vertexColors = n
			}
		}
		FinalizeMeshes(e) {
			for (let t = 0; t < e.MeshCount(); t++) {
				let i = e.GetMesh(t);
				if (zt(i) === lt.Empty) {
					e.RemoveMesh(t), t = t - 1;
					continue
				}
				this.FinalizeMesh(e, i)
			}
		}
		FinalizeMesh(e, t) {
			function i(n) {
				function s(h, u, d, m, f) {
					function p(C, M) {
						for (let I = 0; I < C.length; I++) {
							let b = C[I];
							if (Ve(b, M)) return !0
						}
						return !1
					}
					let c = [],
						g = f.get(d);
					for (let C = 0; C < g.length; C++) {
						let M = g[C],
							I = h.GetTriangle(M);
						if (u.curve === I.curve) {
							let b = m[M];
							p(c, b) || c.push(b)
						}
					}
					let x = new T(0, 0, 0);
					for (let C = 0; C < c.length; C++) x = Wn(x, c[C]);
					return x.MultiplyScalar(1 / c.length), x.Normalize(), h.AddNormal(x)
				}
				let l = [],
					a = new Map;
				for (let h = 0; h < n.VertexCount(); h++) a.set(h, []);
				for (let h = 0; h < n.TriangleCount(); h++) {
					let u = n.GetTriangle(h),
						d = n.GetVertex(u.v0),
						m = n.GetVertex(u.v1),
						f = n.GetVertex(u.v2),
						p = Qt(d, m, f);
					l.push(p), a.get(u.v0)
						.push(h), a.get(u.v1)
						.push(h), a.get(u.v2)
						.push(h)
				}
				for (let h = 0; h < n.TriangleCount(); h++) {
					let u = n.GetTriangle(h);
					if (!u.HasNormals()) {
						let d = s(n, u, u.v0, l, a),
							m = s(n, u, u.v1, l, a),
							f = s(n, u, u.v2, l, a);
						u.SetNormals(d, m, f)
					}
				}
			}
			let r = {
				calculateCurveNormals: !1
			};
			for (let n = 0; n < t.TriangleCount(); n++) {
				let s = t.GetTriangle(n);
				this.FinalizeTriangle(t, s, r), s.mat === null && (s.mat = this.GetDefaultMaterialIndex(e))
			}
			r.calculateCurveNormals && i(t)
		}
		FinalizeTriangle(e, t, i) {
			if (!t.HasNormals())
				if (t.curve === null || t.curve === 0) {
					let r = e.GetVertex(t.v0),
						n = e.GetVertex(t.v1),
						s = e.GetVertex(t.v2),
						l = Qt(r, n, s),
						a = e.AddNormal(l);
					t.SetNormals(a, a, a)
				} else i.calculateCurveNormals = !0;
			t.curve === null && (t.curve = 0)
		}
		FinalizeNodes(e) {
			let t = e.GetRootNode(),
				i = [];
			t.EnumerateChildren(r => {
				r.IsEmpty() && i.push(r)
			});
			for (let r = 0; r < i.length; r++) {
				let n = i[r],
					s = n.GetParent();
				s !== null && (s.RemoveChildNode(n), s.IsEmpty() && i.push(s))
			}
		}
		GetDefaultMaterialIndex(e) {
			if (this.defaultMaterialIndex === null) {
				let t = this.params.getDefaultMaterialColor(),
					i = new Q;
				i.color = t, i.isDefault = !0, this.defaultMaterialIndex = e.AddMaterial(i)
			}
			return this.defaultMaterialIndex
		}
		Reset() {
			this.defaultMaterialIndex = null
		}
	};

	function cs(o, e) {
		new fs(e)
			.Finalize(o)
	}
	var W = class {
		constructor() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null
		}
		Import(e, t, i, r) {
			this.Clear(), this.name = e, this.extension = t, this.callbacks = r, this.model = new Ir, this.error = !1, this.message = null, this.ResetContent(), this.ImportContent(i, () => {
				this.CreateResult(r)
			})
		}
		Clear() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null, this.ClearContent()
		}
		CreateResult(e) {
			if (this.error) {
				e.onError(), e.onComplete();
				return
			}
			if (Li(this.model)) {
				this.SetError("The model doesn't contain any meshes."), e.onError(), e.onComplete();
				return
			}
			cs(this.model, {
				getDefaultMaterialColor: this.callbacks.getDefaultMaterialColor
			}), e.onSuccess(), e.onComplete()
		}
		CanImportExtension(e) {
			return !1
		}
		GetUpDirection() {
			return G.Z
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {}
		GetModel() {
			return this.model
		}
		SetError(e) {
			this.error = !0, e != null && (this.message = e)
		}
		WasError() {
			return this.error
		}
		GetErrorMessage() {
			return this.message
		}
	};

	function ut(o, e, t) {
		let i = o.substring(e),
			r = i.indexOf(t);
		return r !== -1 && (i = i.substring(0, r)), i.trim()
	}

	function et(o, e) {
		if (e !== null) {
			let t = o.indexOf(e);
			t !== -1 && (o = o.substring(0, t)
				.trim())
		}
		return o.split(/\s+/u)
	}

	function Pe(o, e) {
		function t(n, s) {
			let l = n.trim();
			l.length > 0 && s(l)
		}
		let i = 0,
			r = o.indexOf(`
`, i);
		for (; r !== -1;) t(o.substring(i, r), e), i = r + 1, r = o.indexOf(`
`, i);
		t(o.substring(i), e)
	}

	function ce(o) {
		o.transparent = !1, xi(o.opacity, 1) && (o.transparent = !0)
	}
	var Tr = class {
		constructor(e) {
			this.createMaterialFunc = e, this.colorToMaterialIndex = new Map
		}
		GetMaterialIndex(e) {
			let t = ue(e);
			if (this.colorToMaterialIndex.has(t)) return this.colorToMaterialIndex.get(t); {
				let i = this.createMaterialFunc(e);
				return this.colorToMaterialIndex.set(t, i), i
			}
		}
	};
	var Mr = class extends W {
		constructor() {
			super();
			this.rhino = null
		}
		CanImportExtension(e) {
			return e === "3dm"
		}
		GetUpDirection() {
			return G.Z
		}
		ClearContent() {
			this.instanceIdToObject = null, this.instanceIdToDefinition = null
		}
		ResetContent() {
			this.instanceIdToObject = new Map, this.instanceIdToDefinition = new Map
		}
		ImportContent(e, t) {
			this.rhino === null ? xe("loaders/rhino3dm.min.js")
				.then(() => {
					rhino3dm()
						.then(i => {
							this.rhino = i, this.ImportRhinoContent(e), t()
						})
				})
				.catch(() => {
					this.SetError("Failed to load rhino3dm."), t()
				}) : (this.ImportRhinoContent(e), t())
		}
		ImportRhinoContent(e) {
			let t = this.rhino.File3dm.fromByteArray(e);
			if (t === null) {
				this.SetError("Failed to read Rhino file.");
				return
			}
			this.ImportRhinoDocument(t), Li(this.model) && this.SetError("The model doesn't contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.")
		}
		ImportRhinoDocument(e) {
			this.InitRhinoInstances(e), this.ImportRhinoUserStrings(e), this.ImportRhinoGeometry(e)
		}
		InitRhinoInstances(e) {
			let t = e.objects();
			for (let r = 0; r < t.count; r++) {
				let n = t.get(r),
					s = n.attributes();
				s.isInstanceDefinitionObject && this.instanceIdToObject.set(s.id, n)
			}
			let i = e.instanceDefinitions();
			for (let r = 0; r < i.count(); r++) {
				let n = i.get(r);
				this.instanceIdToDefinition.set(n.id, n)
			}
		}
		ImportRhinoUserStrings(e) {
			let t = e.strings();
			if (t.count() > 0) {
				let i = new Ge("Document user texts");
				for (let r = 0; r < t.count(); r++) {
					let n = t.get(r);
					i.AddProperty(new B(P.Text, n[0], n[1]))
				}
				this.model.AddPropertyGroup(i)
			}
		}
		ImportRhinoGeometry(e) {
			let t = e.objects();
			for (let i = 0; i < t.count; i++) {
				let r = t.get(i);
				this.ImportRhinoGeometryObject(e, r, [])
			}
		}
		ImportRhinoGeometryObject(e, t, i) {
			let r = t.geometry(),
				n = t.attributes(),
				s = r.objectType;
			if (n.isInstanceDefinitionObject && i.length === 0) return;
			let l = null,
				a = !1;
			if (s === this.rhino.ObjectType.Mesh) l = r, a = !1;
			else if (s === this.rhino.ObjectType.Extrusion) l = r.getMesh(this.rhino.MeshType.Any), a = !0;
			else if (s === this.rhino.ObjectType.Brep) {
				l = new this.rhino.Mesh;
				let h = r.faces();
				for (let u = 0; u < h.count; u++) {
					let d = h.get(u),
						m = d.getMesh(this.rhino.MeshType.Any);
					m && (l.append(m), m.delete()), d.delete()
				}
				h.delete(), l.compact(), a = !0
			} else if (s === this.rhino.ObjectType.SubD) r.subdivide(3), l = this.rhino.Mesh.createFromSubDControlNet(r), a = !0;
			else if (s === this.rhino.ObjectType.InstanceReference) {
				let h = r.parentIdefId;
				if (this.instanceIdToDefinition.has(h)) {
					let d = this.instanceIdToDefinition.get(h)
						.getObjectIds();
					for (let m = 0; m < d.length; m++) {
						let f = d[m];
						if (this.instanceIdToObject.has(f)) {
							let p = this.instanceIdToObject.get(f);
							i.push(t), this.ImportRhinoGeometryObject(e, p, i), i.pop()
						}
					}
				}
			}
			l !== null && (this.ImportRhinoMesh(e, l, t, i), a && l.delete())
		}
		ImportRhinoMesh(e, t, i, r) {
			let n = i.attributes(),
				s = this.GetMaterialIndex(e, i, r),
				l = t.toThreejsJSON(),
				a = St(l.data, s);
			a.SetName(n.name);
			let h = n.getUserStrings();
			if (h.length > 0) {
				let u = new Ge("User texts");
				for (let d = 0; d < h.length; d++) {
					let m = h[d];
					u.AddProperty(new B(P.Text, m[0], m[1]))
				}
				a.AddPropertyGroup(u)
			}
			if (r.length !== 0) {
				let u = new U()
					.CreateIdentity();
				for (let m = r.length - 1; m >= 0; m--) {
					let c = r[m].geometry()
						.xform.toFloatArray(!1),
						g = new U(c);
					u = u.MultiplyMatrix(g)
				}
				let d = new q(u);
				at(a, d)
			}
			this.model.AddMeshToRootNode(a)
		}
		GetMaterialIndex(e, t, i) {
			function r(a, h, u) {
				let d = h.attributes();
				if (d.materialSource === a.ObjectMaterialSource.MaterialFromObject) {
					let m = d.materialIndex;
					if (m > -1) return e.materials()
						.get(m)
				} else if (d.materialSource === a.ObjectMaterialSource.MaterialFromLayer) {
					let m = d.layerIndex;
					if (m > -1) {
						let p = e.layers()
							.get(m)
							.renderMaterialIndex;
						if (p > -1) return e.materials()
							.get(p)
					}
				} else if (d.materialSource === a.ObjectMaterialSource.MaterialFromParent && u.length !== 0) return r(a, u[0], []);
				return null
			}

			function n(a, h) {
				function u(g, x) {
					g.Set(x.r, x.g, x.b)
				}

				function d(g) {
					return g.r === 0 && g.g === 0 && g.b === 0
				}

				function m(g) {
					return g.r === 255 && g.g === 255 && g.b === 255
				}
				let f = null,
					p = a.physicallyBased();
				p.supported ? (f = new yt, f.metalness = p.metallic ? 1 : 0, f.roughness = p.roughness) : (f = new Q, u(f.ambient, a.ambientColor), u(f.specular, a.specularColor)), f.name = a.name, u(f.color, a.diffuseColor), f.opacity = 1 - a.transparency, ce(f), d(f.color) && !m(a.reflectionColor) && u(f.color, a.reflectionColor), d(f.color) && !m(a.transparentColor) && u(f.color, a.transparentColor);
				let c = a.getBitmapTexture();
				if (c) {
					let g = new Oe,
						x = $(c.fileName),
						C = h.getTextureBuffer(x);
					g.name = x, C !== null && (g.url = C.url, g.buffer = C.buffer), f.diffuseMap = g
				}
				return f
			}

			function s(a, h, u) {
				let d = n(h, u);
				for (let m = 0; m < a.MaterialCount(); m++)
					if (a.GetMaterial(m)
						.IsEqual(d)) return m;
				return a.AddMaterial(d)
			}
			let l = r(this.rhino, t, i);
			return l === null ? null : s(this.model, l, this.callbacks)
		}
	};
	var Fe = class {
		constructor(e, t) {
			this.arrayBuffer = e, this.dataView = new DataView(e), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		GetByteLength() {
			return this.arrayBuffer.byteLength
		}
		Skip(e) {
			this.position = this.position + e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		ReadArrayBuffer(e) {
			let t = new Uint8Array(this.arrayBuffer),
				i = new ArrayBuffer(e),
				r = new Uint8Array(i),
				n = t.subarray(this.position, this.position + e);
			return r.set(n, 0), this.position += e, i
		}
		ReadBoolean8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, !!e
		}
		ReadCharacter8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, e
		}
		ReadUnsignedCharacter8() {
			let e = this.dataView.getUint8(this.position);
			return this.position = this.position + 1, e
		}
		ReadInteger16() {
			let e = this.dataView.getInt16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadUnsignedInteger16() {
			let e = this.dataView.getUint16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadInteger32() {
			let e = this.dataView.getInt32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadUnsignedInteger32() {
			let e = this.dataView.getUint32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadFloat32() {
			let e = this.dataView.getFloat32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadDouble64() {
			let e = this.dataView.getFloat64(this.position, this.isLittleEndian);
			return this.position = this.position + 8, e
		}
	};
	var _ = {
			MAIN3DS: 19789,
			EDIT3DS: 15677,
			EDIT_MATERIAL: 45055,
			MAT_NAME: 40960,
			MAT_AMBIENT: 40976,
			MAT_DIFFUSE: 40992,
			MAT_SPECULAR: 41008,
			MAT_SHININESS: 41024,
			MAT_SHININESS_STRENGTH: 41025,
			MAT_TRANSPARENCY: 41040,
			MAT_COLOR_F: 16,
			MAT_COLOR: 17,
			MAT_LIN_COLOR: 18,
			MAT_LIN_COLOR_F: 19,
			MAT_TEXMAP: 41472,
			MAT_TEXMAP_NAME: 41728,
			MAT_TEXMAP_UOFFSET: 41816,
			MAT_TEXMAP_VOFFSET: 41818,
			MAT_TEXMAP_USCALE: 41812,
			MAT_TEXMAP_VSCALE: 41814,
			MAT_TEXMAP_ROTATION: 41820,
			PERCENTAGE: 48,
			PERCENTAGE_F: 49,
			EDIT_OBJECT: 16384,
			OBJ_TRIMESH: 16640,
			OBJ_LIGHT: 17920,
			OBJ_CAMERA: 18176,
			TRI_VERTEX: 16656,
			TRI_TEXVERTEX: 16704,
			TRI_FACE: 16672,
			TRI_TRANSFORMATION: 16736,
			TRI_MATERIAL: 16688,
			TRI_SMOOTH: 16720,
			KF3DS: 45056,
			OBJECT_NODE: 45058,
			OBJECT_HIERARCHY: 45072,
			OBJECT_INSTANCE_NAME: 45073,
			OBJECT_PIVOT: 45075,
			OBJECT_POSITION: 45088,
			OBJECT_ROTATION: 45089,
			OBJECT_SCALE: 45090,
			OBJECT_ID: 45104
		},
		ps = class {
			constructor() {
				this.id = -1, this.name = "", this.flags = -1, this.parentId = -1, this.instanceName = "", this.pivot = [0, 0, 0], this.positions = [], this.rotations = [], this.scales = []
			}
		},
		gs = class {
			constructor() {
				this.nodes = [], this.nodeIdToNode = new Map
			}
			IsEmpty() {
				return this.nodes.length === 0
			}
			AddNode(e) {
				this.nodes.push(e), this.nodeIdToNode.set(e.nodeId, e)
			}
			GetNodes() {
				return this.nodes
			}
		},
		yr = class extends W {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "3ds"
			}
			GetUpDirection() {
				return G.Z
			}
			ClearContent() {
				this.materialNameToIndex = null, this.meshNameToIndex = null, this.nodeList = null
			}
			ResetContent() {
				this.materialNameToIndex = new Map, this.meshNameToIndex = new Map, this.nodeList = new gs
			}
			ImportContent(e, t) {
				this.ProcessBinary(e), t()
			}
			ProcessBinary(e) {
				let t = new Fe(e, !0),
					i = t.GetByteLength();
				this.ReadChunks(t, i, (r, n) => {
					r === _.MAIN3DS ? this.ReadMainChunk(t, n) : this.SkipChunk(t, n)
				})
			}
			ReadMainChunk(e, t) {
				let i = this.GetChunkEnd(e, t);
				this.ReadChunks(e, i, (r, n) => {
					r === _.EDIT3DS ? this.ReadEditorChunk(e, n) : r === _.KF3DS ? this.ReadKeyFrameChunk(e, n) : this.SkipChunk(e, n)
				}), this.BuildNodeHierarchy()
			}
			ReadEditorChunk(e, t) {
				let i = this.GetChunkEnd(e, t);
				this.ReadChunks(e, i, (r, n) => {
					r === _.EDIT_MATERIAL ? this.ReadMaterialChunk(e, n) : r === _.EDIT_OBJECT ? this.ReadObjectChunk(e, n) : this.SkipChunk(e, n)
				})
			}
			ReadMaterialChunk(e, t) {
				let i = new Q,
					r = this.GetChunkEnd(e, t),
					n = null,
					s = null;
				this.ReadChunks(e, r, (a, h) => {
					a === _.MAT_NAME ? i.name = this.ReadName(e) : a === _.MAT_AMBIENT ? i.ambient = this.ReadColorChunk(e, h) : a === _.MAT_DIFFUSE ? i.color = this.ReadColorChunk(e, h) : a === _.MAT_SPECULAR ? i.specular = this.ReadColorChunk(e, h) : a === _.MAT_SHININESS ? n = this.ReadPercentageChunk(e, h) : a === _.MAT_SHININESS_STRENGTH ? s = this.ReadPercentageChunk(e, h) : a === _.MAT_TRANSPARENCY ? (i.opacity = 1 - this.ReadPercentageChunk(e, h), ce(i)) : a === _.MAT_TEXMAP ? (i.diffuseMap = this.ReadTextureMapChunk(e, h), ce(i)) : this.SkipChunk(e, h)
				}), n !== null && s !== null && (i.shininess = n * s / 10);
				let l = this.model.AddMaterial(i);
				this.materialNameToIndex.set(i.name, l)
			}
			ReadTextureMapChunk(e, t) {
				let i = new Oe,
					r = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, r, (n, s) => {
					if (n === _.MAT_TEXMAP_NAME) {
						let l = this.ReadName(e),
							a = this.callbacks.getTextureBuffer(l);
						i.name = l, a !== null && (i.url = a.url, i.buffer = a.buffer)
					} else n === _.MAT_TEXMAP_UOFFSET ? i.offset.x = e.ReadFloat32() : n === _.MAT_TEXMAP_VOFFSET ? i.offset.y = e.ReadFloat32() : n === _.MAT_TEXMAP_USCALE ? i.scale.x = e.ReadFloat32() : n === _.MAT_TEXMAP_VSCALE ? i.scale.y = e.ReadFloat32() : n === _.MAT_TEXMAP_ROTATION ? i.rotation = e.ReadFloat32() * Lt : this.SkipChunk(e, s)
				}), i
			}
			ReadColorChunk(e, t) {
				let i = new D(0, 0, 0),
					r = this.GetChunkEnd(e, t),
					n = !1;
				return this.ReadChunks(e, r, (s, l) => {
					s === _.MAT_COLOR ? n || (i.r = e.ReadUnsignedCharacter8(), i.g = e.ReadUnsignedCharacter8(), i.b = e.ReadUnsignedCharacter8()) : s === _.MAT_LIN_COLOR ? (i.r = e.ReadUnsignedCharacter8(), i.g = e.ReadUnsignedCharacter8(), i.b = e.ReadUnsignedCharacter8(), n = !0) : s === _.MAT_COLOR_F ? n || (i.r = De(e.ReadFloat32()), i.g = De(e.ReadFloat32()), i.b = De(e.ReadFloat32())) : s === _.MAT_LIN_COLOR_F ? (i.r = De(e.ReadFloat32()), i.g = De(e.ReadFloat32()), i.b = De(e.ReadFloat32()), n = !0) : this.SkipChunk(e, l)
				}), i
			}
			ReadPercentageChunk(e, t) {
				let i = 0,
					r = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, r, (n, s) => {
					n === _.PERCENTAGE ? i = e.ReadUnsignedInteger16() / 100 : n === _.PERCENTAGE_F ? i = e.ReadFloat32() : this.SkipChunk(e, s)
				}), i
			}
			ReadObjectChunk(e, t) {
				let i = this.GetChunkEnd(e, t),
					r = this.ReadName(e);
				this.ReadChunks(e, i, (n, s) => {
					n === _.OBJ_TRIMESH ? this.ReadMeshChunk(e, s, r) : this.SkipChunk(e, s)
				})
			}
			ReadMeshChunk(e, t, i) {
				function r(u, d) {
					if (!d.IsValid()) return;
					let m = d.Determinant(),
						f = pt(m);
					f && (d = new U()
						.CreateScale(-1, 1, 1)
						.MultiplyMatrix(d));
					let p = d.Invert();
					if (p === null) return;
					let c = new q(p);
					at(u, c), f && is(u)
				}
				let n = new Y;
				n.SetName(i);
				let s = this.GetChunkEnd(e, t),
					l = null;
				if (this.ReadChunks(e, s, (u, d) => {
					u === _.TRI_VERTEX ? this.ReadVerticesChunk(n, e) : u === _.TRI_TEXVERTEX ? this.ReadTextureVerticesChunk(n, e) : u === _.TRI_FACE ? this.ReadFacesChunk(n, e, d) : u === _.TRI_TRANSFORMATION ? l = this.ReadTransformationChunk(e) : this.SkipChunk(e, d)
				}), n.VertexCount() === n.TextureUVCount())
					for (let u = 0; u < n.TriangleCount(); u++) {
						let d = n.GetTriangle(u);
						d.SetTextureUVs(d.v0, d.v1, d.v2)
					}
				let a = new U(l);
				r(n, a);
				let h = this.model.AddMesh(n);
				this.meshNameToIndex.set(n.GetName(), h)
			}
			ReadVerticesChunk(e, t) {
				let i = t.ReadUnsignedInteger16();
				for (let r = 0; r < i; r++) {
					let n = t.ReadFloat32(),
						s = t.ReadFloat32(),
						l = t.ReadFloat32();
					e.AddVertex(new T(n, s, l))
				}
			}
			ReadTextureVerticesChunk(e, t) {
				let i = t.ReadUnsignedInteger16();
				for (let r = 0; r < i; r++) {
					let n = t.ReadFloat32(),
						s = t.ReadFloat32();
					e.AddTextureUV(new O(n, s))
				}
			}
			ReadFacesChunk(e, t, i) {
				let r = this.GetChunkEnd(t, i),
					n = t.ReadUnsignedInteger16();
				for (let s = 0; s < n; s++) {
					let l = t.ReadUnsignedInteger16(),
						a = t.ReadUnsignedInteger16(),
						h = t.ReadUnsignedInteger16();
					t.ReadUnsignedInteger16(), e.AddTriangle(new z(l, a, h))
				}
				this.ReadChunks(t, r, (s, l) => {
					s === _.TRI_MATERIAL ? this.ReadFaceMaterialsChunk(e, t) : s === _.TRI_SMOOTH ? this.ReadFaceSmoothingGroupsChunk(e, n, t) : this.SkipChunk(t, l)
				})
			}
			ReadFaceMaterialsChunk(e, t) {
				let i = this.ReadName(t),
					r = this.materialNameToIndex.get(i),
					n = t.ReadUnsignedInteger16();
				for (let s = 0; s < n; s++) {
					let l = t.ReadUnsignedInteger16(),
						a = e.GetTriangle(l);
					r !== void 0 && (a.mat = r)
				}
			}
			ReadFaceSmoothingGroupsChunk(e, t, i) {
				for (let r = 0; r < t; r++) {
					let n = i.ReadUnsignedInteger32(),
						s = e.GetTriangle(r);
					s.curve = n
				}
			}
			ReadTransformationChunk(e) {
				let t = [];
				for (let i = 0; i < 4; i++) {
					for (let r = 0; r < 3; r++) t.push(e.ReadFloat32());
					i < 3 ? t.push(0) : t.push(1)
				}
				return t
			}
			ReadKeyFrameChunk(e, t) {
				let i = this.GetChunkEnd(e, t);
				this.ReadChunks(e, i, (r, n) => {
					r === _.OBJECT_NODE ? this.ReadObjectNodeChunk(e, n) : this.SkipChunk(e, n)
				})
			}
			BuildNodeHierarchy() {
				function e(i, r) {
					function n(h) {
						return h.positions.length === 0 ? [0, 0, 0] : h.positions[0]
					}

					function s(h) {
						function u(m) {
							let f = [0, 0, 0, 1],
								p = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
							if (p > 0) {
								let c = m[3] * -.5,
									g = Math.sin(c) / p;
								f = [g * m[0], g * m[1], g * m[2], Math.cos(c)]
							}
							return f
						}
						if (h.rotations.length === 0) return [0, 0, 0, 1];
						let d = h.rotations[0];
						return u(d)
					}

					function l(h) {
						return h.scales.length === 0 ? [1, 1, 1] : h.scales[0]
					}
					let a = new U;
					if (a.ComposeTRS(Qe(n(i)), Ut(s(i)), Qe(l(i))), r) {
						let h = i.pivot;
						a = new U()
							.CreateTranslation(-h[0], -h[1], -h[2])
							.MultiplyMatrix(a)
					}
					return new q(a)
				}
				let t = this.model.GetRootNode();
				if (this.nodeList.IsEmpty())
					for (let i = 0; i < this.model.MeshCount(); i++) t.AddMeshIndex(i);
				else {
					let i = new Map;
					for (let r of this.nodeList.GetNodes()) {
						let n = new be;
						r.name.length > 0 && r.name !== "$$$DUMMY" && (n.SetName(r.name), r.instanceName.length > 0 && n.SetName(n.GetName() + " " + r.instanceName)), r.parentId === 65535 || !i.has(r.parentId) ? t.AddChildNode(n) : i.get(r.parentId)
							.AddChildNode(n), i.set(r.id, n);
						let s = this.meshNameToIndex.has(r.name);
						n.SetTransformation(e(r, s)), s && (n.SetType(fe.MeshNode), n.AddMeshIndex(this.meshNameToIndex.get(r.name)))
					}
				}
			}
			ReadObjectNodeChunk(e, t) {
				function i(s, l, a) {
					let h = [];
					l.Skip(10);
					let u = l.ReadInteger32();
					for (let d = 0; d < u; d++) {
						l.ReadInteger32(), l.ReadUnsignedInteger16() !== 0 && l.ReadFloat32();
						let f = null;
						if (a === _.OBJECT_ROTATION) {
							let p = l.ReadFloat32();
							f = s.ReadVector(l), f[3] = p
						} else f = s.ReadVector(l);
						h.push(f)
					}
					return h
				}
				let r = new ps,
					n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (s, l) => {
					s === _.OBJECT_HIERARCHY ? (r.name = this.ReadName(e), r.flags = e.ReadUnsignedInteger32(), r.parentId = e.ReadUnsignedInteger16()) : s === _.OBJECT_INSTANCE_NAME ? r.instanceName = this.ReadName(e) : s === _.OBJECT_PIVOT ? r.pivot = this.ReadVector(e) : s === _.OBJECT_POSITION ? r.positions = i(this, e, _.OBJECT_POSITION) : s === _.OBJECT_ROTATION ? r.rotations = i(this, e, _.OBJECT_ROTATION) : s === _.OBJECT_SCALE ? r.scales = i(this, e, _.OBJECT_SCALE) : s === _.OBJECT_ID ? r.id = e.ReadUnsignedInteger16() : this.SkipChunk(e, l)
				}), this.nodeList.AddNode(r)
			}
			ReadName(e) {
				let t = "",
					i = 0,
					r = 0;
				for (; r < 64 && (i = e.ReadCharacter8(), i !== 0);) t = t + String.fromCharCode(i), r = r + 1;
				return t
			}
			ReadVector(e) {
				return [e.ReadFloat32(), e.ReadFloat32(), e.ReadFloat32()]
			}
			ReadChunks(e, t, i) {
				for (; e.GetPosition() <= t - 6;) {
					let r = e.ReadUnsignedInteger16(),
						n = e.ReadUnsignedInteger32();
					i(r, n)
				}
			}
			GetChunkEnd(e, t) {
				return e.GetPosition() + t - 6
			}
			SkipChunk(e, t) {
				e.Skip(t - 6)
			}
		};
	var Se = {
			BYTE: 5120,
			UNSIGNED_BYTE: 5121,
			SHORT: 5122,
			UNSIGNED_SHORT: 5123,
			UNSIGNED_INT: 5125,
			FLOAT: 5126
		},
		ke = {
			SCALAR: 0,
			VEC2: 1,
			VEC3: 2,
			VEC4: 3,
			MAT2: 4,
			MAT3: 5,
			MAT4: 6
		},
		wt = {
			POINTS: 0,
			LINES: 1,
			LINE_LOOP: 2,
			LINE_STRIP: 3,
			TRIANGLES: 4,
			TRIANGLE_STRIP: 5,
			TRIANGLE_FAN: 6
		},
		br = {
			GLTF_STRING: 1179937895,
			JSON_CHUNK_TYPE: 1313821514,
			BINARY_CHUNK_TYPE: 5130562
		};

	function $t(o) {
		return Ne(Kt(o[0]), Kt(o[1]), Kt(o[2]))
	}

	function xo(o, e) {
		function t(i, r) {
			let n = i;
			return r !== Se.FLOAT && (n /= 255), De(Kt(n))
		}
		return new D(t(o[0], e), t(o[1], e), t(o[2], e))
	}
	var xs = class {
			constructor(e) {
				this.reader = new Fe(e, !0), this.componentType = null, this.dataType = null, this.byteStride = null, this.dataCount = null, this.sparseReader = null
			}
			SetComponentType(e) {
				this.componentType = e
			}
			SetDataType(e) {
				e === "SCALAR" ? this.dataType = ke.SCALAR : e === "VEC2" ? this.dataType = ke.VEC2 : e === "VEC3" ? this.dataType = ke.VEC3 : e === "VEC4" ? this.dataType = ke.VEC4 : e === "MAT2" ? this.dataType = ke.MAT2 : e === "MAT3" ? this.dataType = ke.MAT3 : e === "MAT4" && (this.dataType = ke.MAT4)
			}
			SetByteStride(e) {
				this.byteStride = e
			}
			SetDataCount(e) {
				this.dataCount = e
			}
			SetSparseReader(e, t) {
				this.sparseReader = {
					indexReader: e,
					valueReader: t
				}
			}
			ReadArrayBuffer(e) {
				return this.reader.ReadArrayBuffer(e)
			}
			GetDataCount() {
				return this.dataCount
			}
			ReadData() {
				if (this.dataType === null) return null;
				if (this.dataType === ke.SCALAR) {
					let e = this.ReadComponent();
					return this.SkipBytesByStride(1), e
				} else if (this.dataType === ke.VEC2) {
					let e = this.ReadComponent(),
						t = this.ReadComponent();
					return this.SkipBytesByStride(2), new O(e, t)
				} else if (this.dataType === ke.VEC3) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						i = this.ReadComponent();
					return this.SkipBytesByStride(3), new T(e, t, i)
				} else if (this.dataType === ke.VEC4) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						i = this.ReadComponent(),
						r = this.ReadComponent();
					return this.SkipBytesByStride(4), new We(e, t, i, r)
				}
				return null
			}
			EnumerateData(e) {
				if (this.sparseReader === null)
					for (let t = 0; t < this.dataCount; t++) e(this.ReadData());
				else {
					let t = [];
					for (let r = 0; r < this.sparseReader.indexReader.GetDataCount(); r++) {
						let n = this.sparseReader.indexReader.ReadData(),
							s = this.sparseReader.valueReader.ReadData();
						t.push({
							index: n,
							value: s
						})
					}
					let i = 0;
					for (let r = 0; r < this.dataCount; r++) {
						let n = this.ReadData();
						i < t.length && t[i].index === r ? (e(t[i].value), i += 1) : e(n)
					}
				}
			}
			SkipBytes(e) {
				this.reader.Skip(e)
			}
			ReadComponent() {
				return this.componentType === null ? null : this.componentType === Se.BYTE ? this.reader.ReadCharacter8() : this.componentType === Se.UNSIGNED_BYTE ? this.reader.ReadUnsignedCharacter8() : this.componentType === Se.SHORT ? this.reader.ReadInteger16() : this.componentType === Se.UNSIGNED_SHORT ? this.reader.ReadUnsignedInteger16() : this.componentType === Se.UNSIGNED_INT ? this.reader.ReadInteger32() : this.componentType === Se.FLOAT ? this.reader.ReadFloat32() : null
			}
			SkipBytesByStride(e) {
				if (this.byteStride === null) return;
				let t = e * this.GetComponentSize();
				this.reader.Skip(this.byteStride - t)
			}
			GetComponentSize() {
				return this.componentType === Se.BYTE || this.componentType === Se.UNSIGNED_BYTE ? 1 : this.componentType === Se.SHORT || this.componentType === Se.UNSIGNED_SHORT ? 2 : this.componentType === Se.UNSIGNED_INT || this.componentType === Se.FLOAT ? 4 : 0
			}
		},
		Cs = class {
			constructor() {
				this.supportedExtensions = ["KHR_draco_mesh_compression", "KHR_materials_pbrSpecularGlossiness", "KHR_texture_transform"], this.draco = null
			}
			LoadLibraries(e, t) {
				if (e === void 0) {
					t.onSuccess();
					return
				}
				this.draco === null && e.indexOf("KHR_draco_mesh_compression") !== -1 ? xe("loaders/draco_decoder.js")
					.then(() => {
						DracoDecoderModule()
							.then(i => {
								this.draco = i, t.onSuccess()
							})
					})
					.catch(() => {
						t.onError("Failed to load draco decoder.")
					}) : t.onSuccess()
			}
			GetUnsupportedExtensions(e) {
				let t = [];
				if (e === void 0) return t;
				for (let i = 0; i < e.length; i++) {
					let r = e[i];
					this.supportedExtensions.indexOf(r) === -1 && t.push(r)
				}
				return t
			}
			ProcessMaterial(e, t, i) {
				if (e.extensions === void 0) return null;
				let r = e.extensions.KHR_materials_pbrSpecularGlossiness;
				if (r === void 0) return null;
				let n = new Q,
					s = r.diffuseFactor;
				s !== void 0 && (n.color = $t(s), n.opacity = s[3]);
				let l = r.diffuseTexture;
				l !== void 0 && (n.diffuseMap = i(l));
				let a = r.specularFactor;
				a !== void 0 && (n.specular = $t(a));
				let h = r.specularGlossinessTexture;
				h !== void 0 && (n.specularMap = i(h));
				let u = r.glossinessFactor;
				return u !== void 0 && (n.shininess = u), n
			}
			ProcessTexture(e, t) {
				if (e.extensions === void 0) return;
				let i = e.extensions.KHR_texture_transform;
				i !== void 0 && (i.offset !== void 0 && (t.offset.x = i.offset[0], t.offset.y = -i.offset[1]), i.scale !== void 0 && (t.scale.x = i.scale[0], t.scale.y = i.scale[1]), i.rotation !== void 0 && (t.rotation = -i.rotation))
			}
			ProcessPrimitive(e, t, i, r) {
				function n(F, N, V, ae, H) {
					let Me = N.GetAttributeByUniqueId(V, ae),
						He = Me.num_components(),
						Ft = V.num_points() * He,
						Rt = Ft * 4,
						ct = F._malloc(Rt);
					N.GetAttributeDataArrayForAllPoints(V, Me, F.DT_FLOAT32, Rt, ct);
					let se = new Float32Array(F.HEAPF32.buffer, ct, Ft)
						.slice();
					if (He === 2)
						for (let j = 0; j < se.length; j += 2) H(new O(se[j + 0], se[j + 1]));
					else if (He === 3)
						for (let j = 0; j < se.length; j += 3) H(new T(se[j + 0], se[j + 1], se[j + 2]));
					else if (He === 4)
						for (let j = 0; j < se.length; j += 4) H(new We(se[j + 0], se[j + 1], se[j + 2], se[j + 3]));
					F._free(ct)
				}
				if (this.draco === null || i.extensions === void 0 || i.extensions.KHR_draco_mesh_compression === void 0) return !1;
				let s = new this.draco.Decoder,
					l = new this.draco.DecoderBuffer,
					a = i.extensions.KHR_draco_mesh_compression,
					h = t.bufferViews[a.bufferView],
					d = e.GetReaderFromBufferView(h)
					.ReadArrayBuffer(h.byteLength);
				if (l.Init(new Int8Array(d), d.byteLength), s.GetEncodedGeometryType(l) !== this.draco.TRIANGULAR_MESH) return !0;
				let f = new this.draco.Mesh;
				if (!s.DecodeBufferToMesh(l, f)
					.ok()) return !0;
				let c = a.attributes.POSITION !== void 0,
					g = !1,
					x = a.attributes.NORMAL !== void 0,
					C = a.attributes.TEXCOORD_0 !== void 0;
				if (!c) return !0;
				let M = r.VertexCount(),
					I = r.VertexColorCount(),
					b = r.NormalCount(),
					w = r.TextureUVCount();
				n(this.draco, s, f, a.attributes.POSITION, F => {
					r.AddVertex(F)
				}), x && n(this.draco, s, f, a.attributes.NORMAL, F => {
					r.AddNormal(F)
				}), C && n(this.draco, s, f, a.attributes.TEXCOORD_0, F => {
					F.y = -F.y, r.AddTextureUV(F)
				});
				let E = f.num_faces() * 3,
					S = E * 4,
					A = this.draco._malloc(S);
				s.GetTrianglesUInt32Array(f, S, A);
				let k = new Uint32Array(this.draco.HEAPU32.buffer, A, E)
					.slice();
				for (let F = 0; F < k.length; F += 3) {
					let N = k[F],
						V = k[F + 1],
						ae = k[F + 2];
					e.AddTriangle(i, r, N, V, ae, g, x, C, M, I, b, w)
				}
				return this.draco._free(A), !0
			}
		},
		Sr = class extends W {
			constructor() {
				super();
				this.gltfExtensions = new Cs
			}
			CanImportExtension(e) {
				return e === "gltf" || e === "glb"
			}
			GetUpDirection() {
				return G.Y
			}
			ClearContent() {
				this.bufferContents = null, this.imageIndexToTextureParams = null
			}
			ResetContent() {
				this.bufferContents = [], this.imageIndexToTextureParams = new Map
			}
			ImportContent(e, t) {
				this.extension === "gltf" ? this.ProcessGltf(e, t) : this.extension === "glb" && this.ProcessBinaryGltf(e, t)
			}
			ProcessGltf(e, t) {
				let i = re(e),
					r = JSON.parse(i);
				if (r.asset.version !== "2.0") {
					this.SetError("Invalid glTF version."), t();
					return
				}
				for (let n = 0; n < r.buffers.length; n++) {
					let s = null,
						l = r.buffers[n],
						a = Jt(l.uri);
					if (a !== null) s = a.buffer;
					else {
						let h = this.callbacks.getFileBuffer(l.uri);
						h !== null && (s = h)
					}
					if (s === null) {
						this.SetError("One of the requested buffers is missing."), t();
						return
					}
					this.bufferContents.push(s)
				}
				this.ProcessMainFile(r, t)
			}
			ProcessBinaryGltf(e, t) {
				function i(h) {
					let u = h.ReadUnsignedInteger32(),
						d = h.ReadUnsignedInteger32(),
						m = h.ReadArrayBuffer(u);
					return {
						type: d,
						buffer: m
					}
				}
				let r = new Fe(e, !0);
				if (r.ReadUnsignedInteger32() !== br.GLTF_STRING) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				if (r.ReadUnsignedInteger32() !== 2) {
					this.SetError("Invalid glTF version."), t();
					return
				}
				if (r.ReadUnsignedInteger32() !== r.GetByteLength()) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				let a = null;
				for (; !r.End();) {
					let h = i(r);
					h.type === br.JSON_CHUNK_TYPE ? a = re(h.buffer) : h.type === br.BINARY_CHUNK_TYPE && this.bufferContents.push(h.buffer)
				}
				if (a !== null) {
					let h = JSON.parse(a);
					this.ProcessMainFile(h, t)
				}
			}
			ProcessMainFile(e, t) {
				let i = this.gltfExtensions.GetUnsupportedExtensions(e.extensionsRequired);
				if (i.length > 0) {
					this.SetError("Unsupported extension: " + i.join(", ") + "."), t();
					return
				}
				this.gltfExtensions.LoadLibraries(e.extensionsRequired, {
					onSuccess: () => {
						this.ImportModel(e), t()
					},
					onError: r => {
						this.SetError(r), t()
					}
				})
			}
			ImportModel(e) {
				let t = e.materials;
				if (t !== void 0)
					for (let r of t) this.ImportMaterial(e, r);
				let i = e.meshes;
				if (i !== void 0)
					for (let r of i) this.ImportMesh(e, r);
				this.ImportNodes(e), this.ImportModelProperties(e)
			}
			ImportModelProperties(e) {
				function t(i, r, n) {
					let s = new Ge(r);
					for (let l in n)
						if (Object.prototype.hasOwnProperty.call(n, l) && typeof n[l] == "string") {
							let a = new B(P.Text, l, n[l]);
							s.AddProperty(a)
						} return s.PropertyCount() > 0 && i.AddPropertyGroup(s), s
				}
				t(this.model, "Asset properties", e.asset), e.asset.extras && t(this.model, "Extras", e.asset.extras)
			}
			GetDefaultScene(e) {
				let t = e.scene || 0;
				return t >= e.scenes.length ? null : e.scenes[t]
			}
			ImportMaterial(e, t) {
				let i = new yt;
				if (t.name !== void 0 && (i.name = t.name), i.color = $t([1, 1, 1]), t.pbrMetallicRoughness !== void 0) {
					let n = t.pbrMetallicRoughness.baseColorFactor;
					n !== void 0 && (i.color = $t(n), i.opacity = n[3]);
					let s = t.pbrMetallicRoughness.metallicFactor;
					s !== void 0 && (i.metalness = s);
					let l = t.pbrMetallicRoughness.roughnessFactor;
					l !== void 0 && (i.roughness = l);
					let a = t.emissiveFactor;
					a !== void 0 && (i.emissive = $t(a)), i.diffuseMap = this.ImportTexture(e, t.pbrMetallicRoughness.baseColorTexture), i.metalnessMap = this.ImportTexture(e, t.pbrMetallicRoughness.metallicRoughnessTexture), i.normalMap = this.ImportTexture(e, t.normalTexture), i.emissiveMap = this.ImportTexture(e, t.emissiveTexture), i.diffuseMap !== null && (i.multiplyDiffuseMap = !0);
					let h = t.alphaMode;
					h !== void 0 && (h === "BLEND" ? i.transparent = !0 : h === "MASK" && (i.transparent = !0, i.alphaTest = t.alphaCutoff || .5))
				}
				let r = this.gltfExtensions.ProcessMaterial(t, i, n => this.ImportTexture(e, n));
				r !== null && (i = r), this.model.AddMaterial(i)
			}
			ImportTexture(e, t) {
				if (t == null) return null;
				let i = new Oe,
					n = e.textures[t.index].source,
					s = e.images[n],
					l = null;
				if (this.imageIndexToTextureParams.has(n)) l = this.imageIndexToTextureParams.get(n);
				else {
					l = {
						name: null,
						url: null,
						buffer: null
					};
					let a = n.toString();
					if (s.uri !== void 0) {
						let h = Jt(s.uri);
						if (h !== null) l.name = "Embedded_" + a + "." + kt(h.mimeType), l.url = sr(h.buffer, h.mimeType), l.buffer = h.buffer;
						else {
							let u = this.callbacks.getTextureBuffer(s.uri);
							l.name = s.uri, u !== null && (l.url = u.url, l.buffer = u.buffer)
						}
					} else if (s.bufferView !== void 0) {
						let h = e.bufferViews[s.bufferView],
							u = this.GetReaderFromBufferView(h);
						if (u !== null) {
							let d = u.ReadArrayBuffer(h.byteLength);
							l.name = "Binary_" + a + "." + kt(s.mimeType), l.url = sr(d, s.mimeType), l.buffer = d
						}
					}
					this.imageIndexToTextureParams.set(n, l)
				}
				return i.name = l.name, i.url = l.url, i.buffer = l.buffer, this.gltfExtensions.ProcessTexture(t, i), i
			}
			ImportMesh(e, t) {
				let i = new Y;
				this.model.AddMesh(i), t.name !== void 0 && i.SetName(t.name);
				for (let r = 0; r < t.primitives.length; r++) {
					let n = t.primitives[r];
					this.ImportPrimitive(e, n, i)
				}
			}
			ImportPrimitive(e, t, i) {
				if (this.gltfExtensions.ProcessPrimitive(this, e, t, i) || t.attributes === void 0) return;
				let r = t.attributes.POSITION !== void 0,
					n = t.attributes.COLOR_0 !== void 0,
					s = t.attributes.NORMAL !== void 0,
					l = t.attributes.TEXCOORD_0 !== void 0,
					a = t.indices !== void 0,
					h = wt.TRIANGLES;
				if (t.mode !== void 0 && (h = t.mode), h !== wt.TRIANGLES && h !== wt.TRIANGLE_STRIP && h !== wt.TRIANGLE_FAN) return;
				let u = i.VertexCount(),
					d = i.VertexColorCount(),
					m = i.NormalCount(),
					f = i.TextureUVCount();
				if (r) {
					let c = e.accessors[t.attributes.POSITION],
						g = this.GetReaderFromAccessor(e, c);
					if (g === null) return;
					g.EnumerateData(x => {
						i.AddVertex(x)
					})
				} else return;
				if (n) {
					let c = e.accessors[t.attributes.COLOR_0],
						g = this.GetReaderFromAccessor(e, c);
					if (g === null) return;
					g.EnumerateData(x => {
						let C = xo([x.x, x.y, x.z], g.componentType);
						i.AddVertexColor(C)
					})
				}
				if (s) {
					let c = e.accessors[t.attributes.NORMAL],
						g = this.GetReaderFromAccessor(e, c);
					if (g === null) return;
					g.EnumerateData(x => {
						i.AddNormal(x)
					})
				}
				if (l) {
					let c = e.accessors[t.attributes.TEXCOORD_0],
						g = this.GetReaderFromAccessor(e, c);
					if (g === null) return;
					g.EnumerateData(x => {
						x.y = -x.y, i.AddTextureUV(x)
					})
				}
				let p = [];
				if (a) {
					let c = e.accessors[t.indices],
						g = this.GetReaderFromAccessor(e, c);
					if (g === null) return;
					g.EnumerateData(x => {
						p.push(x)
					})
				} else {
					let c = i.VertexCount() - u;
					for (let g = 0; g < c; g++) p.push(g)
				}
				if (h === wt.TRIANGLES)
					for (let c = 0; c < p.length; c += 3) {
						let g = p[c],
							x = p[c + 1],
							C = p[c + 2];
						this.AddTriangle(t, i, g, x, C, n, s, l, u, d, m, f)
					} else if (h === wt.TRIANGLE_STRIP)
						for (let c = 0; c < p.length - 2; c++) {
							let g = p[c],
								x = p[c + 1],
								C = p[c + 2];
							if (c % 2 === 1) {
								let M = x;
								x = C, C = M
							}
							this.AddTriangle(t, i, g, x, C, n, s, l, u, d, m, f)
						} else if (h === wt.TRIANGLE_FAN)
							for (let c = 1; c < p.length - 1; c++) {
								let g = p[0],
									x = p[c],
									C = p[c + 1];
								this.AddTriangle(t, i, g, x, C, n, s, l, u, d, m, f)
							}
			}
			AddTriangle(e, t, i, r, n, s, l, a, h, u, d, m) {
				let f = new z(h + i, h + r, h + n);
				s && f.SetVertexColors(u + i, u + r, u + n), l && f.SetNormals(d + i, d + r, d + n), a && f.SetTextureUVs(m + i, m + r, m + n), e.material !== void 0 && (f.mat = e.material), t.AddTriangle(f)
			}
			ImportNodes(e) {
				let t = this.GetDefaultScene(e);
				if (t === null) return;
				let i = this.model.GetRootNode();
				for (let r of t.nodes) {
					let n = e.nodes[r];
					this.ImportNode(e, n, i)
				}
			}
			ImportNode(e, t, i) {
				function r(s) {
					let l = new U()
						.CreateIdentity();
					if (s.matrix !== void 0) l.Set(s.matrix);
					else {
						let a = [0, 0, 0],
							h = [0, 0, 0, 1],
							u = [1, 1, 1];
						s.translation !== void 0 && (a = s.translation), s.rotation !== void 0 && (h = s.rotation), s.scale !== void 0 && (u = s.scale), l.ComposeTRS(Qe(a), Ut(h), Qe(u))
					}
					return new q(l)
				}
				if (t.children === void 0 && t.mesh === void 0) return;
				let n = new be;
				if (t.name !== void 0 && n.SetName(t.name), n.SetTransformation(r(t)), i.AddChildNode(n), t.children !== void 0)
					for (let s of t.children) {
						let l = e.nodes[s];
						this.ImportNode(e, l, n)
					}
				t.mesh !== void 0 && ((t.children === void 0 || t.children.length === 0) && n.SetType(fe.MeshNode), n.AddMeshIndex(t.mesh))
			}
			GetReaderFromBufferView(e) {
				let t = e.buffer || 0,
					i = this.bufferContents[t];
				if (i == null) return null;
				let r = new xs(i);
				r.SkipBytes(e.byteOffset || 0);
				let n = e.byteStride;
				return n !== void 0 && n !== 0 && r.SetByteStride(n), r
			}
			GetReaderFromAccessor(e, t) {
				let i = t.bufferView || 0,
					r = e.bufferViews[i],
					n = this.GetReaderFromBufferView(r);
				if (n === null) return null;
				if (n.SetComponentType(t.componentType), n.SetDataType(t.type), n.SetDataCount(t.count), n.SkipBytes(t.byteOffset || 0), t.sparse !== void 0) {
					let s = this.GetReaderFromSparseAccessor(e, t.sparse.indices, t.sparse.indices.componentType, "SCALAR", t.sparse.count),
						l = this.GetReaderFromSparseAccessor(e, t.sparse.values, t.componentType, t.type, t.sparse.count);
					s !== null && l !== null && n.SetSparseReader(s, l)
				}
				return n
			}
			GetReaderFromSparseAccessor(e, t, i, r, n) {
				if (t.bufferView === void 0) return null;
				let s = e.bufferViews[t.bufferView],
					l = this.GetReaderFromBufferView(s);
				return l === null ? null : (l.SetComponentType(i), l.SetDataType(r), l.SetDataCount(n), l.SkipBytes(t.byteOffset || 0), l)
			}
		};
	var wr = class extends W {
		constructor() {
			super();
			this.ifc = null
		}
		CanImportExtension(e) {
			return e === "ifc"
		}
		GetUpDirection() {
			return G.Y
		}
		ClearContent() {
			this.materialNameToIndex = null, this.expressIDToMesh = null
		}
		ResetContent() {
			this.materialNameToIndex = new Map, this.expressIDToMesh = new Map
		}
		ImportContent(e, t) {
			this.ifc === null ? xe("loaders/web-ifc-api-browser.js")
				.then(() => {
					this.ifc = new WebIFC.IfcAPI, this.ifc.Init()
						.then(() => {
							this.ImportIfcContent(e), t()
						})
				})
				.catch(() => {
					this.SetError("Failed to load web-ifc."), t()
				}) : (this.ImportIfcContent(e), t())
		}
		ImportIfcContent(e) {
			let t = new Uint8Array(e),
				i = this.ifc.OpenModel(t, {
					COORDINATE_TO_ORIGIN: !0
				}),
				r = this.ifc.LoadAllGeometry(i);
			for (let n = 0; n < r.size(); n++) {
				let s = r.get(n);
				s.geometries.size() > 0 && this.ImportIfcMesh(i, s)
			}
			this.ImportProperties(i), this.ifc.CloseModel(i)
		}
		ImportIfcMesh(e, t) {
			let i = new Y;
			i.SetName("Mesh " + t.expressID.toString());
			let r = 0,
				n = t.geometries;
			for (let s = 0; s < n.size(); s++) {
				let l = n.get(s),
					a = this.ifc.GetGeometry(e, l.geometryExpressID),
					h = this.ifc.GetVertexArray(a.GetVertexData(), a.GetVertexDataSize()),
					u = this.ifc.GetIndexArray(a.GetIndexData(), a.GetIndexDataSize()),
					d = this.GetMaterialIndexByColor(l.color),
					m = new U(l.flatTransformation),
					f = new q(m);
				for (let p = 0; p < h.length; p += 6) {
					let c = h[p],
						g = h[p + 1],
						x = h[p + 2],
						C = new T(c, g, x),
						M = f.TransformCoord3D(C);
					i.AddVertex(M)
				}
				for (let p = 0; p < u.length; p += 3) {
					let c = u[p],
						g = u[p + 1],
						x = u[p + 2],
						C = new z(r + c, r + g, r + x);
					C.SetMaterial(d), i.AddTriangle(C)
				}
				r += h.length / 6
			}
			this.expressIDToMesh.set(t.expressID, i), this.model.AddMeshToRootNode(i)
		}
		ImportProperties(e) {
			let t = this.ifc.GetLineIDsWithType(e, WebIFC.IFCRELDEFINESBYPROPERTIES);
			for (let i = 0; i < t.size(); i++) {
				let r = t.get(i),
					n = this.ifc.GetLine(e, r);
				Array.isArray(n.RelatingPropertyDefinition) || n.RelatedObjects.forEach(s => {
					let l = null;
					if (this.expressIDToMesh.has(s.value) ? l = this.expressIDToMesh.get(s.value) : this.ifc.GetLine(e, s.value, !0)
						.type === WebIFC.IFCBUILDING && (l = this.model), l === null) return;
					let a = n.RelatingPropertyDefinition,
						h = this.ifc.GetLine(e, a.value, !0);
					if (!h || !h.HasProperties) return;
					let u = new Ge(h.Name.value);
					h.HasProperties.forEach(d => {
						if (!d || !d.Name || !d.NominalValue) return;
						let m = null,
							f = this.GetIFCString(d.Name.value),
							p = null;
						switch (d.NominalValue.label) {
							case "IFCTEXT":
							case "IFCLABEL":
							case "IFCIDENTIFIER":
								m = new B(P.Text, f, this.GetIFCString(d.NominalValue.value));
								break;
							case "IFCBOOLEAN":
							case "IFCLOGICAL":
								p = "Unknown", d.NominalValue.value === "T" ? p = "True" : d.NominalValue.value === "F" && (p = "False"), m = new B(P.Text, f, p);
								break;
							case "IFCINTEGER":
							case "IFCCOUNTMEASURE":
								m = new B(P.Integer, f, d.NominalValue.value);
								break;
							case "IFCREAL":
							case "IFCLENGTHMEASURE":
							case "IFCPOSITIVELENGTHMEASURE":
							case "IFCAREAMEASURE":
							case "IFCVOLUMEMEASURE":
							case "IFCRATIOMEASURE":
							case "IFCPOSITIVERATIOMEASURE":
							case "IFCMASSMEASURE":
							case "IFCMASSPERLENGTHMEASURE":
							case "IFCPLANEANGLEMEASURE":
							case "IFCTHERMALTRANSMITTANCEMEASURE":
								m = new B(P.Number, f, d.NominalValue.value);
								break;
							default:
								console.log(d.NominalValue.label), console.log(d.NominalValue.value);
								break
						}
						m !== null && u.AddProperty(m)
					}), u.PropertyCount() > 0 && l.AddPropertyGroup(u)
				})
			}
		}
		GetMaterialIndexByColor(e) {
			let t = Ne(e.x, e.y, e.z),
				i = "Color " + ie(t.r) + ie(t.g) + ie(t.b) + ie(parseInt(e.w * 255, 10));
			if (this.materialNameToIndex.has(i)) return this.materialNameToIndex.get(i); {
				let r = new Q;
				r.name = i, r.color = t, r.opacity = e.w, ce(r);
				let n = this.model.AddMaterial(r);
				return this.materialNameToIndex.set(i, n), n
			}
		}
		GetIFCString(e) {
			let t = this.DecodeIFCString(e);
			return t.length === 0 && (t = "-"), t
		}
		DecodeIFCString(e) {
			let t = /\\X2\\(.*?)\\X0\\/uig,
				i = e,
				r = t.exec(e);
			for (; r;) {
				let n = String.fromCharCode(parseInt(r[1], 16));
				i = i.replace(r[0], n), r = t.exec(e)
			}
			return i
		}
	};
	var Ui = class {
			constructor() {
				this.name = null, this.material = null
			}
			SetName(e) {
				return this.name = e, this
			}
			SetMaterial(e) {
				return this.material = e, this
			}
		},
		ei = class {
			constructor(e) {
				this.params = e || new Ui, this.mesh = new Y, this.params.name !== null && this.mesh.SetName(this.params.name), this.curve = null
			}
			GetMesh() {
				return this.mesh
			}
			AddVertex(e, t, i) {
				let r = new T(e, t, i);
				return this.mesh.AddVertex(r)
			}
			AddVertices(e) {
				let t = [];
				for (let i = 0; i < e.length; i++) {
					let r = e[i];
					t.push(this.AddVertex(r.x, r.y, r.z))
				}
				return t
			}
			SetCurve(e) {
				this.curve = e
			}
			ResetCurve() {
				this.curve = null
			}
			AddTriangle(e, t, i) {
				let r = new z(e, t, i);
				return this.params.material !== null && (r.mat = this.params.material), this.curve !== null && r.SetCurve(this.curve), this.mesh.AddTriangle(r)
			}
			AddTriangleInverted(e, t, i) {
				this.AddTriangle(e, i, t)
			}
			AddConvexPolygon(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangle(e[0], e[t + 1], e[t + 2])
			}
			AddConvexPolygonInverted(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangleInverted(e[0], e[t + 1], e[t + 2])
			}
		},
		Er = class {
			constructor(e) {
				this.generator = e
			}
			GenerateSurfaceBetweenPolygons(e, t) {
				if (e.length !== t.length) return;
				let i = e.length;
				for (let r = 0; r < i; r++) {
					let n = r,
						s = r < i - 1 ? n + 1 : 0;
					this.generator.AddConvexPolygon([e[n], e[s], t[s], t[n]])
				}
			}
			GenerateTriangleFan(e, t) {
				let i = e.length;
				for (let r = 0; r < i; r++) {
					let n = r,
						s = r < i - 1 ? n + 1 : 0;
					this.generator.AddTriangle(t, e[n], e[s])
				}
			}
		};

	function vs(o, e) {
		return new O(o * Math.cos(e), o * Math.sin(e))
	}

	function Is(o, e, t, i) {
		if (!ze(e) || !ze(t) || !ze(i)) return null;
		let r = new ei(o);
		return r.AddVertex(0, 0, 0), r.AddVertex(e, 0, 0), r.AddVertex(e, t, 0), r.AddVertex(0, t, 0), r.AddVertex(0, 0, i), r.AddVertex(e, 0, i), r.AddVertex(e, t, i), r.AddVertex(0, t, i), r.AddConvexPolygon([0, 3, 2, 1]), r.AddConvexPolygon([0, 1, 5, 4]), r.AddConvexPolygon([1, 2, 6, 5]), r.AddConvexPolygon([2, 3, 7, 6]), r.AddConvexPolygon([3, 0, 4, 7]), r.AddConvexPolygon([4, 5, 6, 7]), r.GetMesh()
	}

	function Ar(o, e, t, i, r, n) {
		if (pt(e) || pt(t) || !ze(i) || r < 3) return null;
		let s = Yt(e),
			l = Yt(t);
		if (s && l) return null;
		let a = new ei(o),
			h = new Er(a),
			u = 2 * Math.PI / r,
			d = n ? 1 : null,
			m = [];
		if (s) m.push(a.AddVertex(0, 0, i));
		else
			for (let p = 0; p < r; p++) {
				let c = vs(e, p * u);
				m.push(a.AddVertex(c.x, c.y, i))
			}
		let f = [];
		if (l) f.push(a.AddVertex(0, 0, 0));
		else
			for (let p = 0; p < r; p++) {
				let c = vs(t, p * u);
				f.push(a.AddVertex(c.x, c.y, 0))
			}
		return s ? (a.SetCurve(d), h.GenerateTriangleFan(f, m[0]), a.ResetCurve(), a.AddConvexPolygonInverted(f)) : l ? (a.SetCurve(d), h.GenerateTriangleFan(m.slice()
			.reverse(), f[0]), a.ResetCurve(), a.AddConvexPolygon(m)) : (a.SetCurve(d), h.GenerateSurfaceBetweenPolygons(f, m), a.ResetCurve(), a.AddConvexPolygonInverted(f), a.AddConvexPolygon(m)), a.GetMesh()
	}

	function Ts(o, e, t, i, r) {
		return Ar(o, e, e, t, i, r)
	}

	function Ms(o, e, t, i) {
		function r(f, p, c) {
			return new T(f * Math.sin(p) * Math.cos(c), f * Math.sin(p) * Math.sin(c), f * Math.cos(p))
		}
		if (!ze(e) || t < 3) return null;
		let n = new ei(o),
			s = new Er(n);
		n.SetCurve(i ? 1 : null);
		let l = [],
			a = t + 1,
			h = Math.PI / t,
			u = 2 * Math.PI / t;
		for (let f = 1; f < a - 1; f++) {
			let p = [],
				c = f * h;
			for (let g = 0; g < t; g++) {
				let x = g * u,
					C = r(e, c, -x);
				p.push(n.AddVertex(C.x, C.y, C.z))
			}
			f > 1 && s.GenerateSurfaceBetweenPolygons(l[l.length - 1], p), l.push(p)
		}
		let d = n.AddVertex(0, 0, e),
			m = n.AddVertex(0, 0, -e);
		return s.GenerateTriangleFan(l[0].slice()
			.reverse(), d), s.GenerateTriangleFan(l[l.length - 1], m), n.ResetCurve(), n.GetMesh()
	}

	function ys(o, e, t) {
		function i(n, s, l, a, h) {
			let u = new T(l, a, h);
			u.MultiplyScalar(s / u.Length()), n.AddVertex(u.x, u.y, u.z)
		}
		if (!ze(t)) return null;
		let r = new ei(o);
		if (e === "tetrahedron") {
			let n = 1;
			i(r, t, +n, +n, +n), i(r, t, -n, -n, +n), i(r, t, -n, +n, -n), i(r, t, +n, -n, -n), r.AddTriangle(0, 1, 3), r.AddTriangle(0, 2, 1), r.AddTriangle(0, 3, 2), r.AddTriangle(1, 2, 3)
		} else if (e === "hexahedron") {
			let n = 1;
			i(r, t, +n, +n, +n), i(r, t, +n, +n, -n), i(r, t, +n, -n, +n), i(r, t, +n, -n, -n), i(r, t, -n, +n, +n), i(r, t, -n, +n, -n), i(r, t, -n, -n, +n), i(r, t, -n, -n, -n), r.AddConvexPolygon([0, 1, 5, 4]), r.AddConvexPolygon([0, 2, 3, 1]), r.AddConvexPolygon([0, 4, 6, 2]), r.AddConvexPolygon([1, 3, 7, 5]), r.AddConvexPolygon([2, 6, 7, 3]), r.AddConvexPolygon([4, 5, 7, 6])
		} else if (e === "octahedron") {
			let n = 1,
				s = 0;
			i(r, t, +n, +s, +s), i(r, t, -n, +s, +s), i(r, t, +s, +n, +s), i(r, t, +s, -n, +s), i(r, t, +s, +s, +n), i(r, t, +s, +s, -n), r.AddTriangle(0, 2, 4), r.AddTriangle(0, 3, 5), r.AddTriangle(0, 4, 3), r.AddTriangle(0, 5, 2), r.AddTriangle(1, 2, 5), r.AddTriangle(1, 3, 4), r.AddTriangle(1, 4, 2), r.AddTriangle(1, 5, 3)
		} else if (e === "dodecahedron") {
			let n = 1,
				s = 0,
				l = (1 + Math.sqrt(5)) / 2,
				a = 1 / l;
			i(r, t, +n, +n, +n), i(r, t, +n, +n, -n), i(r, t, +n, -n, +n), i(r, t, -n, +n, +n), i(r, t, +n, -n, -n), i(r, t, -n, +n, -n), i(r, t, -n, -n, +n), i(r, t, -n, -n, -n), i(r, t, +s, +a, +l), i(r, t, +s, +a, -l), i(r, t, +s, -a, +l), i(r, t, +s, -a, -l), i(r, t, +a, +l, +s), i(r, t, +a, -l, +s), i(r, t, -a, +l, +s), i(r, t, -a, -l, +s), i(r, t, +l, +s, +a), i(r, t, -l, +s, +a), i(r, t, +l, +s, -a), i(r, t, -l, +s, -a), r.AddConvexPolygon([0, 8, 10, 2, 16]), r.AddConvexPolygon([0, 16, 18, 1, 12]), r.AddConvexPolygon([0, 12, 14, 3, 8]), r.AddConvexPolygon([1, 9, 5, 14, 12]), r.AddConvexPolygon([1, 18, 4, 11, 9]), r.AddConvexPolygon([2, 10, 6, 15, 13]), r.AddConvexPolygon([2, 13, 4, 18, 16]), r.AddConvexPolygon([3, 14, 5, 19, 17]), r.AddConvexPolygon([3, 17, 6, 10, 8]), r.AddConvexPolygon([4, 13, 15, 7, 11]), r.AddConvexPolygon([5, 9, 11, 7, 19]), r.AddConvexPolygon([6, 17, 19, 7, 15])
		} else if (e === "icosahedron") {
			let n = 1,
				s = 0,
				l = (1 + Math.sqrt(5)) / 2;
			i(r, t, +s, +n, +l), i(r, t, +s, +n, -l), i(r, t, +s, -n, +l), i(r, t, +s, -n, -l), i(r, t, +n, +l, +s), i(r, t, +n, -l, +s), i(r, t, -n, +l, +s), i(r, t, -n, -l, +s), i(r, t, +l, +s, +n), i(r, t, +l, +s, -n), i(r, t, -l, +s, +n), i(r, t, -l, +s, -n), r.AddTriangle(0, 2, 8), r.AddTriangle(0, 4, 6), r.AddTriangle(0, 6, 10), r.AddTriangle(0, 8, 4), r.AddTriangle(0, 10, 2), r.AddTriangle(1, 3, 11), r.AddTriangle(1, 4, 9), r.AddTriangle(1, 6, 4), r.AddTriangle(1, 9, 3), r.AddTriangle(1, 11, 6), r.AddTriangle(2, 5, 8), r.AddTriangle(2, 7, 5), r.AddTriangle(2, 10, 7), r.AddTriangle(3, 5, 7), r.AddTriangle(3, 7, 11), r.AddTriangle(3, 9, 5), r.AddTriangle(4, 8, 9), r.AddTriangle(5, 9, 8), r.AddTriangle(6, 11, 10), r.AddTriangle(7, 10, 11)
		}
		return r.GetMesh()
	}
	var Dr = class extends W {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "o3dv"
		}
		GetUpDirection() {
			return G.Z
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {
			let i = re(e),
				r = JSON.parse(i);
			if (r.root === void 0) {
				t();
				return
			}
			if (r.materials !== void 0)
				for (let s = 0; s < r.materials.length; s++) {
					let l = r.materials[s];
					this.ImportMaterial(l)
				}
			if (r.meshes !== void 0)
				for (let s = 0; s < r.meshes.length; s++) {
					let l = r.meshes[s];
					this.ImportMesh(l)
				}
			let n = r.nodes[r.root];
			this.ImportNode(r, n, this.model.GetRootNode()), this.ImportProperties(this.model, r), t()
		}
		ImportMaterial(e) {
			let t = new yt;
			t.color.Set(255, 255, 255), e.name !== void 0 && (t.name = e.name), e.color !== void 0 && (t.color = Pn(e.color)), t.metalness = je(e.metalness, 0), t.roughness = je(e.roughness, 1), this.model.AddMaterial(t)
		}
		ImportMesh(e) {
			let t = new Ui;
			e.name !== void 0 && t.SetName(e.name), e.material !== void 0 && t.SetMaterial(e.material);
			let i = e.parameters;
			if (i === void 0) return;
			let r = null;
			if (e.type === "cuboid") {
				if (i.size_x === void 0 || i.size_y === void 0 || i.size_z === void 0) return;
				r = Is(t, i.size_x, i.size_y, i.size_z)
			} else if (e.type === "cylinder") {
				if (i.radius === void 0 || i.height === void 0) return;
				let n = je(i.segments, 25),
					s = je(i.smooth, !0);
				r = Ts(t, i.radius, i.height, n, s)
			} else if (e.type === "cone") {
				if (i.top_radius === void 0 || i.bottom_radius === void 0 || i.height === void 0) return;
				let n = je(i.segments, 25),
					s = je(i.smooth, !0);
				r = Ar(t, i.top_radius, i.bottom_radius, i.height, n, s)
			} else if (e.type === "sphere") {
				if (i.radius === void 0) return;
				let n = je(i.segments, 20),
					s = je(i.smooth, !0);
				r = Ms(t, i.radius, n, s)
			} else if (e.type === "platonic") {
				if (i.solid_type === void 0) return;
				let n = je(i.radius, 1);
				r = ys(t, i.solid_type, n)
			}
			r !== null && (this.ImportProperties(r, e), this.model.AddMesh(r))
		}
		ImportNode(e, t, i) {
			if (t.name !== void 0 && i.SetName(t.name), t.transformation !== void 0) {
				let r = this.GetTransformation(t.transformation);
				i.SetTransformation(r)
			}
			if (t.children !== void 0)
				for (let r of t.children) {
					let n = e.nodes[r],
						s = new be;
					i.AddChildNode(s), this.ImportNode(e, n, s)
				}
			t.mesh !== void 0 && ((t.children === void 0 || t.children.length === 0) && i.SetType(fe.MeshNode), i.AddMeshIndex(t.mesh))
		}
		ImportProperties(e, t) {
			if (t.properties !== void 0) {
				let i = new Ge("Properties");
				e.AddPropertyGroup(i);
				for (let r of t.properties) {
					let n = new B(P.Text, r.name, r.value);
					i.AddProperty(n)
				}
			}
		}
		GetTransformation(e) {
			let t = new T(0, 0, 0),
				i = new ye(0, 0, 0, 1),
				r = new T(1, 1, 1);
			e.translation !== void 0 && (t = Qe(e.translation)), e.rotation !== void 0 && (i = Ut(e.rotation)), e.scale !== void 0 && (r = Qe(e.scale));
			let n = new U()
				.ComposeTRS(t, i, r);
			return new q(n)
		}
	};
	var bs = class {
		constructor(e) {
			this.mesh = e, this.globalToMeshVertices = new Map, this.globalToMeshVertexColors = new Map, this.globalToMeshNormals = new Map, this.globalToMeshUvs = new Map
		}
		AddVertex(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertices, i => this.mesh.AddVertex(new T(i.x, i.y, i.z)))
		}
		AddVertexColor(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertexColors, i => this.mesh.AddVertexColor(new D(i.r, i.g, i.b)))
		}
		AddNormal(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshNormals, i => this.mesh.AddNormal(new T(i.x, i.y, i.z)))
		}
		AddUV(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshUvs, i => this.mesh.AddTextureUV(new O(i.x, i.y)))
		}
		AddTriangle(e) {
			this.mesh.AddTriangle(e)
		}
		GetLocalIndex(e, t, i, r) {
			if (isNaN(e) || e < 0 || e >= t.length) return null;
			if (i.has(e)) return i.get(e); {
				let n = t[e],
					s = r(n);
				return i.set(e, s), s
			}
		}
	};

	function Hi(o, e, t) {
		return Ne(parseFloat(o), parseFloat(e), parseFloat(t))
	}
	var Gr = class extends W {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "obj"
		}
		GetUpDirection() {
			return G.Y
		}
		ClearContent() {
			this.globalVertices = null, this.globalVertexColors = null, this.globalNormals = null, this.globalUvs = null, this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = null, this.materialNameToIndex = null
		}
		ResetContent() {
			this.globalVertices = [], this.globalVertexColors = [], this.globalNormals = [], this.globalUvs = [], this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = new Map, this.materialNameToIndex = new Map
		}
		ImportContent(e, t) {
			let i = re(e);
			Pe(i, r => {
				this.WasError() || this.ProcessLine(r)
			}), t()
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = et(e, "#");
			if (t.length === 0) return;
			let i = t[0].toLowerCase();
			t.shift(), !this.ProcessMeshParameter(i, t, e) && this.ProcessMaterialParameter(i, t, e)
		}
		AddNewMesh(e) {
			if (this.meshNameToConverter.has(e)) this.currentMeshConverter = this.meshNameToConverter.get(e);
			else {
				let t = new Y;
				t.SetName(e), this.model.AddMeshToRootNode(t), this.currentMeshConverter = new bs(t), this.meshNameToConverter.set(e, this.currentMeshConverter)
			}
		}
		ProcessMeshParameter(e, t, i) {
			if (e === "g" || e === "o") {
				if (t.length === 0) return !0;
				let r = ut(i, e.length, "#");
				return this.AddNewMesh(r), !0
			} else {
				if (e === "v") return t.length < 3 || (this.globalVertices.push(new T(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), t.length >= 6 && this.globalVertexColors.push(Hi(t[3], t[4], t[5]))), !0;
				if (e === "vn") return t.length < 3 || this.globalNormals.push(new T(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), !0;
				if (e === "vt") return t.length < 2 || this.globalUvs.push(new O(parseFloat(t[0]), parseFloat(t[1]))), !0;
				if (e === "f") return t.length < 3 || this.ProcessFace(t), !0
			}
			return !1
		}
		ProcessMaterialParameter(e, t, i) {
			function r(n, s, l) {
				let a = new Oe,
					h = ut(s, n.length, "#"),
					u = l.getTextureBuffer(h);
				return a.name = h, u !== null && (a.url = u.url, a.buffer = u.buffer), a
			}
			if (e === "newmtl") {
				if (t.length === 0) return !0;
				let n = new Q,
					s = ut(i, e.length, "#"),
					l = this.model.AddMaterial(n);
				return n.name = s, this.currentMaterial = n, this.materialNameToIndex.set(s, l), !0
			} else if (e === "usemtl") {
				if (t.length === 0) return !0;
				let n = ut(i, e.length, "#");
				return this.materialNameToIndex.has(n) && (this.currentMaterialIndex = this.materialNameToIndex.get(n)), !0
			} else if (e === "mtllib") {
				if (t.length === 0) return !0;
				let n = ut(i, e.length, "#"),
					s = this.callbacks.getFileBuffer(n);
				if (s !== null) {
					let l = re(s);
					Pe(l, a => {
						this.WasError() || this.ProcessLine(a)
					})
				}
				return !0
			} else {
				if (e === "map_kd") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.diffuseMap = r(e, i, this.callbacks), ce(this.currentMaterial)), !0;
				if (e === "map_ks") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.specularMap = r(e, i, this.callbacks)), !0;
				if (e === "map_bump" || e === "bump") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.bumpMap = r(e, i, this.callbacks)), !0;
				if (e === "ka") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.ambient = Hi(t[0], t[1], t[2])), !0;
				if (e === "kd") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.color = Hi(t[0], t[1], t[2])), !0;
				if (e === "ks") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.specular = Hi(t[0], t[1], t[2])), !0;
				if (e === "ns") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.shininess = parseFloat(t[0]) / 1e3), !0;
				if (e === "tr") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = 1 - parseFloat(t[0]), ce(this.currentMaterial)), !0;
				if (e === "d") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = parseFloat(t[0]), ce(this.currentMaterial)), !0
			}
			return !1
		}
		ProcessFace(e) {
			function t(l, a) {
				return l > 0 ? l - 1 : a + l
			}
			let i = [],
				r = [],
				n = [],
				s = [];
			for (let l = 0; l < e.length; l++) {
				let a = e[l].split("/");
				i.push(t(parseInt(a[0], 10), this.globalVertices.length)), this.globalVertices.length === this.globalVertexColors.length && r.push(t(parseInt(a[0], 10), this.globalVertices.length)), a.length > 1 && a[1].length > 0 && s.push(t(parseInt(a[1], 10), this.globalUvs.length)), a.length > 2 && a[2].length > 0 && n.push(t(parseInt(a[2], 10), this.globalNormals.length))
			}
			this.currentMeshConverter === null && this.AddNewMesh("");
			for (let l = 0; l < i.length - 2; l++) {
				let a = this.currentMeshConverter.AddVertex(i[0], this.globalVertices),
					h = this.currentMeshConverter.AddVertex(i[l + 1], this.globalVertices),
					u = this.currentMeshConverter.AddVertex(i[l + 2], this.globalVertices);
				if (a === null || h === null || u === null) {
					this.SetError("Invalid vertex index.");
					break
				}
				let d = new z(a, h, u);
				if (r.length === i.length) {
					let m = this.currentMeshConverter.AddVertexColor(r[0], this.globalVertexColors),
						f = this.currentMeshConverter.AddVertexColor(r[l + 1], this.globalVertexColors),
						p = this.currentMeshConverter.AddVertexColor(r[l + 2], this.globalVertexColors);
					if (m === null || f === null || p === null) {
						this.SetError("Invalid vertex color index.");
						break
					}
					d.SetVertexColors(m, f, p)
				}
				if (n.length === i.length) {
					let m = this.currentMeshConverter.AddNormal(n[0], this.globalNormals),
						f = this.currentMeshConverter.AddNormal(n[l + 1], this.globalNormals),
						p = this.currentMeshConverter.AddNormal(n[l + 2], this.globalNormals);
					if (m === null || f === null || p === null) {
						this.SetError("Invalid normal index.");
						break
					}
					d.SetNormals(m, f, p)
				}
				if (s.length === i.length) {
					let m = this.currentMeshConverter.AddUV(s[0], this.globalUvs),
						f = this.currentMeshConverter.AddUV(s[l + 1], this.globalUvs),
						p = this.currentMeshConverter.AddUV(s[l + 2], this.globalUvs);
					if (m === null || f === null || p === null) {
						this.SetError("Invalid uv index.");
						break
					}
					d.SetTextureUVs(m, f, p)
				}
				this.currentMaterialIndex !== null && (d.mat = this.currentMaterialIndex), this.currentMeshConverter.AddTriangle(d)
			}
		}
	};
	var _r = class extends W {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "off"
		}
		GetUpDirection() {
			return G.Y
		}
		ClearContent() {
			this.mesh = null, this.status = null
		}
		ResetContent() {
			this.mesh = new Y, this.model.AddMeshToRootNode(this.mesh), this.status = {
				vertexCount: 0,
				faceCount: 0,
				foundVertex: 0,
				foundFace: 0
			}
		}
		ImportContent(e, t) {
			let i = re(e);
			Pe(i, r => {
				this.WasError() || this.ProcessLine(r)
			}), t()
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = et(e, "#");
			if (t.length !== 0 && t[0] !== "OFF") {
				if (this.status.vertexCount === 0 && this.status.faceCount === 0) {
					t.length > 1 && (this.status.vertexCount = parseInt(t[0], 10), this.status.faceCount = parseInt(t[1], 10));
					return
				}
				if (this.status.foundVertex < this.status.vertexCount) {
					t.length >= 3 && (this.mesh.AddVertex(new T(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), this.status.foundVertex += 1);
					return
				}
				if (this.status.foundFace < this.status.faceCount) {
					if (t.length >= 4) {
						let i = parseInt(t[0], 10);
						if (t.length < i + 1) return;
						for (let r = 0; r < i - 2; r++) {
							let n = parseInt(t[1]),
								s = parseInt(t[r + 2]),
								l = parseInt(t[r + 3]),
								a = new z(n, s, l);
							this.mesh.AddTriangle(a)
						}
						this.status.foundFace += 1
					}
					return
				}
			}
		}
	};
	var dt = {
			Ok: 1,
			NoVertices: 2,
			NoFaces: 3,
			UnknownError: 4
		},
		Ss = class {
			constructor() {
				this.format = null, this.elements = []
			}
			SetFormat(e) {
				this.format = e
			}
			AddElement(e, t) {
				this.elements.push({
					name: e,
					count: t,
					format: []
				})
			}
			GetElements() {
				return this.elements
			}
			AddSingleFormat(e, t) {
				this.elements[this.elements.length - 1].format.push({
					name: t,
					isSingle: !0,
					elemType: e
				})
			}
			AddListFormat(e, t, i) {
				this.elements[this.elements.length - 1].format.push({
					name: i,
					isSingle: !1,
					countType: e,
					elemType: t
				})
			}
			GetElement(e) {
				for (let t = 0; t < this.elements.length; t++) {
					let i = this.elements[t];
					if (i.name === e) return i
				}
				return null
			}
			Check() {
				let e = this.GetElement("vertex");
				if (e === null || e.length === 0 || e.format.length < 3) return dt.NoVertices;
				let t = this.GetElement("face");
				if (this.format === "ascii") {
					if (t === null || t.count === 0 || t.format.length < 0) return dt.NoFaces
				} else if (this.format === "binary_little_endian" || this.format === "binary_big_endian") {
					let i = this.GetElement("tristrips"),
						r = t !== null && t.count > 0 && t.format.length > 0,
						n = i !== null && i.count > 0 && i.format.length > 0;
					if (!r && !n) return dt.NoFaces
				} else return dt.UnknownError;
				return dt.Ok
			}
		},
		ws = class {
			constructor(e) {
				this.model = e, this.colorToMaterial = new Map
			}
			GetMaterialIndexByColor(e) {
				let t = "Color " + ie(e[0]) + ie(e[1]) + ie(e[2]) + ie(e[3]);
				if (this.colorToMaterial.has(t)) return this.colorToMaterial.get(t); {
					let i = new Q;
					i.name = t, i.color = new D(e[0], e[1], e[2]), i.opacity = e[3] / 255, ce(i);
					let r = this.model.AddMaterial(i);
					return this.colorToMaterial.set(t, r), r
				}
			}
		},
		Pr = class extends W {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "ply"
			}
			GetUpDirection() {
				return G.Y
			}
			ClearContent() {
				this.mesh = null
			}
			ResetContent() {
				this.mesh = new Y, this.model.AddMeshToRootNode(this.mesh)
			}
			ImportContent(e, t) {
				let i = this.GetHeaderContent(e),
					r = this.ReadHeader(i),
					n = r.Check();
				if (n === dt.Ok)
					if (r.format === "ascii") {
						let s = re(e);
						s = s.substring(i.length), this.ReadAsciiContent(r, s)
					} else(r.format === "binary_little_endian" || r.format === "binary_big_endian") && this.ReadBinaryContent(r, e, i.length);
				else n === dt.NoVertices ? this.SetError("The model contains no vertices.") : n === dt.NoFaces ? this.SetError("The model contains no faces.") : this.SetError("Invalid header information.");
				t()
			}
			GetHeaderContent(e) {
				let t = "",
					i = new Uint8Array(e),
					r = 0;
				for (r = 0; r < e.byteLength && (t += String.fromCharCode(i[r]), !t.endsWith("end_header")); r++);
				for (r += 1; r < e.byteLength;) {
					let n = String.fromCharCode(i[r]);
					if (t += n, r += 1, n === `
`) break
				}
				return t
			}
			ReadHeader(e) {
				let t = new Ss;
				return Pe(e, i => {
					let r = et(i, null);
					r.length === 0 || r[0] === "comment" || r[0] !== "ply" && (r[0] === "format" && r.length >= 2 ? t.SetFormat(r[1]) : r[0] === "element" && r.length >= 3 ? t.AddElement(r[1], parseInt(r[2], 10)) : r[0] === "property" && r.length >= 3 && (r[1] === "list" && r.length >= 5 ? t.AddListFormat(r[2], r[3], r[4]) : t.AddSingleFormat(r[1], r[2])))
				}), t
			}
			ReadAsciiContent(e, t) {
				let i = e.GetElement("vertex"),
					r = e.GetElement("face"),
					n = 0,
					s = 0;
				Pe(t, l => {
					if (this.WasError()) return;
					let a = et(l, null);
					if (!(a.length === 0 || a[0] === "comment")) {
						if (n < i.count) {
							a.length >= 3 && (this.mesh.AddVertex(new T(parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]))), n += 1);
							return
						}
						if (r !== null && s < r.count) {
							if (a.length >= 4) {
								let h = parseInt(a[0], 10);
								if (a.length < h + 1) return;
								for (let u = 0; u < h - 2; u++) {
									let d = parseInt(a[1]),
										m = parseInt(a[u + 2]),
										f = parseInt(a[u + 3]),
										p = new z(d, m, f);
									this.mesh.AddTriangle(p)
								}
								s += 1
							}
							return
						}
					}
				})
			}
			ReadBinaryContent(e, t, i) {
				function r(u, d) {
					function m(f, p) {
						return p === "char" || p === "int8" ? f.ReadCharacter8() : p === "uchar" || p === "uint8" ? f.ReadUnsignedCharacter8() : p === "short" || p === "int16" ? f.ReadInteger16() : p === "ushort" || p === "uint16" ? f.ReadUnsignedInteger16() : p === "int" || p === "int32" ? f.ReadInteger32() : p === "uint" || p === "uint32" ? f.ReadUnsignedInteger32() : p === "float" || p === "float32" ? f.ReadFloat32() : p === "double" || p === "double64" ? f.ReadDouble64() : null
					}
					if (d.isSingle) return m(u, d.elemType); {
						let f = [],
							p = m(u, d.countType);
						for (let c = 0; c < p; c++) f.push(m(u, d.elemType));
						return f
					}
				}

				function n(u, d, m) {
					for (let f = m; f < d.length; f++) r(u, d[f])
				}

				function s(u, d, m) {
					let f = null,
						p = null,
						c = null,
						g = 255;
					for (let x = m; x < d.length; x++) {
						let C = d[x],
							M = r(u, C);
						C.name === "red" ? f = M : C.name === "green" ? p = M : C.name === "blue" ? c = M : C.name === "alpha" && (g = M)
					}
					return f !== null && p !== null && c !== null ? [f, p, c, g] : null
				}
				let l = null;
				if (e.format === "binary_little_endian") l = new Fe(t, !0);
				else if (e.format === "binary_big_endian") l = new Fe(t, !1);
				else return;
				l.Skip(i);
				let a = new ws(this.model),
					h = e.GetElements();
				for (let u = 0; u < h.length; u++) {
					let d = h[u];
					if (d.name === "vertex")
						for (let m = 0; m < d.count; m++) {
							let f = r(l, d.format[0]),
								p = r(l, d.format[1]),
								c = r(l, d.format[2]),
								g = s(l, d.format, 3);
							g !== null && this.mesh.AddVertexColor(new D(g[0], g[1], g[2])), this.mesh.AddVertex(new T(f, p, c))
						} else if (d.name === "face")
							for (let m = 0; m < d.count; m++) {
								let f = r(l, d.format[0]),
									p = s(l, d.format, 1);
								for (let c = 0; c < f.length - 2; c++) {
									let g = f[0],
										x = f[c + 1],
										C = f[c + 2],
										M = new z(g, x, C);
									p !== null ? M.mat = a.GetMaterialIndexByColor(p) : this.mesh.VertexColorCount() > 0 && M.SetVertexColors(g, x, C), this.mesh.AddTriangle(M)
								}
							} else if (d.name === "tristrips")
								for (let m = 0; m < d.count; m++) {
									let f = r(l, d.format[0]);
									n(l, d.format, 1);
									let p = !0;
									for (let c = 0; c < f.length - 2; c++) {
										let g = f[c],
											x = f[c + 1],
											C = f[c + 2];
										if (C === -1) {
											c += 2, p = !0;
											continue
										}
										if (!p) {
											let I = x;
											x = C, C = I
										}
										p = !p;
										let M = new z(g, x, C);
										this.mesh.AddTriangle(M)
									}
								} else n(l, d.format, 0)
				}
			}
		};
	var Fr = class extends W {
		constructor() {
			super();
			this.worker = null
		}
		CanImportExtension(e) {
			return e === "stp" || e === "step"
		}
		GetUpDirection() {
			return G.Y
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {
			if (this.worker === null) {
				let n = tr("loaders/occt-import-js-worker.js");
				this.worker = new Worker(n)
			}
			let i = n => {
				this.ImportStepContent(n.data, t), this.worker.removeEventListener("message", i)
			};
			this.worker.addEventListener("message", i), this.worker.addEventListener("error", n => {
				this.worker = null, this.SetError("Failed to load occt-import-js."), t()
			});
			let r = new Uint8Array(e);
			this.worker.postMessage(r)
		}
		ImportStepContent(e, t) {
			if (!e.success) return;
			let i = new Tr(r => {
				let n = new Q;
				return n.name = ue(r)
					.toUpperCase(), n.color = r, this.model.AddMaterial(n)
			});
			for (let r of e.meshes) {
				let n = null;
				if (r.color) {
					let l = Ne(r.color[0], r.color[1], r.color[2]);
					n = i.GetMaterialIndex(l)
				}
				let s = St(r, n);
				if (r.name && s.SetName(r.name), r.face_colors)
					for (let l of r.face_colors) {
						let a = Ne(l.color[0], l.color[1], l.color[2]),
							h = i.GetMaterialIndex(a);
						for (let u = l.first; u <= l.last; u++) s.GetTriangle(u)
							.SetMaterial(h)
					}
				this.model.AddMeshToRootNode(s)
			}
			t()
		}
	};
	var Rr = class extends W {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "stl"
		}
		GetUpDirection() {
			return G.Z
		}
		ClearContent() {
			this.mesh = null, this.triangle = null
		}
		ResetContent() {
			this.mesh = new Y, this.model.AddMeshToRootNode(this.mesh), this.triangle = null
		}
		ImportContent(e, t) {
			if (this.IsBinaryStlFile(e)) this.ProcessBinary(e);
			else {
				let i = re(e);
				Pe(i, r => {
					this.WasError() || this.ProcessLine(r)
				})
			}
			t()
		}
		IsBinaryStlFile(e) {
			let t = e.byteLength;
			if (t < 84) return !1;
			let i = new Fe(e, !0);
			i.Skip(80);
			let r = i.ReadUnsignedInteger32();
			return t === r * 50 + 84
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = et(e, "#");
			if (t.length === 0) return;
			let i = t[0];
			if (i === "solid") {
				if (t.length > 1) {
					let r = ut(e, i.length, "#");
					this.mesh.SetName(r)
				}
				return
			}
			if (i === "facet") {
				if (this.triangle = new z(-1, -1, -1), t.length >= 5 && t[1] === "normal") {
					let r = new T(parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4]));
					if (ze(r.Length())) {
						let n = this.mesh.AddNormal(r);
						this.triangle.SetNormals(n, n, n)
					}
				}
				return
			}
			if (i === "vertex" && this.triangle !== null) {
				if (t.length >= 4) {
					let r = this.mesh.AddVertex(new T(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])));
					this.triangle.v0 === -1 ? this.triangle.v0 = r : this.triangle.v1 === -1 ? this.triangle.v1 = r : this.triangle.v2 === -1 && (this.triangle.v2 = r)
				}
				return
			}
			if (i === "endfacet" && this.triangle !== null) {
				this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null && this.mesh.AddTriangle(this.triangle), this.triangle = null;
				return
			}
		}
		ProcessBinary(e) {
			function t(s) {
				let l = new T;
				return l.x = s.ReadFloat32(), l.y = s.ReadFloat32(), l.z = s.ReadFloat32(), l
			}

			function i(s, l) {
				let a = t(l);
				return s.AddVertex(a)
			}
			let r = new Fe(e, !0);
			r.Skip(80);
			let n = r.ReadUnsignedInteger32();
			for (let s = 0; s < n; s++) {
				let l = t(r),
					a = i(this.mesh, r),
					h = i(this.mesh, r),
					u = i(this.mesh, r);
				r.Skip(2);
				let d = new z(a, h, u);
				if (ze(l.Length())) {
					let m = this.mesh.AddNormal(l);
					d.SetNormals(m, m, m)
				}
				this.mesh.AddTriangle(d)
			}
		}
	};
	var Nr = class extends W {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "bim"
		}
		GetUpDirection() {
			return G.Z
		}
		ClearContent() {
			this.meshIdToMesh = null, this.colorToMaterialIndex = null
		}
		ResetContent() {
			this.meshIdToMesh = new Map, this.colorToMaterialIndex = new Map
		}
		ImportContent(e, t) {
			let i = re(e),
				r = null;
			try {
				r = JSON.parse(i)
			} catch {
				this.SetError("Failed to parse bim file."), t();
				return
			}
			for (let n of r.meshes) this.meshIdToMesh.set(n.mesh_id, n);
			this.ImportProperties(r, this.model);
			for (let n of r.elements) {
				let s = this.ImportElement(n);
				s.SetName(n.type), this.ImportProperties(n, s)
			}
			t()
		}
		ImportElement(e) {
			let t = null;
			if (e.color) {
				let m = ie(e.color.r) + ie(e.color.g) + ie(e.color.b) + ie(e.color.a);
				if (this.colorToMaterialIndex.has(m)) t = this.colorToMaterialIndex.get(m);
				else {
					let f = new Q;
					f.name = m, f.color = new D(e.color.r, e.color.g, e.color.b), e.color.a < 255 && (f.opacity = e.color.a / 255, ce(f)), t = this.model.AddMaterial(f), this.colorToMaterialIndex.set(m, t)
				}
			}
			let i = this.model.GetRootNode(),
				r = this.meshIdToMesh.get(e.mesh_id),
				n = this.ImportMesh(r, t),
				s = this.model.AddMesh(n),
				l = new be;
			l.SetType(fe.MeshNode), l.AddMeshIndex(s);
			let a = new T(0, 0, 0);
			e.vector && (a = new T(e.vector.x, e.vector.y, e.vector.z));
			let h = new ye(0, 0, 0, 1);
			e.rotation && (h = new ye(e.rotation.qx, e.rotation.qy, e.rotation.qz, e.rotation.qw));
			let u = new T(1, 1, 1),
				d = new U()
				.ComposeTRS(a, h, u);
			return l.SetTransformation(new q(d)), i.AddChildNode(l), n
		}
		ImportMesh(e, t) {
			let i = new Y;
			for (let r = 0; r < e.coordinates.length; r += 3) i.AddVertex(new T(e.coordinates[r + 0], e.coordinates[r + 1], e.coordinates[r + 2]));
			for (let r = 0; r < e.indices.length; r += 3) {
				let n = new z(e.indices[r + 0], e.indices[r + 1], e.indices[r + 2]);
				t !== null && n.SetMaterial(t), i.AddTriangle(n)
			}
			return i
		}
		ImportProperties(e, t) {
			function i(s, l, a) {
				if (a == null) return;
				let h = new B(P.Text, l, a);
				s.AddProperty(h)
			}
			if (!e.info) return;
			let r = e.info,
				n = new Ge("Info");
			i(n, "Guid", e.guid), i(n, "Type", e.type);
			for (let s in r) Object.prototype.hasOwnProperty.call(r, s) && typeof r[s] == "string" && i(n, s, r[s]);
			t.AddPropertyGroup(n)
		}
	};
	var ti = class extends W {
			constructor() {
				super()
			}
			GetExternalLibraries() {
				return null
			}
			CreateLoader(e) {
				return null
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				return !0
			}
			ClearContent() {
				this.loader = null, this.materialIdToIndex = null, this.objectUrlToFileName = null
			}
			ResetContent() {
				this.loader = null, this.materialIdToIndex = new Map, this.objectUrlToFileName = new Map
			}
			ImportContent(e, t) {
				async function i(n, s, l) {
					try {
						for (let a = 0; a < n.length; a++) await xe(n[a])
					} catch {
						l()
					}
					s()
				}
				let r = this.GetExternalLibraries();
				if (r === null) {
					t();
					return
				}
				i(r, () => {
					this.LoadModel(e, t)
				}, () => {
					this.SetError("Failed to load three.js loader."), t()
				})
			}
			LoadModel(e, t) {
				let i = !1,
					r = new THREE.LoadingManager(() => {
						i = !0
					}),
					n = It(e);
				r.setURLModifier(l => {
					if (l === n) return l;
					let a = $(l);
					if (Be(l)
						.length > 0) {
						let u = this.callbacks.getFileBuffer(l);
						if (u !== null) {
							let d = It(u);
							return this.objectUrlToFileName.set(d, a), d
						}
					}
					return l
				});
				let s = this.CreateLoader(r);
				if (s === null) {
					t();
					return
				}
				s.load(n, l => {
					$n(() => i ? (this.OnThreeObjectsLoaded(l, t), !1) : !0)
				}, () => {}, l => {
					this.SetError(l), t()
				})
			}
			OnThreeObjectsLoaded(e, t) {
				function i(l) {
					let a = new U()
						.CreateIdentity();
					return l.updateMatrix(), l.matrix !== void 0 && l.matrix !== null && a.Set(l.matrix.elements), new q(a)
				}

				function r(l, a, h, u) {
					let d = new be;
					h.name !== void 0 && d.SetName(h.name), d.SetTransformation(i(h)), u.AddChildNode(d);
					for (let m of h.children) r(l, a, m, d);
					if (h.isMesh && l.IsMeshVisible(h)) {
						h.children.length === 0 && d.SetType(fe.MeshNode);
						let m = l.ConvertThreeMesh(h),
							f = a.AddMesh(m);
						d.AddMeshIndex(f)
					}
				}
				let n = this.GetMainObject(e),
					s = this.model.GetRootNode();
				s.SetTransformation(i(n));
				for (let l of n.children) r(this, this.model, l, s);
				t()
			}
			ConvertThreeMesh(e) {
				let t = null;
				if (Array.isArray(e.material)) {
					if (t = St(e.geometry, null), e.geometry.attributes.color === void 0 || e.geometry.attributes.color === null) {
						let i = [];
						for (let r = 0; r < e.material.length; r++) {
							let n = e.material[r],
								s = this.FindOrCreateMaterial(n);
							i.push(s)
						}
						for (let r = 0; r < e.geometry.groups.length; r++) {
							let n = e.geometry.groups[r],
								s = null;
							n.count === 1 / 0 ? s = t.TriangleCount() : s = n.start / 3 + n.count / 3;
							for (let l = n.start / 3; l < s; l++) t.GetTriangle(l)
								.SetMaterial(i[n.materialIndex])
						}
					}
				} else {
					let i = this.FindOrCreateMaterial(e.material);
					t = St(e.geometry, i)
				}
				return e.name !== void 0 && e.name !== null && t.SetName(e.name), t
			}
			FindOrCreateMaterial(e) {
				if (this.materialIdToIndex.has(e.id)) return this.materialIdToIndex.get(e.id);
				let t = this.ConvertThreeMaterial(e),
					i = this.model.AddMaterial(t);
				return this.materialIdToIndex.set(e.id, i), i
			}
			ConvertThreeMaterial(e) {
				function t(r, n) {
					function s(l) {
						if (l.data !== void 0 && l.data !== null) {
							let a = new ImageData(l.width, l.height),
								h = l.width * l.height * 4;
							for (let u = 0; u < h; u++) a.data[u] = l.data[u];
							return THREE.ImageUtils.getDataURL(a)
						} else return THREE.ImageUtils.getDataURL(l)
					}
					if (r == null || r.image === void 0 || r.image === null) return null;
					try {
						let l = s(r.image),
							a = Jt(l),
							h = new Oe,
							u = null;
						return n.has(r.image.src) ? u = n.get(r.image.src) : r.name !== void 0 && r.name !== null ? u = r.name + "." + kt(a.mimeType) : u = "Embedded_" + r.id.toString() + "." + kt(a.mimeType), h.name = u, h.url = l, h.buffer = a.buffer, h.rotation = r.rotation, h.offset.x = r.offset.x, h.offset.y = r.offset.y, h.scale.x = r.repeat.x, h.scale.y = r.repeat.y, h
					} catch {
						return null
					}
				}
				let i = new Q;
				return i.name = e.name, i.color = Bi(e.color), i.opacity = e.opacity, i.transparent = e.transparent, i.alphaTest = e.alphaTest, e.type === "MeshPhongMaterial" && (i.specular = Bi(e.specular), i.shininess = e.shininess / 100), i.diffuseMap = t(e.map, this.objectUrlToFileName), i.normalMap = t(e.normalMap, this.objectUrlToFileName), i.bumpMap = t(e.bumpMap, this.objectUrlToFileName), i
			}
		},
		Vr = class extends ti {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "fbx"
			}
			GetUpDirection() {
				return G.Y
			}
			GetExternalLibraries() {
				return ["loaders/fflate.min.js", "three_loaders/TGALoader.js", "three_loaders/FBXLoader.js"]
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new THREE.TGALoader(e)), new THREE.FBXLoader(e)
			}
			GetMainObject(e) {
				return e
			}
		},
		Lr = class extends ti {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "dae"
			}
			GetUpDirection() {
				return G.Y
			}
			GetExternalLibraries() {
				return ["three_loaders/TGALoader.js", "three_loaders/ColladaLoader.js"]
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new THREE.TGALoader(e)), new THREE.ColladaLoader(e)
			}
			GetMainObject(e) {
				return e.scene
			}
		},
		Br = class extends ti {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "wrl"
			}
			GetUpDirection() {
				return G.Y
			}
			GetExternalLibraries() {
				return ["three_loaders/chevrotain.min.js", "three_loaders/VRMLLoader.js"]
			}
			CreateLoader(e) {
				return new THREE.VRMLLoader(e)
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				let t = !0;
				if (Array.isArray(e.material)) {
					for (let i = 0; i < e.material.length; i++)
						if (e.material[i].side === THREE.BackSide) {
							t = !1;
							break
						}
				} else t = e.material.side !== THREE.BackSide;
				return t
			}
		},
		Or = class extends ti {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "3mf"
			}
			GetUpDirection() {
				return G.Z
			}
			GetExternalLibraries() {
				return ["loaders/fflate.min.js", "three_loaders/3MFLoader.js"]
			}
			CreateLoader(e) {
				return new THREE.ThreeMFLoader(e)
			}
			GetMainObject(e) {
				return e
			}
		};
	var jt = class {
			constructor() {
				this.defaultColor = new D(200, 200, 200)
			}
		},
		Re = {
			NoImportableFile: 1,
			FailedToLoadFile: 2,
			ImportFailed: 3,
			UnknownError: 4
		},
		ii = class {
			constructor(e) {
				this.code = e, this.mainFile = null, this.message = null
			}
		},
		Es = class {
			constructor() {
				this.model = null, this.mainFile = null, this.upVector = null, this.usedFiles = null, this.missingFiles = null
			}
		},
		As = class {
			constructor(e) {
				this.getBufferCallback = e, this.fileBuffers = new Map, this.textureBuffers = new Map
			}
			GetFileBuffer(e) {
				let t = $(e);
				if (this.fileBuffers.has(t)) return this.fileBuffers.get(t);
				let i = this.getBufferCallback(t);
				return this.fileBuffers.set(t, i), i
			}
			GetTextureBuffer(e) {
				let t = $(e);
				if (this.textureBuffers.has(t)) return this.textureBuffers.get(t);
				let i = null,
					r = this.getBufferCallback(t);
				return r !== null && (i = {
					url: It(r),
					buffer: r
				}), this.textureBuffers.set(t, i), i
			}
		},
		kr = class {
			constructor() {
				this.importers = [new Gr, new Rr, new _r, new Pr, new yr, new Sr, new Dr, new Nr, new Mr, new wr, new Fr, new Vr, new Lr, new Br, new Or], this.fileList = new Ri, this.model = null, this.usedFiles = [], this.missingFiles = []
			}
			AddImporter(e) {
				this.importers.push(e)
			}
			ImportFiles(e, t, i, r) {
				this.LoadFiles(e, t, () => {
					r.onFilesLoaded(), Mt(() => {
						this.ImportLoadedFiles(i, r)
					})
				})
			}
			LoadFiles(e, t, i) {
				let r = new Ri;
				t === Z.Url ? r.FillFromFileUrls(e) : t === Z.File && r.FillFromFileObjects(e);
				let n = !1;
				if (this.HasImportableFile(r)) n = !0;
				else {
					let s = !1;
					for (let l = 0; l < this.missingFiles.length; l++) {
						let a = this.missingFiles[l];
						r.ContainsFileByPath(a) && (s = !0)
					}
					if (!s) n = !0;
					else {
						let l = r.GetFiles();
						this.fileList.ExtendFromFileList(l), n = !1
					}
				}
				n && (this.fileList = r), this.fileList.GetContent(() => {
					this.DecompressArchives(this.fileList, () => {
						i()
					})
				})
			}
			ImportLoadedFiles(e, t) {
				let i = this.GetImportableFiles(this.fileList);
				if (i.length === 0) {
					t.onImportError(new ii(Re.NoImportableFile));
					return
				}
				if (i.length === 1 || !t.onSelectMainFile) {
					let r = i[0];
					this.ImportLoadedMainFile(r, e, t)
				} else {
					let r = i.map(n => n.file.name);
					t.onSelectMainFile(r, n => {
						if (n === null) {
							t.onImportError(new ii(Re.NoImportableFile));
							return
						}
						Mt(() => {
							let s = i[n];
							this.ImportLoadedMainFile(s, e, t)
						})
					})
				}
			}
			ImportLoadedMainFile(e, t, i) {
				if (e === null || e.file === null || e.file.content === null) {
					let s = new ii(Re.FailedToLoadFile);
					e !== null && e.file !== null && (s.mainFile = e.file.name), i.onImportError(s);
					return
				}
				this.RevokeModelUrls(), this.model = null, this.usedFiles = [], this.missingFiles = [], this.usedFiles.push(e.file.name);
				let r = e.importer,
					n = new As(s => {
						let l = null,
							a = this.fileList.FindFileByPath(s);
						return a === null || a.content === null ? (this.missingFiles.push(s), l = null) : (this.usedFiles.push(s), l = a.content), l
					});
				r.Import(e.file.name, e.file.extension, e.file.content, {
					getDefaultMaterialColor: () => t.defaultColor,
					getFileBuffer: s => n.GetFileBuffer(s),
					getTextureBuffer: s => n.GetTextureBuffer(s),
					onSuccess: () => {
						this.model = r.GetModel();
						let s = new Es;
						s.mainFile = e.file.name, s.model = this.model, s.usedFiles = this.usedFiles, s.missingFiles = this.missingFiles, s.upVector = r.GetUpDirection(), i.onImportSuccess(s)
					},
					onError: () => {
						let s = new ii(Re.ImportFailed);
						s.mainFile = e.file.name, s.message = r.GetErrorMessage(), i.onImportError(s)
					},
					onComplete: () => {
						r.Clear()
					}
				})
			}
			DecompressArchives(e, t) {
				let i = e.GetFiles(),
					r = [];
				for (let n of i) n.extension === "zip" && r.push(n);
				if (r.length === 0) {
					t();
					return
				}
				xe("loaders/fflate.min.js")
					.then(() => {
						for (let n = 0; n < r.length; n++) {
							let s = r[n],
								l = new Uint8Array(s.content),
								a = fflate.unzipSync(l);
							for (let h in a)
								if (Object.prototype.hasOwnProperty.call(a, h)) {
									let u = new Fi(h, Z.Decompressed);
									u.SetContent(a[h].buffer), e.AddFile(u)
								}
						}
						t()
					})
					.catch(() => {
						t()
					})
			}
			GetFileList() {
				return this.fileList
			}
			HasImportableFile(e) {
				return this.GetImportableFiles(e)
					.length > 0
			}
			GetImportableFiles(e) {
				function t(n, s) {
					for (let l = 0; l < s.length; l++) {
						let a = s[l];
						if (a.CanImportExtension(n.extension)) return a
					}
					return null
				}
				let i = [],
					r = e.GetFiles();
				for (let n = 0; n < r.length; n++) {
					let s = r[n],
						l = t(s, this.importers);
					l !== null && i.push({
						file: s,
						importer: l
					})
				}
				return i
			}
			RevokeModelUrls() {
				if (this.model !== null)
					for (let e = 0; e < this.model.MaterialCount(); e++) this.model.GetMaterial(e)
						.EnumerateTextureMaps(i => {
							i.url !== null && Fn(i.url)
						})
			}
		};

	function Ds(o, e, t) {
		let i = e / t,
			r = i * i;
		return o * (r / (2 * (r - i) + 1))
	}

	function zi(o, e, t, i) {
		let r = oe(e, o)
			.Normalize(),
			n = Le(o, e),
			s = [];
		for (let l = 0; l < t; l++) {
			let a = i(n, l, t - 1);
			s.push(o.Clone()
				.Offset(r, a))
		}
		return s
	}
	var Gs = class {
			constructor() {
				this.prev = new O(0, 0), this.curr = new O(0, 0), this.diff = new O(0, 0), this.buttons = []
			}
			Down(e, t) {
				this.buttons.push(t.which), this.curr = this.GetPositionFromEvent(e, t), this.prev = this.curr.Clone()
			}
			Move(e, t) {
				this.curr = this.GetPositionFromEvent(e, t), this.diff = rr(this.curr, this.prev), this.prev = this.curr.Clone()
			}
			Up(e, t) {
				let i = this.buttons.indexOf(t.which);
				i !== -1 && this.buttons.splice(i, 1), this.curr = this.GetPositionFromEvent(e, t)
			}
			Leave(e, t) {
				this.buttons = [], this.curr = this.GetPositionFromEvent(e, t)
			}
			IsButtonDown() {
				return this.buttons.length > 0
			}
			GetButton() {
				let e = this.buttons.length;
				return e === 0 ? 0 : this.buttons[e - 1]
			}
			GetPosition() {
				return this.curr
			}
			GetMoveDiff() {
				return this.diff
			}
			GetPositionFromEvent(e, t) {
				return xt(e, t.clientX, t.clientY)
			}
		},
		_s = class {
			constructor() {
				this.prevPos = new O(0, 0), this.currPos = new O(0, 0), this.diffPos = new O(0, 0), this.prevDist = 0, this.currDist = 0, this.diffDist = 0, this.fingers = 0
			}
			Start(e, t) {
				t.touches.length !== 0 && (this.fingers = t.touches.length, this.currPos = this.GetPositionFromEvent(e, t), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.prevDist = this.currDist)
			}
			Move(e, t) {
				t.touches.length !== 0 && (this.currPos = this.GetPositionFromEvent(e, t), this.diffPos = rr(this.currPos, this.prevPos), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.diffDist = this.currDist - this.prevDist, this.prevDist = this.currDist)
			}
			End(e, t) {
				t.touches.length !== 0 && (this.fingers = 0, this.currPos = this.GetPositionFromEvent(e, t), this.currDist = this.GetTouchDistanceFromEvent(e, t))
			}
			IsFingerDown() {
				return this.fingers !== 0
			}
			GetFingerCount() {
				return this.fingers
			}
			GetPosition() {
				return this.currPos
			}
			GetMoveDiff() {
				return this.diffPos
			}
			GetDistanceDiff() {
				return this.diffDist
			}
			GetPositionFromEvent(e, t) {
				let i = null;
				if (t.touches.length !== 0) {
					let r = t.touches[0];
					i = xt(e, r.pageX, r.pageY)
				}
				return i
			}
			GetTouchDistanceFromEvent(e, t) {
				if (t.touches.length !== 2) return 0;
				let i = t.touches[0],
					r = t.touches[1];
				return nr(xt(e, i.pageX, i.pageY), xt(e, r.pageX, r.pageY))
			}
		},
		Ps = class {
			constructor() {
				this.isClick = !1, this.startPosition = null
			}
			Start(e) {
				this.isClick = !0, this.startPosition = e
			}
			Move(e) {
				!this.isClick || (this.startPosition !== null ? nr(this.startPosition, e) > 3 && this.Cancel() : this.Cancel())
			}
			End() {
				this.startPosition = null
			}
			Cancel() {
				this.isClick = !1, this.startPosition = null
			}
			IsClick() {
				return this.isClick
			}
		},
		we = {
			None: 0,
			Orbit: 1,
			Pan: 2,
			Zoom: 3
		},
		Ur = class {
			constructor(e, t, i) {
				this.canvas = e, this.camera = t, this.callbacks = i, this.fixUpVector = !0, this.mouse = new Gs, this.touch = new _s, this.clickDetector = new Ps, this.onMouseClick = null, this.onMouseMove = null, this.onContext = null, this.canvas.addEventListener && (this.canvas.addEventListener("mousedown", this.OnMouseDown.bind(this)), this.canvas.addEventListener("wheel", this.OnMouseWheel.bind(this)), this.canvas.addEventListener("touchstart", this.OnTouchStart.bind(this)), this.canvas.addEventListener("touchmove", this.OnTouchMove.bind(this)), this.canvas.addEventListener("touchcancel", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("touchend", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("contextmenu", this.OnContextMenu.bind(this))), document.addEventListener && (document.addEventListener("mousemove", this.OnMouseMove.bind(this)), document.addEventListener("mouseup", this.OnMouseUp.bind(this)), document.addEventListener("mouseleave", this.OnMouseLeave.bind(this)))
			}
			SetMouseClickHandler(e) {
				this.onMouseClick = e
			}
			SetMouseMoveHandler(e) {
				this.onMouseMove = e
			}
			SetContextMenuHandler(e) {
				this.onContext = e
			}
			IsFixUpVector() {
				return this.fixUpVector
			}
			SetFixUpVector(e) {
				this.fixUpVector = e
			}
			GetCamera() {
				return this.camera
			}
			SetCamera(e) {
				this.camera = e
			}
			MoveCamera(e, t) {
				function i(r, n, s, l) {
					r.camera.eye = n.eye[l], r.camera.center = n.center[l], r.camera.up = n.up[l], r.Update(), l < s - 1 && requestAnimationFrame(() => {
						i(r, n, s, l + 1)
					})
				}
				if (e !== null) {
					if (t === 0 || qn(this.camera, e)) this.camera = e;
					else {
						let r = Ds,
							n = {
								eye: zi(this.camera.eye, e.eye, t, r),
								center: zi(this.camera.center, e.center, t, r),
								up: zi(this.camera.up, e.up, t, r)
							};
						requestAnimationFrame(() => {
							i(this, n, t, 0)
						})
					}
					this.Update()
				}
			}
			GetFitToSphereCamera(e, t, i) {
				if (Yt(t)) return null;
				let r = this.camera.Clone(),
					n = oe(r.center, e);
				r.eye = oe(r.eye, n), r.center = e.Clone();
				let s = oe(r.eye, r.center)
					.Normalize(),
					l = i / 2;
				this.canvas.width < this.canvas.height && (l = l * this.canvas.width / this.canvas.height);
				let a = t / Math.sin(l * Lt);
				return r.eye = r.center.Clone()
					.Offset(s, a), r
			}
			OnMouseDown(e) {
				e.preventDefault(), this.mouse.Down(this.canvas, e), this.clickDetector.Start(this.mouse.GetPosition())
			}
			OnMouseMove(e) {
				if (this.mouse.Move(this.canvas, e), this.clickDetector.Move(this.mouse.GetPosition()), this.onMouseMove) {
					let n = xt(this.canvas, e.clientX, e.clientY);
					this.onMouseMove(n)
				}
				if (!this.mouse.IsButtonDown()) return;
				let t = this.mouse.GetMoveDiff(),
					i = this.mouse.GetButton(),
					r = we.None;
				if (i === 1 ? e.ctrlKey ? r = we.Zoom : e.shiftKey ? r = we.Pan : r = we.Orbit : (i === 2 || i === 3) && (r = we.Pan), r === we.Orbit) {
					let n = .5;
					this.Orbit(t.x * n, t.y * n)
				} else if (r === we.Pan) {
					let n = Le(this.camera.eye, this.camera.center),
						s = .001 * n;
					this.Pan(t.x * s, t.y * s)
				} else if (r === we.Zoom) {
					let n = .005;
					this.Zoom(-t.y * n)
				}
				this.Update()
			}
			OnMouseUp(e) {
				if (this.mouse.Up(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.mouse.GetPosition();
					this.Click(e.which, t)
				}
			}
			OnMouseLeave(e) {
				this.mouse.Leave(this.canvas, e), this.clickDetector.Cancel()
			}
			OnTouchStart(e) {
				e.preventDefault(), this.touch.Start(this.canvas, e), this.clickDetector.Start(this.touch.GetPosition())
			}
			OnTouchMove(e) {
				if (e.preventDefault(), this.touch.Move(this.canvas, e), this.clickDetector.Move(this.touch.GetPosition()), !this.touch.IsFingerDown()) return;
				let t = this.touch.GetMoveDiff(),
					i = this.touch.GetDistanceDiff(),
					r = this.touch.GetFingerCount(),
					n = we.None;
				if (r === 1 ? n = we.Orbit : r === 2 && (n = we.Pan), n === we.Orbit) {
					let s = .5;
					this.Orbit(t.x * s, t.y * s)
				} else if (n === we.Pan) {
					let s = .005;
					this.Zoom(i * s);
					let l = .001 * Le(this.camera.eye, this.camera.center);
					this.Pan(t.x * l, t.y * l)
				}
				this.Update()
			}
			OnTouchEnd(e) {
				if (e.preventDefault(), this.touch.End(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.touch.GetPosition();
					this.touch.GetFingerCount() === 1 && this.Click(1, t)
				}
			}
			OnMouseWheel(e) {
				let t = e || window.event;
				t.preventDefault();
				let i = -t.deltaY / 40,
					r = .1;
				i < 0 && (r = r * -1), this.Zoom(r), this.Update()
			}
			OnContextMenu(e) {
				e.preventDefault(), this.clickDetector.IsClick() && (this.Context(e.clientX, e.clientY), this.clickDetector.Cancel())
			}
			Orbit(e, t) {
				let i = e * Lt,
					r = t * Lt,
					n = oe(this.camera.center, this.camera.eye)
					.Normalize(),
					s = Ze(n, this.camera.up)
					.Normalize();
				if (this.fixUpVector) {
					let a = jn(n, this.camera.up) + r;
					wn(a, 0) && xi(a, Math.PI) && this.camera.eye.Rotate(s, -r, this.camera.center), this.camera.eye.Rotate(this.camera.up, -i, this.camera.center)
				} else {
					let l = Ze(s, n)
						.Normalize();
					this.camera.eye.Rotate(s, -r, this.camera.center), this.camera.eye.Rotate(l, -i, this.camera.center), this.camera.up = l
				}
			}
			Pan(e, t) {
				let i = oe(this.camera.center, this.camera.eye)
					.Normalize(),
					r = Ze(i, this.camera.up)
					.Normalize(),
					n = Ze(r, i)
					.Normalize();
				this.camera.eye.Offset(r, -e), this.camera.center.Offset(r, -e), this.camera.eye.Offset(n, t), this.camera.center.Offset(n, t)
			}
			Zoom(e) {
				let t = oe(this.camera.center, this.camera.eye),
					r = t.Length() * e;
				this.camera.eye.Offset(t, r)
			}
			Update() {
				this.callbacks.onUpdate()
			}
			Click(e, t) {
				this.onMouseClick && this.onMouseClick(e, t)
			}
			Context(e, t) {
				if (this.onContext) {
					let i = {
							x: e,
							y: t
						},
						r = xt(this.canvas, e, t);
					this.onContext(i, r)
				}
			}
		};

	function Fs(o, e) {
		function t(i, r) {
			for (let n of i) n.polygonOffset = r, n.polygonOffsetUnit = 1, n.polygonOffsetFactor = 1
		}
		t(o.material, e), o.userData.threeMaterials && t(o.userData.threeMaterials, e)
	}
	var Hr = class {
			constructor(e) {
				this.scene = e, this.mainObject = null, this.mainEdgeObject = null, this.edgeSettings = {
					showEdges: !1,
					edgeColor: new D(0, 0, 0),
					edgeThreshold: 1
				}
			}
			SetMainObject(e) {
				this.mainObject = e, this.scene.add(this.mainObject), this.edgeSettings.showEdges && this.GenerateMainEdgeObject()
			}
			UpdateWorldMatrix() {
				this.mainObject !== null && this.mainObject.updateWorldMatrix(!0, !0)
			}
			SetEdgeSettings(e, t, i) {
				let r = !1;
				if (e && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== i) && (r = !0), this.edgeSettings.showEdges = e, this.edgeSettings.edgeThreshold = i, this.edgeSettings.edgeColor = t, this.mainObject !== null)
					if (this.edgeSettings.showEdges)
						if (r) this.ClearMainEdgeObject(), this.GenerateMainEdgeObject();
						else {
							let n = _e(this.edgeSettings.edgeColor);
							this.EnumerateEdges(s => {
								s.material.color = n
							})
						}
				else this.ClearMainEdgeObject()
			}
			GenerateMainEdgeObject() {
				let e = _e(this.edgeSettings.edgeColor);
				this.mainEdgeObject = new THREE.Object3D, this.UpdateWorldMatrix(), this.EnumerateMeshes(t => {
					Fs(t, !0);
					let i = new THREE.EdgesGeometry(t.geometry, this.edgeSettings.edgeThreshold),
						r = new THREE.LineSegments(i, new THREE.LineBasicMaterial({
							color: e
						}));
					r.applyMatrix4(t.matrixWorld), r.userData = t.userData, r.visible = t.visible, this.mainEdgeObject.add(r)
				}), this.scene.add(this.mainEdgeObject)
			}
			GetBoundingBox(e) {
				let t = !1,
					i = new THREE.Box3;
				return this.EnumerateMeshes(r => {
					e(r.userData) && (i.union(new THREE.Box3()
						.setFromObject(r)), t = !0)
				}), t ? i : null
			}
			GetBoundingSphere(e) {
				let t = this.GetBoundingBox(e);
				if (t === null) return null;
				let i = new THREE.Sphere;
				return t.getBoundingSphere(i), i
			}
			Clear() {
				this.ClearMainObject(), this.ClearMainEdgeObject()
			}
			ClearMainObject() {
				this.mainObject !== null && (this.EnumerateMeshes(e => {
					e.geometry.dispose()
				}), this.scene.remove(this.mainObject), this.mainObject = null)
			}
			ClearMainEdgeObject() {
				this.mainEdgeObject !== null && (this.EnumerateMeshes(e => {
					Fs(e, !1)
				}), this.EnumerateEdges(e => {
					e.geometry.dispose()
				}), this.scene.remove(this.mainEdgeObject), this.mainEdgeObject = null)
			}
			EnumerateMeshes(e) {
				this.mainObject !== null && this.mainObject.traverse(t => {
					t.isMesh && e(t)
				})
			}
			EnumerateEdges(e) {
				this.mainEdgeObject !== null && this.mainEdgeObject.traverse(t => {
					t.isLineSegments && e(t)
				})
			}
			GetMeshIntersectionUnderMouse(e, t, i, r) {
				if (this.mainObject === null || e.x < 0 || e.x > i || e.y < 0 || e.y > r) return null;
				let n = new THREE.Raycaster,
					s = new THREE.Vector2;
				s.x = e.x / i * 2 - 1, s.y = -(e.y / r) * 2 + 1, n.setFromCamera(s, t);
				let l = n.intersectObject(this.mainObject, !0);
				for (let a = 0; a < l.length; a++) {
					let h = l[a];
					if (h.object.type === "Mesh" && h.object.visible) return h
				}
				return null
			}
		},
		zr = class {
			constructor(e) {
				this.scene = e, this.mainObject = null
			}
			AddObject(e) {
				this.mainObject === null && (this.mainObject = new THREE.Object3D, this.scene.add(this.mainObject)), this.mainObject.add(e)
			}
			Clear() {
				this.mainObject !== null && (this.mainObject.traverse(e => {
					(e.isMesh || e.isLineSegments) && e.geometry.dispose()
				}), this.scene.remove(this.mainObject), this.mainObject = null)
			}
		};

	function Rs(o) {
		return o === G.X ? new $e(new T(2, -3, 1.5), new T(0, 0, 0), new T(1, 0, 0)) : o === G.Y ? new $e(new T(-1.5, 2, 3), new T(0, 0, 0), new T(0, 1, 0)) : o === G.Z ? new $e(new T(-1.5, -3, 2), new T(0, 0, 0), new T(0, 0, 1)) : null
	}

	function Ns(o, e) {
		if (!e(o)) return !1;
		for (let t of o.children)
			if (!Ns(t, e)) return !1;
		return !0
	}

	function Co(o) {
		let e = null;
		return Ns(o, t => {
			if (t.isMesh)
				for (let i of t.material) return i.type === "MeshPhongMaterial" ? e = me.Phong : i.type === "MeshStandardMaterial" && (e = me.Physical), !1;
			return !0
		}), e
	}
	var Vs = class {
			constructor() {
				this.direction = G.Z, this.isFixed = !0, this.isFlipped = !1
			}
			SetDirection(e, t) {
				this.direction = e, this.isFlipped = !1;
				let i = Rs(this.direction),
					r = oe(i.eye, i.center),
					n = Le(t.center, t.eye),
					s = t.center.Clone()
					.Offset(r, n),
					l = t.Clone();
				return this.direction === G.X ? (l.up = new T(1, 0, 0), l.eye = s) : this.direction === G.Y ? (l.up = new T(0, 1, 0), l.eye = s) : this.direction === G.Z && (l.up = new T(0, 0, 1), l.eye = s), l
			}
			SetFixed(e, t) {
				return this.isFixed = e, this.isFixed ? this.SetDirection(this.direction, t) : null
			}
			Flip(e) {
				this.isFlipped = !this.isFlipped;
				let t = e.Clone();
				return t.up.MultiplyScalar(-1), t
			}
		},
		Ls = class {
			constructor(e) {
				this.scene = e, this.type = me.Phong, this.ambientLight = new THREE.AmbientLight(8947848), this.directionalLight = new THREE.DirectionalLight(8947848), this.environment = null, this.backgroundIsEnvMap = !1, this.scene.add(this.ambientLight), this.scene.add(this.directionalLight)
			}
			SetType(e) {
				this.type = e, this.UpdateShading()
			}
			UpdateShading() {
				this.type === me.Phong ? (this.ambientLight.color.set(8947848), this.directionalLight.color.set(8947848), this.scene.environment = null, this.scene.background = null) : this.type === me.Physical && (this.ambientLight.color.set(0), this.directionalLight.color.set(5592405), this.scene.environment = this.environment, this.backgroundIsEnvMap ? this.scene.background = this.environment : this.scene.background = null)
			}
			SetEnvironment(e, t, i) {
				let r = new THREE.CubeTextureLoader;
				this.environment = r.load(e, () => {
					i()
				}), this.backgroundIsEnvMap = t
			}
			UpdateByCamera(e) {
				let t = oe(e.eye, e.center);
				this.directionalLight.position.set(t.x, t.y, t.z)
			}
			CreateHighlightMaterial(e, t) {
				let i = null;
				return this.type === me.Phong ? i = new THREE.MeshPhongMaterial({
					color: e,
					side: THREE.DoubleSide
				}) : this.type === me.Physical && (i = new THREE.MeshStandardMaterial({
					color: e,
					side: THREE.DoubleSide
				})), i !== null && t && (i.polygonOffset = !0, i.polygonOffsetUnit = 1, i.polygonOffsetFactor = 1), i
			}
		},
		ri = class {
			constructor() {
				this.canvas = null, this.renderer = null, this.scene = null, this.geometry = null, this.extraGeometry = null, this.camera = null, this.shading = null, this.navigation = null, this.upVector = null, this.settings = {
					animationSteps: 40
				}
			}
			Init(e) {
				this.canvas = e, this.canvas.id = "viewer";
				let t = {
					canvas: this.canvas,
					antialias: !0
				};
				this.renderer = new THREE.WebGLRenderer(t), window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setClearColor("#ffffff", 1), this.renderer.setSize(this.canvas.width, this.canvas.height), this.scene = new THREE.Scene, this.geometry = new Hr(this.scene), this.extraGeometry = new zr(this.scene), this.InitNavigation(), this.InitShading(), this.Render()
			}
			SetMouseClickHandler(e) {
				this.navigation.SetMouseClickHandler(e)
			}
			SetMouseMoveHandler(e) {
				this.navigation.SetMouseMoveHandler(e)
			}
			SetContextMenuHandler(e) {
				this.navigation.SetContextMenuHandler(e)
			}
			SetEnvironmentMapSettings(e, t) {
				this.shading.SetEnvironment(e, t, () => {
					this.Render()
				}), this.shading.UpdateShading(), this.Render()
			}
			SetBackgroundColor(e) {
				let t = "#" + ue(e);
				this.renderer.setClearColor(t, 1), this.Render()
			}
			SetEdgeSettings(e, t, i) {
				this.geometry.SetEdgeSettings(e, t, i), this.Render()
			}
			GetCanvas() {
				return this.canvas
			}
			GetCamera() {
				return this.navigation.GetCamera()
			}
			SetCamera(e) {
				this.navigation.SetCamera(e), this.Render()
			}
			Resize(e, t) {
				let i = Dn(this.canvas, e, t);
				this.ResizeRenderer(i.width, i.height)
			}
			ResizeRenderer(e, t) {
				window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.camera.aspect = e / t, this.camera.updateProjectionMatrix(), this.renderer.setSize(e, t), this.Render()
			}
			FitSphereToWindow(e, t) {
				if (e === null) return;
				let i = new T(e.center.x, e.center.y, e.center.z),
					r = e.radius,
					n = this.camera.fov,
					s = this.navigation.GetFitToSphereCamera(i, r, n);
				this.navigation.MoveCamera(s, t ? this.settings.animationSteps : 0)
			}
			AdjustClippingPlanesToSphere(e) {
				e !== null && (e.radius < 10 ? (this.camera.near = .01, this.camera.far = 100) : e.radius < 100 ? (this.camera.near = .1, this.camera.far = 1e3) : e.radius < 1e3 ? (this.camera.near = 10, this.camera.far = 1e4) : (this.camera.near = 100, this.camera.far = 1e6), this.camera.updateProjectionMatrix(), this.Render())
			}
			IsFixUpVector() {
				return this.navigation.IsFixUpVector()
			}
			SetFixUpVector(e) {
				let t = this.navigation.GetCamera(),
					i = this.upVector.SetFixed(e, t);
				this.navigation.SetFixUpVector(e), i !== null && this.navigation.MoveCamera(i, this.settings.animationSteps), this.Render()
			}
			SetUpVector(e, t) {
				let i = this.navigation.GetCamera(),
					r = this.upVector.SetDirection(e, i),
					n = t ? this.settings.animationSteps : 0;
				this.navigation.MoveCamera(r, n), this.Render()
			}
			FlipUpVector() {
				let e = this.navigation.GetCamera(),
					t = this.upVector.Flip(e);
				this.navigation.MoveCamera(t, 0), this.Render()
			}
			Render() {
				let e = this.navigation.GetCamera();
				this.camera.position.set(e.eye.x, e.eye.y, e.eye.z), this.camera.up.set(e.up.x, e.up.y, e.up.z), this.camera.lookAt(new THREE.Vector3(e.center.x, e.center.y, e.center.z)), this.shading.UpdateByCamera(e), this.renderer.render(this.scene, this.camera)
			}
			SetMainObject(e) {
				let t = Co(e);
				this.geometry.SetMainObject(e), this.shading.SetType(t), this.Render()
			}
			AddExtraObject(e) {
				this.extraGeometry.AddObject(e), this.Render()
			}
			Clear() {
				this.geometry.Clear(), this.extraGeometry.Clear(), this.Render()
			}
			ClearExtra() {
				this.extraGeometry.Clear(), this.Render()
			}
			SetMeshesVisibility(e) {
				this.geometry.EnumerateMeshes(t => {
					let i = e(t.userData);
					t.visible !== i && (t.visible = i)
				}), this.geometry.EnumerateEdges(t => {
					let i = e(t.userData);
					t.visible !== i && (t.visible = i)
				}), this.Render()
			}
			SetMeshesHighlight(e, t) {
				function i(n, s) {
					let l = [];
					for (let a = 0; a < n.length; a++) l.push(s);
					return l
				}
				let r = this.CreateHighlightMaterial(e);
				this.geometry.EnumerateMeshes(n => {
					t(n.userData) ? n.userData.threeMaterials === null && (n.userData.threeMaterials = n.material, n.material = i(n.material, r)) : n.userData.threeMaterials !== null && (n.material = n.userData.threeMaterials, n.userData.threeMaterials = null)
				}), this.Render()
			}
			CreateHighlightMaterial(e) {
				let t = this.geometry.edgeSettings.showEdges;
				return this.shading.CreateHighlightMaterial(e, t)
			}
			GetMeshUserDataUnderMouse(e) {
				let t = this.GetMeshIntersectionUnderMouse(e);
				return t === null ? null : t.object.userData
			}
			GetMeshIntersectionUnderMouse(e) {
				let t = this.GetCanvasSize(),
					i = this.geometry.GetMeshIntersectionUnderMouse(e, this.camera, t.width, t.height);
				return i === null ? null : i
			}
			GetBoundingBox(e) {
				return this.geometry.GetBoundingBox(e)
			}
			GetBoundingSphere(e) {
				return this.geometry.GetBoundingSphere(e)
			}
			EnumerateMeshesUserData(e) {
				this.geometry.EnumerateMeshes(t => {
					e(t.userData)
				})
			}
			InitNavigation() {
				this.camera = new THREE.PerspectiveCamera(45, this.canvas.width / this.canvas.height, .1, 1e3), this.scene.add(this.camera);
				let e = this.renderer.domElement,
					t = Rs(G.Z);
				this.navigation = new Ur(e, t, {
					onUpdate: () => {
						this.Render()
					}
				}), this.upVector = new Vs
			}
			InitShading() {
				this.shading = new Ls(this.scene)
			}
			GetShadingType() {
				return this.shading.type
			}
			GetImageSize() {
				let e = new THREE.Vector2;
				return this.renderer.getSize(e), {
					width: parseInt(e.x, 10),
					height: parseInt(e.y, 10)
				}
			}
			GetCanvasSize() {
				let e = this.canvas.width,
					t = this.canvas.height;
				return window.devicePixelRatio && (e /= window.devicePixelRatio, t /= window.devicePixelRatio), {
					width: e,
					height: t
				}
			}
			GetImageAsDataUrl(e, t) {
				let i = this.GetImageSize(),
					r = e,
					n = t;
				window.devicePixelRatio && (r /= window.devicePixelRatio, n /= window.devicePixelRatio), this.ResizeRenderer(r, n), this.Render();
				let s = this.renderer.domElement.toDataURL();
				return this.ResizeRenderer(i.width, i.height), s
			}
		};
	var ni = class {
		constructor() {
			this.skipNextEvent = !1, this.eventListener = null
		}
		SetEventListener(e) {
			this.eventListener = e, window.onhashchange = this.OnChange.bind(this)
		}
		SkipNextEventHandler() {
			this.skipNextEvent = !0
		}
		HasHash() {
			return this.GetHash()
				.length > 0
		}
		ClearHash() {
			this.SetHash("")
		}
		GetModelFilesFromHash() {
			return Tt(this.GetHash())
				.GetModelUrls()
		}
		SetModelFilesToHash(e) {
			let t = _i(e);
			this.SetHash(t)
		}
		GetCameraFromHash() {
			return Tt(this.GetHash())
				.GetCamera()
		}
		GetBackgroundFromHash() {
			return Tt(this.GetHash())
				.GetBackgroundColor()
		}
		GetEnvironmentSettingsFromHash() {
			return Tt(this.GetHash())
				.GetEnvironmentSettings()
		}
		GetDefaultColorFromHash() {
			return Tt(this.GetHash())
				.GetDefaultColor()
		}
		GetEdgeSettingsFromHash() {
			return Tt(this.GetHash())
				.GetEdgeSettings()
		}
		GetHash() {
			return window.location.hash.substring(1)
		}
		SetHash(e) {
			window.location.hash = e
		}
		OnChange() {
			if (this.skipNextEvent) {
				this.skipNextEvent = !1;
				return
			}
			this.eventListener()
		}
	};
	var Wr = class {
			constructor() {
				this.forceMediumpForMaterials = !1
			}
		},
		jr = class {
			constructor() {
				this.defaultMaterial = null
			}
		},
		Bs = class {
			constructor(e) {
				this.callbacks = e, this.texturesNeeded = 0, this.texturesLoaded = 0, this.threeObject = null
			}
			OnTextureNeeded() {
				this.texturesNeeded += 1
			}
			OnTextureLoaded() {
				this.texturesLoaded += 1, this.callbacks.onTextureLoaded(), this.Finish()
			}
			OnModelLoaded(e) {
				this.threeObject = e, this.Finish()
			}
			Finish() {
				this.threeObject !== null && this.texturesNeeded === this.texturesLoaded && this.callbacks.onModelLoaded(this.threeObject)
			}
		},
		Os = class {
			constructor(e, t) {
				this.meshInstances = [], this.AddNode(e, t)
			}
			AddNode(e, t) {
				let i = e.GetTransformation()
					.GetMatrix(),
					r = new THREE.Matrix4()
					.fromArray(i.Get());
				t.applyMatrix4(r);
				for (let n of e.GetChildNodes()) {
					let s = new THREE.Object3D;
					t.add(s), this.AddNode(n, s)
				}
				for (let n of e.GetMeshIndices()) this.meshInstances.push({
					node: e,
					threeNode: t,
					meshIndex: n
				})
			}
			GetMeshInstances() {
				return this.meshInstances
			}
		};

	function ks(o, e, t, i) {
		function r(m, f, p, c, g, x) {
			function C(S, A) {
				A.wrapS = THREE.RepeatWrapping, A.wrapT = THREE.RepeatWrapping, A.rotation = S.rotation, A.offset.x = S.offset.x, A.offset.y = S.offset.y, A.repeat.x = S.scale.x, A.repeat.y = S.scale.y
			}

			function M(S, A, k, F) {
				if (k === null || !k.IsValid()) return;
				let N = new THREE.TextureLoader;
				S.OnTextureNeeded(), N.load(k.url, V => {
					C(k, V), A.needsUpdate = !0, F(V), S.OnTextureLoaded()
				}, null, V => {
					S.OnTextureLoaded()
				})
			}
			let I = f.GetMaterial(p),
				b = _e(I.color);
			I.vertexColors && b.setRGB(1, 1, 1);
			let w = {
				color: b,
				vertexColors: I.vertexColors,
				opacity: I.opacity,
				transparent: I.transparent,
				alphaTest: I.alphaTest,
				side: THREE.DoubleSide
			};
			g.forceMediumpForMaterials && (w.precision = "mediump");
			let y = null;
			if (c === me.Phong) {
				if (y = new THREE.MeshPhongMaterial(w), I.type === K.Phong) {
					let S = _e(I.specular);
					J(I.shininess, 0) && S.setRGB(0, 0, 0), y.specular = S, y.shininess = I.shininess * 100, M(m, y, I.specularMap, A => {
						y.specularMap = A
					})
				}
			} else c === me.Physical && (y = new THREE.MeshStandardMaterial(w), I.type === K.Physical && (y.metalness = I.metalness, y.roughness = I.roughness, M(m, y, I.metalnessMap, S => {
				y.metalness = 1, y.roughness = 1, y.metalnessMap = S, y.roughnessMap = S
			})));
			let E = _e(I.emissive);
			return y.emissive = E, M(m, y, I.diffuseMap, S => {
				I.multiplyDiffuseMap || y.color.setRGB(1, 1, 1), y.map = S
			}), M(m, y, I.bumpMap, S => {
				y.bumpMap = S
			}), M(m, y, I.normalMap, S => {
				y.normalMap = S
			}), M(m, y, I.emissiveMap, S => {
				y.emissiveMap = S
			}), I.isDefault && (x.defaultMaterial = y), y
		}

		function n(m, f, p) {
			let c = m.GetMesh(f.meshIndex),
				g = c.TriangleCount(),
				x = [];
			for (let V = 0; V < g; V++) x.push(V);
			x.sort((V, ae) => {
				let H = c.GetTriangle(V),
					Me = c.GetTriangle(ae);
				return H.mat - Me.mat
			});
			let C = new THREE.BufferGeometry,
				M = [],
				I = [],
				b = new Map,
				w = [],
				y = [],
				E = [],
				S = [],
				A = [];
			A.push({
				start: 0,
				end: -1
			});
			let k = c.VertexColorCount() > 0,
				F = c.TextureUVCount() > 0;
			for (let V = 0; V < x.length; V++) {
				let ae = x[V],
					H = c.GetTriangle(ae),
					Me = c.GetVertex(H.v0),
					He = c.GetVertex(H.v1),
					pi = c.GetVertex(H.v2);
				if (w.push(Me.x, Me.y, Me.z, He.x, He.y, He.z, pi.x, pi.y, pi.z), H.HasVertexColors()) {
					let j = _e(c.GetVertexColor(H.c0)),
						Nt = _e(c.GetVertexColor(H.c1)),
						Vt = _e(c.GetVertexColor(H.c2));
					y.push(j.r, j.g, j.b, Nt.r, Nt.g, Nt.b, Vt.r, Vt.g, Vt.b)
				} else k && y.push(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let Ft = c.GetNormal(H.n0),
					Rt = c.GetNormal(H.n1),
					ct = c.GetNormal(H.n2);
				if (E.push(Ft.x, Ft.y, Ft.z, Rt.x, Rt.y, Rt.z, ct.x, ct.y, ct.z), H.HasTextureUVs()) {
					let j = c.GetTextureUV(H.u0),
						Nt = c.GetTextureUV(H.u1),
						Vt = c.GetTextureUV(H.u2);
					S.push(j.x, j.y, Nt.x, Nt.y, Vt.x, Vt.y)
				} else F && S.push(0, 0, 0, 0, 0, 0);
				let se = H.mat;
				b.has(se) || (b.set(se, M.length), M.push(p[se]), I.push(se), V > 0 && (A[A.length - 1].end = V - 1, A.push({
					start: A[A.length - 1].end + 1,
					end: -1
				})))
			}
			A[A.length - 1].end = g - 1, C.setAttribute("position", new THREE.Float32BufferAttribute(w, 3)), y.length !== 0 && C.setAttribute("color", new THREE.Float32BufferAttribute(y, 3)), C.setAttribute("normal", new THREE.Float32BufferAttribute(E, 3)), S.length !== 0 && C.setAttribute("uv", new THREE.Float32BufferAttribute(S, 2));
			for (let V = 0; V < A.length; V++) {
				let ae = A[V];
				C.addGroup(ae.start * 3, (ae.end - ae.start + 1) * 3, V)
			}
			let N = new THREE.Mesh(C, M);
			return N.userData = {
				originalMeshId: f,
				originalMaterials: I,
				threeMaterials: null
			}, N
		}

		function s(m, f, p, c) {
			let g = f.GetMesh(p.meshIndex);
			if (zt(g) === lt.TriangleMesh) {
				let C = n(f, p, c);
				m.add(C)
			}
		}

		function l(m, f, p, c) {
			let g = f.GetRootNode(),
				C = new Os(g, m)
				.GetMeshInstances();
			Qn(C.length, 100, {
				runTask: (M, I, b) => {
					for (let w = M; w <= I; w++) {
						let y = C[w],
							E = y.node,
							S = y.threeNode,
							A = new ht(E.GetId(), y.meshIndex);
						s(S, f, A, p)
					}
					b()
				},
				onReady: () => {
					c.OnModelLoaded(m)
				}
			})
		}
		let a = new Bs(i),
			h = ds(o),
			u = [];
		for (let m = 0; m < o.MaterialCount(); m++) {
			let f = r(a, o, m, h, e, t);
			u.push(f)
		}
		let d = new THREE.Object3D;
		l(d, o, u, a)
	}
	var qr = class {
		constructor() {
			this.importer = new kr, this.inProgress = !1, this.defaultMaterial = null, this.hasHighpDriverIssue = us()
		}
		InProgress() {
			return this.inProgress
		}
		LoadModel(e, t, i, r) {
			this.inProgress || (this.inProgress = !0, r.onLoadStart(), this.importer.ImportFiles(e, t, i, {
				onFilesLoaded: () => {
					r.onImportStart()
				},
				onSelectMainFile: (n, s) => {
					r.onSelectMainFile ? r.onSelectMainFile(n, s) : s(0)
				},
				onImportSuccess: n => {
					r.onVisualizationStart();
					let s = new Wr;
					s.forceMediumpForMaterials = this.hasHighpDriverIssue;
					let l = new jr;
					ks(n.model, s, l, {
						onTextureLoaded: () => {
							r.onTextureLoaded()
						},
						onModelLoaded: a => {
							if (this.defaultMaterial = l.defaultMaterial, n.upVector === G.X) {
								let h = new THREE.Quaternion()
									.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
								a.quaternion.multiply(h)
							} else if (n.upVector === G.Z) {
								let h = new THREE.Quaternion()
									.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
								a.quaternion.multiply(h)
							}
							r.onModelFinished(n, a), this.inProgress = !1
						}
					})
				},
				onImportError: n => {
					r.onLoadError(n), this.inProgress = !1
				}
			}))
		}
		GetImporter() {
			return this.importer
		}
		GetDefaultMaterial() {
			return this.defaultMaterial
		}
		ReplaceDefaultMaterialColor(e) {
			this.defaultMaterial !== null && !this.defaultMaterial.vertexColors && (this.defaultMaterial.color = _e(e))
		}
	};
	var si = null;

	function Xr() {
		si !== null && (si.Close(), si = null)
	}

	function vo() {
		si = null
	}

	function Io(o) {
		Xr(), si = o
	}
	var Wi = class {
			constructor() {
				this.modalDiv = Ie("ov_modal"), this.modalDiv.addEventListener("mousemove", e => {
					e.stopPropagation()
				}), this.overlayDiv = null, this.resizeHandler = null, this.positionCalculator = null, this.closeHandler = null, this.isOpen = !1, this.closeable = !0
			}
			GetContentDiv() {
				return this.modalDiv
			}
			SetCloseable(e) {
				this.closeable = e
			}
			SetPositionCalculator(e) {
				this.positionCalculator = e
			}
			SetCloseHandler(e) {
				this.closeHandler = e
			}
			Open() {
				this.isOpen || (Io(this), this.overlayDiv = v(document.body, "ov_modal_overlay"), document.body.appendChild(this.modalDiv), this.resizeHandler = this.Resize.bind(this), window.addEventListener("resize", this.resizeHandler), this.closeable && (this.overlayDiv.addEventListener("click", e => {
					e.preventDefault(), this.Close()
				}), this.overlayDiv.addEventListener("mousemove", e => {
					e.stopPropagation()
				}), this.overlayDiv.addEventListener("contextmenu", e => {
					e.preventDefault(), this.Close()
				})), this.isOpen = !0, this.Resize())
			}
			Close() {
				!this.isOpen || (vo(), window.removeEventListener("resize", this.resizeHandler), this.closeHandler !== null && this.closeHandler(), this.modalDiv.remove(), this.overlayDiv.remove(), this.overlayDiv = null, this.resizeHandler = null, this.isOpen = !1)
			}
			Resize() {
				let e = window.innerWidth,
					t = window.innerHeight,
					i = (e - this.modalDiv.offsetWidth) / 2,
					r = (t - this.modalDiv.offsetHeight) / 3;
				if (this.positionCalculator !== null) {
					let n = this.positionCalculator();
					i = n.x, r = n.y
				}
				this.modalDiv.style.left = i + "px", this.modalDiv.style.top = r + "px"
			}
		},
		oi = class extends Wi {
			constructor() {
				super();
				this.SetCloseable(!1), this.textDiv = null
			}
			Init(e) {
				let t = this.GetContentDiv();
				t.classList.add("ov_progress"), v(t, "ov_progress_img", '<svg><use href="assets/images/3dviewer_net_logo.svg#logo"></use></svg>'), this.textDiv = v(t, "ov_progress_text"), this.SetText(e)
			}
			SetText(e) {
				this.textDiv.innerHTML = e
			}
		},
		Ee = class extends Wi {
			constructor() {
				super()
			}
			Init(e, t) {
				function i(a, h) {
					let u = v(h, "ov_button ov_dialog_button", a.name);
					a.subClass && u.classList.add(a.subClass), u.addEventListener("click", () => {
						a.onClick()
					})
				}
				let r = this.GetContentDiv();
				r.classList.add("ov_dialog"), v(r, "ov_dialog_title", e);
				let n = v(r, "ov_dialog_content"),
					s = v(r, "ov_dialog_buttons"),
					l = v(s, "ov_dialog_buttons_inner");
				for (let a = 0; a < t.length; a++) i(t[a], l);
				return n
			}
		},
		ji = class extends Wi {
			constructor() {
				super()
			}
			Init(e) {
				let t = this.GetContentDiv();
				return t.classList.add("ov_popup"), this.SetPositionCalculator(e), t
			}
		},
		Yr = class extends ji {
			constructor() {
				super();
				this.listDiv = null
			}
			Init(e) {
				let t = super.Init(e);
				return this.listDiv = v(t, "ov_popup_list ov_thin_scrollbar"), t
			}
			AddListItem(e, t) {
				let i = v(this.listDiv, "ov_popup_list_item");
				if (e.icon && ne(i, e.icon, "left_inline"), e.color) {
					let r = v(i, "ov_popup_list_item_icon"),
						n = Si(e.color);
					r.appendChild(n)
				}
				v(i, "ov_popup_list_item_name", e.name), i.addEventListener("click", t.onClick), lr() && t.onHoverStart && t.onHoverStop && (i.addEventListener("mouseover", () => {
					t.onHoverStart()
				}), i.addEventListener("mouseout", () => {
					t.onHoverStop()
				}))
			}
		};

	function tt(o, e, t) {
		let i = new Ee,
			r = i.Init(o, [{
				name: "OK",
				onClick() {
					i.Close()
				}
			}]);
		return v(r, "ov_dialog_message", e), t !== null && v(r, "ov_dialog_submessage", t), i.Open(), i
	}

	function qt(o, e) {
		if (o.length === 0) return null;
		let t = new Yr;
		t.Init(() => e.calculatePosition(t.GetContentDiv()));
		for (let i = 0; i < o.length; i++) {
			let r = o[i];
			t.AddListItem(r, {
				onHoverStart: function() {
					e.onHoverStart && e.onHoverStart(i)
				},
				onHoverStop: function() {
					e.onHoverStop && e.onHoverStop(i)
				},
				onClick: function() {
					t.Close(), e.onClick(i)
				}
			})
		}
		return t.Open(), t
	}

	function Us(o, e) {
		let t = o.getBoundingClientRect();
		return {
			x: t.left - e.offsetWidth,
			y: t.top
		}
	}

	function qi(o, e) {
		let t = o.getBoundingClientRect();
		return {
			x: t.left + o.offsetWidth,
			y: t.top + o.offsetHeight - e.offsetHeight
		}
	}

	function Hs(o, e) {
		let t = window.innerWidth,
			i = window.innerHeight,
			r = o.x,
			n = o.y,
			s = r + e.offsetWidth,
			l = n + e.offsetHeight;
		return s > t && (r = r - (s - t)), l > i && (n = n - (l - i)), {
			x: r,
			y: n
		}
	}
	var li = class {
		constructor() {
			this.modelLoader = new qr, this.modalDialog = null
		}
		LoadModel(e, t, i, r) {
			if (this.modelLoader.InProgress()) return;
			let n = null;
			this.modelLoader.LoadModel(e, t, i, {
				onLoadStart: () => {
					this.CloseDialogIfOpen(), r.onStart(), n = new oi, n.Init("Loading Model"), n.Open()
				},
				onSelectMainFile: (s, l) => {
					n.Close(), this.modalDialog = this.ShowFileSelectorDialog(s, a => {
						n.Open(), l(a)
					})
				},
				onImportStart: () => {
					n.SetText("Importing Model")
				},
				onVisualizationStart: () => {
					n.SetText("Visualizing Model")
				},
				onModelFinished: (s, l) => {
					n.Close(), r.onFinish(s, l)
				},
				onTextureLoaded: () => {
					r.onRender()
				},
				onLoadError: s => {
					n.Close(), r.onError(s), this.modalDialog = this.ShowErrorDialog(s)
				}
			})
		}
		GetModelLoader() {
			return this.modelLoader
		}
		GetImporter() {
			return this.modelLoader.GetImporter()
		}
		ShowErrorDialog(e) {
			return e.code === Re.NoImportableFile ? tt("Something went wrong", "No importable file found.", null) : e.code === Re.FailedToLoadFile ? tt("Something went wrong", "Failed to load file for import.", "The remote server refused to fulfill the request. Check if the url is correct, and make sure that CORS requests are allowed on the remote server.") : e.code === Re.ImportFailed ? tt("Something went wrong", "Failed to import model.", e.message) : tt("Something went wrong", "Unknown error.", null)
		}
		ShowFileSelectorDialog(e, t) {
			let i = new Ee,
				r = i.Init("Select Model", [{
					name: "Cancel",
					subClass: "outline",
					onClick() {
						i.Close()
					}
				}]);
			i.SetCloseHandler(() => {
				t(null)
			}), v(r, "ov_dialog_message", "Multiple importable models found. Select the model you would like to import from the list below.");
			let s = v(r, "ov_dialog_section"),
				l = v(s, "ov_dialog_import_file_list ov_thin_scrollbar");
			for (let a = 0; a < e.length; a++) {
				let h = e[a],
					u = v(l, "ov_dialog_file_link");
				ne(u, "meshes", "ov_file_link_img"), v(u, "ov_dialog_file_link_text", h), u.addEventListener("click", () => {
					i.SetCloseHandler(null), i.Close(), t(a)
				})
			}
			return i.Open(), i
		}
		CloseDialogIfOpen() {
			this.modalDialog !== null && (this.modalDialog.Close(), this.modalDialog = null)
		}
	};
	var Kr = class {
		constructor(e) {
			this.parameters = e, this.viewer = new ri, this.hashHandler = new ni, this.modelLoaderUI = new li
		}
		Load() {
			let e = X(this.parameters.viewerDiv, "canvas");
			if (this.viewer.Init(e), this.Resize(), this.hashHandler.HasHash()) {
				let t = this.hashHandler.GetModelFilesFromHash();
				if (t === null) return;
				Pi(t);
				let i = "fishermans_bastion",
					r = !1,
					n = this.hashHandler.GetEnvironmentSettingsFromHash();
				n !== null && (i = n.environmentMapName, r = n.backgroundIsEnvMap);
				let s = "assets/envmaps/" + i + "/",
					l = [s + "posx.jpg", s + "negx.jpg", s + "posy.jpg", s + "negy.jpg", s + "posz.jpg", s + "negz.jpg"];
				this.viewer.SetEnvironmentMapSettings(l, r);
				let a = this.hashHandler.GetBackgroundFromHash();
				a !== null && this.viewer.SetBackgroundColor(a);
				let h = this.hashHandler.GetEdgeSettingsFromHash();
				h !== null && this.viewer.SetEdgeSettings(h.showEdges, h.edgeColor, h.edgeThreshold);
				let u = new jt,
					d = this.hashHandler.GetDefaultColorFromHash();
				d !== null && (u.defaultColor = d), this.modelLoaderUI.LoadModel(t, Z.Url, u, {
					onStart: () => {},
					onFinish: (p, c) => {
						this.OnModelFinished(c)
					},
					onRender: () => {
						this.viewer.Render()
					},
					onError: p => {}
				});
				let m = _i(t),
					f = this.parameters.websiteLinkDiv.getAttribute("href") + "#" + m;
				this.parameters.websiteLinkDiv.setAttribute("href", f)
			}
			window.addEventListener("resize", () => {
				this.Resize()
			})
		}
		Resize() {
			let e = window.innerWidth,
				t = window.innerHeight;
			this.viewer.Resize(e, t)
		}
		OnModelFinished(e) {
			this.viewer.SetMainObject(e);
			let t = this.viewer.GetBoundingSphere(r => !0);
			this.viewer.AdjustClippingPlanesToSphere(t);
			let i = this.hashHandler.GetCameraFromHash();
			i !== null ? this.viewer.SetCamera(i) : (this.viewer.SetUpVector(G.Y, !1), this.viewer.FitSphereToWindow(t, !1))
		}
	};
	var ai = class {
			constructor(e) {
				this.parentDiv = e, this.panelDiv = v(e), L(this.panelDiv, !1), this.visible = !1
			}
			GetName() {
				return null
			}
			GetIcon() {
				return null
			}
			IsVisible() {
				return this.visible
			}
			Show(e) {
				this.visible !== e && (this.visible = e, L(this.panelDiv, this.visible))
			}
			Resize() {}
			Clear() {}
		},
		hi = class {
			constructor(e) {
				this.parentDiv = e, this.menuDiv = v(e, "ov_panel_set_menu"), this.contentDiv = v(e, "ov_panel_set_content ov_thin_scrollbar"), this.panels = [], this.panelButtons = [], this.panelsVisible = !0, this.panelsPrevWidth = null, this.callbacks = null
			}
			Init(e) {
				this.callbacks = e
			}
			GetContentDiv() {
				return this.contentDiv
			}
			AddPanel(e) {
				this.panels.push(e);
				let t = ne(this.menuDiv, e.GetIcon(), "ov_panel_set_menu_button");
				t.setAttribute("alt", e.GetName()), t.setAttribute("title", e.GetName()), this.panelButtons.push(t), t.addEventListener("click", () => {
					e === this.GetVisiblePanel() ? this.ShowPanels(!1) : (this.ShowPanels(!0), this.ShowPanel(e))
				})
			}
			IsPanelsVisible() {
				return this.panelsVisible
			}
			ShowPanels(e) {
				if (!!this.IsParentVisible() && this.panelsVisible !== e) {
					if (this.panelsVisible = e, this.panelsVisible) L(this.contentDiv, !0), Bt(this.parentDiv, this.menuDiv.offsetWidth + this.panelsPrevWidth);
					else {
						for (let t of this.panelButtons) t.classList.remove("selected");
						for (let t of this.panels) t.Show(!1);
						this.panelsPrevWidth = this.contentDiv.offsetWidth, Bt(this.parentDiv, this.menuDiv.offsetWidth), L(this.contentDiv, !1)
					}
					this.callbacks.onShowHidePanels(this.panelsVisible), this.callbacks.onResize()
				}
			}
			ShowPanel(e) {
				if (e === this.GetVisiblePanel()) return;
				let t = this.GetPanelButton(e);
				for (let i of this.panelButtons) i !== t && i.classList.remove("selected");
				t.classList.add("selected");
				for (let i of this.panels) i !== e && i.Show(!1);
				e.Show(!0), e.Resize()
			}
			GetVisiblePanel() {
				if (!this.panelsVisible) return null;
				for (let e of this.panels)
					if (e.IsVisible()) return e;
				return null
			}
			SetPanelIcon(e, t) {
				let i = this.GetPanelButton(e);
				Je(i, t)
			}
			GetPanelButton(e) {
				let t = this.panels.indexOf(e);
				return this.panelButtons[t]
			}
			Resize() {
				let e = this.parentDiv.offsetHeight;
				if (ve(this.menuDiv, e), ve(this.contentDiv, e), this.panelsVisible)
					for (let t of this.panels) t.IsVisible() && t.Resize()
			}
			IsParentVisible() {
				return Ii(this.parentDiv)
			}
			Clear() {
				for (let e of this.panels) e.Clear()
			}
		};

	function zs(o) {
		o.scrollIntoView({
			behavior: "smooth",
			block: "nearest"
		})
	}
	var mt = class {
			constructor(e) {
				this.imagePath = e, this.mainElement = Zt(this.imagePath, "ov_tree_item_button"), this.mainElement.setAttribute("src", this.imagePath)
			}
			SetImage(e) {
				this.imagePath = e, Je(this.mainElement, this.imagePath)
			}
			OnClick(e) {
				this.mainElement.addEventListener("click", t => {
					t.stopPropagation(), e(t)
				})
			}
			GetDomElement() {
				return this.mainElement
			}
		},
		Jr = class {
			constructor(e, t) {
				if (this.name = e, this.parent = null, this.mainElement = Ie("ov_tree_item"), this.mainElement.setAttribute("title", this.name), this.nameElement = v(this.mainElement, "ov_tree_item_name", this.name), Wt(t)) {
					let i = Zt(t, "ov_tree_item_icon");
					Ct(i, this.nameElement)
				}
			}
			OnClick(e) {
				this.mainElement.classList.add("clickable"), this.mainElement.style.cursor = "pointer", this.mainElement.addEventListener("click", e)
			}
			SetParent(e) {
				this.parent = e
			}
			AddDomElements(e) {
				e.appendChild(this.mainElement)
			}
		},
		Et = class extends Jr {
			constructor(e, t) {
				super(e, t);
				this.selected = !1
			}
			SetSelected(e) {
				if (this.selected = e, this.selected) {
					this.mainElement.classList.add("selected");
					let t = this.parent;
					if (t === null) zs(this.mainElement);
					else
						for (; t !== null;) t.ShowChildren(!0), zs(this.mainElement), t = t.parent
				} else this.mainElement.classList.remove("selected")
			}
		},
		ui = class extends Et {
			constructor(e, t) {
				super(e, t);
				this.buttonsDiv = Ie("ov_tree_item_button_container"), Ct(this.buttonsDiv, this.nameElement)
			}
			AppendButton(e) {
				this.buttonsDiv.appendChild(e.GetDomElement())
			}
		},
		At = class extends Jr {
			constructor(e, t) {
				super(e, t);
				this.children = [], this.isVisible = !0, this.isChildrenVisible = !1, this.childrenDiv = null, this.openButtonIcon = "arrow_down", this.closeButtonIcon = "arrow_right", this.openCloseButton = Zt(this.openButtonIcon, "ov_tree_item_icon"), Ct(this.openCloseButton, this.nameElement)
			}
			AddChild(e) {
				this.CreateChildrenDiv(), this.children.push(e), e.SetParent(this), e.AddDomElements(this.childrenDiv)
			}
			ExpandAll(e) {
				for (let t of this.children) t instanceof At && (t.ShowChildren(e), t.ExpandAll(e))
			}
			Show(e) {
				this.isVisible = e, this.childrenDiv !== null && (this.isVisible ? (L(this.mainElement, !0), this.childrenDiv.classList.add("ov_tree_view_children")) : (L(this.mainElement, !1), this.childrenDiv.classList.remove("ov_tree_view_children")))
			}
			ShowChildren(e) {
				this.isChildrenVisible = e, this.childrenDiv !== null && (e ? (Je(this.openCloseButton, this.openButtonIcon), L(this.childrenDiv, !0)) : (Je(this.openCloseButton, this.closeButtonIcon), L(this.childrenDiv, !1)))
			}
			CreateChildrenDiv() {
				return this.childrenDiv === null && (this.childrenDiv = Ie("ov_tree_view_children"), Gn(this.childrenDiv, this.mainElement), this.Show(this.isVisible), this.ShowChildren(this.isChildrenVisible), this.OnClick(e => {
					this.isChildrenVisible = !this.isChildrenVisible, this.ShowChildren(this.isChildrenVisible)
				})), this.childrenDiv
			}
		},
		Zr = class extends At {
			constructor(e, t) {
				super(e, t);
				this.buttonsDiv = Ie("ov_tree_item_button_container"), Ct(this.buttonsDiv, this.nameElement)
			}
			AppendButton(e) {
				this.buttonsDiv.appendChild(e.GetDomElement())
			}
		},
		Qr = class {
			constructor(e) {
				this.mainDiv = v(e, "ov_tree_view"), this.children = []
			}
			AddClass(e) {
				this.mainDiv.classList.add(e)
			}
			AddChild(e) {
				e.AddDomElements(this.mainDiv), this.children.push(e)
			}
			Clear() {
				Ce(this.mainDiv), this.children = []
			}
		};
	var di = class {
			constructor(e) {
				this.parentDiv = e, this.callbacks = null, this.popup = null, this.button = v(this.parentDiv, "ov_panel_button"), this.buttonText = v(this.button, "ov_panel_button_text"), ne(this.button, "arrow_right", "ov_panel_button_icon"), this.button.addEventListener("click", () => {
					this.OnButtonClick()
				})
			}
			Init(e) {
				this.callbacks = e
			}
			OnButtonClick() {}
			Clear() {
				this.popup !== null && (this.popup.Close(), this.popup = null)
			}
		},
		Dt = class extends ai {
			constructor(e) {
				super(e);
				this.callbacks = null, this.titleDiv = v(this.panelDiv, "ov_navigator_tree_title"), this.treeDiv = v(this.panelDiv, "ov_navigator_tree_panel ov_thin_scrollbar"), this.treeView = new Qr(this.treeDiv);
				let t = this.GetName();
				this.titleDiv.innerHTML = t, this.titleDiv.setAttribute("title", t)
			}
			Clear() {
				this.treeView.Clear()
			}
			GetName() {
				return null
			}
			Init(e) {
				this.callbacks = e
			}
			Fill(e) {}
		};
	var $r = class extends Dt {
		constructor(e) {
			super(e)
		}
		GetName() {
			return "Files"
		}
		GetIcon() {
			return "files"
		}
		Resize() {
			let e = Ke(this.titleDiv),
				t = this.parentDiv.offsetHeight;
			ve(this.treeDiv, t - e)
		}
		Clear() {
			super.Clear()
		}
		Fill(e) {
			super.Fill(e);
			let t = e.usedFiles,
				i = e.missingFiles;
			if (i.length > 0) {
				let r = new At("Missing Files", null);
				r.ShowChildren(!0), this.treeView.AddChild(r);
				for (let s = 0; s < i.length; s++) {
					let l = i[s],
						a = new ui(l),
						h = new mt("open");
					h.OnClick(() => {
						this.callbacks.onFileBrowseButtonClicked()
					}), a.AppendButton(h), r.AddChild(a)
				}
				let n = new At("Available Files", null);
				n.ShowChildren(!0), this.treeView.AddChild(n);
				for (let s = 0; s < t.length; s++) {
					let l = t[s],
						a = new Et(l);
					n.AddChild(a)
				}
			} else
				for (let r = 0; r < t.length; r++) {
					let n = t[r],
						s = new Et(n);
					this.treeView.AddChild(s)
				}
		}
	};
	var Te = {
			No: 0,
			Parents: 1,
			Children: 2,
			All: 3
		},
		en = class extends Et {
			constructor(e, t, i) {
				super(e);
				this.OnClick(() => {
					i.onSelected(t)
				})
			}
		},
		Xt = class extends ui {
			constructor(e, t, i, r) {
				super(e, t);
				this.meshInstanceId = i, this.visible = !0, this.fitToWindowButton = new mt("fit"), this.fitToWindowButton.OnClick(() => {
					r.onFitToWindow(this.meshInstanceId)
				}), this.AppendButton(this.fitToWindowButton), this.showHideButton = new mt("visible"), this.showHideButton.OnClick(() => {
					r.onShowHide(this.meshInstanceId)
				}), this.AppendButton(this.showHideButton), this.OnClick(() => {
					r.onSelected(this.meshInstanceId)
				})
			}
			GetMeshInstanceId() {
				return this.meshInstanceId
			}
			IsVisible() {
				return this.visible
			}
			SetVisible(e, t) {
				if (this.visible !== e && (this.visible = e, this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"), t === Te.Parents && this.parent instanceof qe)) {
					let i = this.parent.CalculateIsVisible();
					this.parent.SetVisible(i, Te.Parents)
				}
			}
		},
		qe = class extends Zr {
			constructor(e, t, i) {
				super(e, null);
				this.nodeId = t, this.callbacks = i, this.visible = !0, this.fitToWindowButton = new mt("fit"), this.fitToWindowButton.OnClick(() => {
					this.callbacks.onFitToWindow(t)
				}), this.AppendButton(this.fitToWindowButton), this.showHideButton = new mt("visible"), this.showHideButton.OnClick(() => {
					this.callbacks.onShowHide(t)
				}), this.AppendButton(this.showHideButton)
			}
			GetNodeId() {
				return this.nodeId
			}
			IsVisible() {
				return this.visible
			}
			CalculateIsVisible() {
				let e = !1;
				for (let t of this.children)
					if ((t instanceof qe || t instanceof Xt) && t.IsVisible()) {
						e = !0;
						break
					} return e
			}
			SetVisible(e, t) {
				if (this.visible !== e) {
					if (this.visible = e, this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"), Wt(this.callbacks.onVisibilityChanged) && this.callbacks.onVisibilityChanged(this.visible), t === Te.Children || t === Te.All)
						for (let i of this.children)(i instanceof qe || i instanceof Xt) && i.SetVisible(this.visible, Te.Children);
					if ((t === Te.Parents || t === Te.All) && this.parent instanceof qe) {
						let i = this.parent.CalculateIsVisible();
						this.parent.SetVisible(i, Te.Parents)
					}
				}
			}
			EnumerateMeshItems(e) {
				for (let t of this.children) t instanceof qe ? t.EnumerateMeshItems(e) : t instanceof Xt && e(t)
			}
		};
	var Ws = class extends di {
			constructor(e) {
				super(e);
				this.meshInfoArray = null
			}
			Update(e) {
				if (this.meshInfoArray = e, this.meshInfoArray === null) return;
				let t = "Meshes (" + this.meshInfoArray.length + ")";
				this.buttonText.innerHTML = t
			}
			OnButtonClick() {
				if (this.meshInfoArray === null) return;
				let e = [];
				for (let t = 0; t < this.meshInfoArray.length; t++) {
					let i = this.meshInfoArray[t];
					e.push({
						name: Mi(i.name)
					})
				}
				e.length !== 0 && (this.popup = qt(e, {
					calculatePosition: t => qi(this.button, t),
					onHoverStart: t => {
						let i = this.meshInfoArray[t];
						this.callbacks.onMeshHover(i.meshId)
					},
					onHoverStop: t => {
						this.callbacks.onMeshHover(null)
					},
					onClick: t => {
						let i = this.meshInfoArray[t];
						this.callbacks.onMeshSelected(i.meshId)
					}
				}))
			}
		},
		tn = class extends Dt {
			constructor(e) {
				super(e);
				this.callbacks = null, this.materialIndexToItem = new Map, this.popupDiv = v(this.panelDiv, "ov_navigator_info_panel"), this.meshesButton = new Ws(this.popupDiv)
			}
			GetName() {
				return "Materials"
			}
			GetIcon() {
				return "materials"
			}
			Resize() {
				let e = Ke(this.titleDiv),
					t = Ke(this.popupDiv),
					i = this.parentDiv.offsetHeight;
				ve(this.treeDiv, i - e - t)
			}
			Clear() {
				super.Clear(), this.meshesButton.Clear(), this.materialIndexToItem = new Map
			}
			Init(e) {
				super.Init(e), this.meshesButton.Init({
					onMeshHover: t => {
						this.callbacks.onMeshTemporarySelected(t)
					},
					onMeshSelected: t => {
						this.callbacks.onMeshSelected(t)
					}
				})
			}
			Fill(e) {
				super.Fill(e);
				let t = e.model;
				for (let i = 0; i < t.MaterialCount(); i++) {
					let r = t.GetMaterial(i),
						n = yi(r.name),
						s = new en(n, i, {
							onSelected: l => {
								this.callbacks.onMaterialSelected(l)
							}
						});
					this.materialIndexToItem.set(i, s), this.treeView.AddChild(s)
				}
			}
			GetMaterialItem(e) {
				return this.materialIndexToItem.get(e)
			}
			SelectMaterialItem(e, t) {
				this.GetMaterialItem(e)
					.SetSelected(t)
			}
			UpdateMeshList(e) {
				this.meshesButton.Update(e)
			}
		};
	var pe = {
			Simple: 0,
			FlatList: 1,
			TreeView: 2
		},
		js = class extends di {
			constructor(e) {
				super(e);
				this.materialInfoArray = null
			}
			Update(e) {
				if (this.materialInfoArray = e, this.materialInfoArray === null) return;
				let t = "Materials (" + this.materialInfoArray.length + ")";
				this.buttonText.innerHTML = t
			}
			OnButtonClick() {
				if (this.materialInfoArray === null) return;
				let e = [];
				for (let t = 0; t < this.materialInfoArray.length; t++) {
					let i = this.materialInfoArray[t];
					e.push({
						name: yi(i.name),
						color: i.color
					})
				}
				e.length !== 0 && (this.popup = qt(e, {
					calculatePosition: t => qi(this.button, t),
					onClick: t => {
						let i = this.materialInfoArray[t];
						this.callbacks.onMaterialSelected(i.index)
					}
				}))
			}
		},
		rn = class extends Dt {
			constructor(e) {
				super(e);
				this.callbacks = null, this.nodeIdToItem = new Map, this.meshInstanceIdToItem = new Map, this.rootItem = null, this.mode = pe.Simple, this.buttons = null, this.treeView.AddClass("tight"), this.titleButtonsDiv = v(this.titleDiv, "ov_navigator_tree_title_buttons"), this.buttonsDiv = Ie("ov_navigator_buttons"), Ct(this.buttonsDiv, this.treeDiv), this.popupDiv = v(this.panelDiv, "ov_navigator_info_panel"), this.materialsButton = new js(this.popupDiv)
			}
			GetName() {
				return "Meshes"
			}
			GetIcon() {
				return "meshes"
			}
			Resize() {
				let e = Ke(this.titleDiv),
					t = 0;
				Ii(this.buttonsDiv) && (t = Ke(this.buttonsDiv));
				let i = Ke(this.popupDiv),
					r = this.parentDiv.offsetHeight;
				ve(this.treeDiv, r - e - t - i)
			}
			Clear() {
				this.ClearMeshTree(), Ce(this.titleButtonsDiv), Ce(this.buttonsDiv), this.buttons = null
			}
			ClearMeshTree() {
				super.Clear(), this.materialsButton.Clear(), this.nodeIdToItem = new Map, this.meshInstanceIdToItem = new Map, this.rootItem = null
			}
			Init(e) {
				super.Init(e), this.materialsButton.Init({
					onMeshHover: t => {
						this.callbacks.onMeshTemporarySelected(t)
					},
					onMeshSelected: t => {
						this.callbacks.onMeshSelected(t)
					},
					onMaterialSelected: t => {
						this.callbacks.onMaterialSelected(t)
					}
				})
			}
			Fill(e) {
				super.Fill(e);
				let t = e.model.GetRootNode(),
					i = !1;
				for (let r of t.GetChildNodes())
					if (r.GetType() === fe.GroupNode) {
						i = !0;
						break
					} this.mode === pe.Simple ? i && (this.mode = pe.FlatList) : (this.mode === pe.FlatList || this.mode === pe.TreeView) && (i || (this.mode = pe.Simple)), this.FillButtons(e), this.mode === pe.Simple ? (L(this.buttonsDiv, !1), this.titleDiv.classList.add("withbuttons"), this.titleDiv.classList.remove("nomargin")) : (L(this.buttonsDiv, !0), this.titleDiv.classList.remove("withbuttons"), this.titleDiv.classList.add("nomargin")), this.FillMeshTree(e.model), this.Resize()
			}
			FillButtons(e) {
				function t(n, s, l, a) {
					s.div = v(n, "ov_navigator_button"), s.div.setAttribute("alt", s.name), s.div.setAttribute("title", s.name), l && s.div.classList.add(l), s.iconDiv = ne(s.div, s.icon), s.div.addEventListener("click", () => {
						a()
					})
				}

				function i(n, s) {
					let l = s === pe.TreeView;
					l ? (n.flatList.iconDiv.classList.remove("selected"), n.treeView.iconDiv.classList.add("selected")) : (n.flatList.iconDiv.classList.add("selected"), n.treeView.iconDiv.classList.remove("selected")), L(n.separator, l), L(n.expandAll.div, l), L(n.collapseAll.div, l)
				}

				function r(n, s) {
					let l = [];
					n.EnumerateMeshItems(a => (a.IsVisible() || l.push(a.GetMeshInstanceId()), !0)), n.ClearMeshTree(), n.FillMeshTree(s.model);
					for (let a of l) n.GetMeshItem(a)
						.SetVisible(!1, Te.Parents);
					i(n.buttons, n.mode), n.callbacks.onViewTypeChanged()
				}
				this.buttons = {
					flatList: {
						name: "Flat list",
						icon: "flat_list",
						div: null,
						iconDiv: null
					},
					treeView: {
						name: "Tree view",
						icon: "tree_view",
						div: null,
						iconDiv: null
					},
					separator: null,
					expandAll: {
						name: "Expand all",
						icon: "expand",
						div: null,
						iconDiv: null
					},
					collapseAll: {
						name: "Collapse all",
						icon: "collapse",
						div: null,
						iconDiv: null
					},
					showHideMeshes: {
						name: "Show/hide meshes",
						icon: "visible",
						div: null,
						iconDiv: null
					},
					fitToWindow: {
						name: "Fit meshes to window",
						icon: "fit",
						div: null,
						iconDiv: null
					}
				}, this.mode === pe.Simple ? (t(this.titleButtonsDiv, this.buttons.showHideMeshes, "right", () => {
					let n = this.rootItem.GetNodeId();
					this.callbacks.onNodeShowHide(n)
				}), t(this.titleButtonsDiv, this.buttons.fitToWindow, "right", () => {
					let n = this.rootItem.GetNodeId();
					this.callbacks.onNodeFitToWindow(n)
				})) : (t(this.buttonsDiv, this.buttons.flatList, null, () => {
					this.mode !== pe.FlatList && (this.mode = pe.FlatList, r(this, e))
				}), t(this.buttonsDiv, this.buttons.treeView, null, () => {
					this.mode !== pe.TreeView && (this.mode = pe.TreeView, r(this, e))
				}), this.buttons.separator = v(this.buttonsDiv, "ov_navigator_buttons_separator"), t(this.buttonsDiv, this.buttons.expandAll, null, () => {
					this.rootItem.ExpandAll(!0)
				}), t(this.buttonsDiv, this.buttons.collapseAll, null, () => {
					this.rootItem.ExpandAll(!1)
				}), t(this.buttonsDiv, this.buttons.showHideMeshes, "right", () => {
					let n = this.rootItem.GetNodeId();
					this.callbacks.onNodeShowHide(n)
				}), t(this.buttonsDiv, this.buttons.fitToWindow, "right", () => {
					let n = this.rootItem.GetNodeId();
					this.callbacks.onNodeFitToWindow(n)
				}), i(this.buttons, this.mode))
			}
			FillMeshTree(e) {
				function t(l, a, h, u, d, m) {
					let f = a.GetMesh(u),
						p = Mi(f.GetName()),
						c = new ht(h.GetId(), u),
						g = m === pe.TreeView ? "tree_mesh" : null,
						x = new Xt(p, g, c, {
							onShowHide: C => {
								l.callbacks.onMeshShowHide(C)
							},
							onFitToWindow: C => {
								l.callbacks.onMeshFitToWindow(C)
							},
							onSelected: C => {
								l.callbacks.onMeshSelected(C)
							}
						});
					l.meshInstanceIdToItem.set(c.GetKey(), x), d.AddChild(x)
				}

				function i(l, a) {
					let h = Nn(a.GetName()),
						u = a.GetId(),
						d = new qe(h, u, {
							onShowHide: m => {
								l.callbacks.onNodeShowHide(m)
							},
							onFitToWindow: m => {
								l.callbacks.onNodeFitToWindow(m)
							}
						});
					return l.nodeIdToItem.set(u, d), d
				}

				function r(l, a) {
					let h = a.GetId(),
						u = new qe(null, h, {
							onVisibilityChanged: d => {
								d ? Je(l.buttons.showHideMeshes.iconDiv, "visible") : Je(l.buttons.showHideMeshes.iconDiv, "hidden")
							}
						});
					return u.Show(!1), u.ShowChildren(!0), l.treeView.AddChild(u), l.nodeIdToItem.set(h, u), u
				}

				function n(l, a, h, u, d) {
					let m = [];
					for (let f of h.GetChildNodes())
						if (d === pe.TreeView)
							if (f.GetType() === fe.GroupNode) {
								let p = i(l, f);
								u.AddChild(p), n(l, a, f, p, d)
							} else f.GetType() === fe.MeshNode && m.push(f);
					else n(l, a, f, u, d);
					for (let f of m) n(l, a, f, u, d);
					for (let f of h.GetMeshIndices()) t(l, a, h, f, u, d)
				}
				let s = e.GetRootNode();
				this.rootItem = r(this, s), n(this, e, s, this.rootItem, this.mode)
			}
			UpdateMaterialList(e) {
				this.materialsButton.Update(e)
			}
			GetNodeItem(e) {
				return this.nodeIdToItem.get(e)
			}
			MeshItemCount() {
				return this.meshInstanceIdToItem.size
			}
			GetMeshItem(e) {
				return this.meshInstanceIdToItem.get(e.GetKey())
			}
			EnumerateNodeItems(e) {
				for (let t of this.nodeIdToItem.values())
					if (!e(t)) break
			}
			EnumerateMeshItems(e) {
				for (let t of this.meshInstanceIdToItem.values())
					if (!e(t)) break
			}
			IsMeshVisible(e) {
				return this.GetMeshItem(e)
					.IsVisible()
			}
			HasHiddenMesh() {
				let e = !1;
				return this.EnumerateMeshItems(t => t.IsVisible() ? !0 : (e = !0, !1)), e
			}
			ShowAllMeshes(e) {
				this.EnumerateNodeItems(t => (t.SetVisible(e, Te.No), !0)), this.EnumerateMeshItems(t => (t.SetVisible(e, Te.No), !0))
			}
			ToggleNodeVisibility(e) {
				let t = this.GetNodeItem(e);
				t.SetVisible(!t.IsVisible(), Te.All)
			}
			ToggleMeshVisibility(e) {
				let t = this.GetMeshItem(e);
				t.SetVisible(!t.IsVisible(), Te.Parents)
			}
			IsMeshIsolated(e) {
				let t = !0;
				return this.EnumerateMeshItems(i => !i.GetMeshInstanceId()
					.IsEqual(e) && i.IsVisible() ? (t = !1, !1) : !0), t
			}
			IsolateMesh(e) {
				this.ShowAllMeshes(!1), this.ToggleMeshVisibility(e)
			}
		};
	var le = {
			Material: 1,
			Mesh: 2
		},
		Gt = class {
			constructor(e, t) {
				this.type = e, this.materialIndex = null, this.meshInstanceId = null, this.type === le.Material ? this.materialIndex = t : this.type === le.Mesh && (this.meshInstanceId = t)
			}
			IsEqual(e) {
				if (this.type !== e.type) return !1;
				if (this.type === le.Material) return this.materialIndex === e.materialIndex;
				if (this.type === le.Mesh) return this.meshInstanceId.IsEqual(e.meshInstanceId)
			}
		},
		nn = class {
			constructor(e, t) {
				this.mainDiv = e, this.splitterDiv = t, this.panelSet = new hi(e), this.callbacks = null, this.selection = null, this.tempSelectedMeshId = null, this.filesPanel = new $r(this.panelSet.GetContentDiv()), this.materialsPanel = new tn(this.panelSet.GetContentDiv()), this.meshesPanel = new rn(this.panelSet.GetContentDiv()), this.panelSet.AddPanel(this.filesPanel), this.panelSet.AddPanel(this.materialsPanel), this.panelSet.AddPanel(this.meshesPanel), this.panelSet.ShowPanel(this.meshesPanel)
			}
			ShowPanels(e) {
				this.panelSet.ShowPanels(e)
			}
			Init(e) {
				this.callbacks = e, this.panelSet.Init({
					onResize: () => {
						L(this.splitterDiv, this.panelSet.IsPanelsVisible()), this.callbacks.onResize()
					},
					onShowHidePanels: t => {
						this.callbacks.onShowHidePanels(t)
					}
				}), this.filesPanel.Init({
					onFileBrowseButtonClicked: () => {
						this.callbacks.openFileBrowserDialog()
					}
				}), this.materialsPanel.Init({
					onMaterialSelected: t => {
						this.SetSelection(new Gt(le.Material, t))
					},
					onMeshTemporarySelected: t => {
						this.tempSelectedMeshId = t, this.callbacks.updateMeshesSelection()
					},
					onMeshSelected: t => {
						this.SetSelection(new Gt(le.Mesh, t))
					}
				}), this.meshesPanel.Init({
					onMeshSelected: t => {
						this.SetSelection(new Gt(le.Mesh, t))
					},
					onMeshShowHide: t => {
						this.ToggleMeshVisibility(t)
					},
					onMeshFitToWindow: t => {
						this.FitMeshToWindow(t)
					},
					onNodeShowHide: t => {
						this.ToggleNodeVisibility(t)
					},
					onNodeFitToWindow: t => {
						this.FitNodeToWindow(t)
					},
					onMaterialSelected: t => {
						this.SetSelection(new Gt(le.Material, t))
					},
					onViewTypeChanged: () => {
						this.SetSelection(null)
					}
				}), wi(this.splitterDiv, this.mainDiv, !1, () => {
					this.callbacks.onResize()
				})
			}
			GetWidth() {
				let e = Ot(this.mainDiv),
					t = 0;
				return this.panelSet.IsPanelsVisible() && (t = this.splitterDiv.offsetWidth), e + t
			}
			Resize(e) {
				st(this.mainDiv, e), ve(this.splitterDiv, e), this.panelSet.Resize()
			}
			FillTree(e) {
				this.filesPanel.Fill(e), e.missingFiles.length === 0 ? this.panelSet.SetPanelIcon(this.filesPanel, "files") : this.panelSet.SetPanelIcon(this.filesPanel, "missing_files"), this.materialsPanel.Fill(e), this.meshesPanel.Fill(e), this.OnSelectionChanged()
			}
			MeshItemCount() {
				return this.meshesPanel.MeshItemCount()
			}
			IsMeshVisible(e) {
				return this.meshesPanel.IsMeshVisible(e)
			}
			HasHiddenMesh() {
				return this.meshesPanel.HasHiddenMesh()
			}
			ShowAllMeshes(e) {
				this.meshesPanel.ShowAllMeshes(e), this.callbacks.updateMeshesVisibility()
			}
			ToggleNodeVisibility(e) {
				this.meshesPanel.ToggleNodeVisibility(e), this.callbacks.updateMeshesVisibility()
			}
			ToggleMeshVisibility(e) {
				this.meshesPanel.ToggleMeshVisibility(e), this.callbacks.updateMeshesVisibility()
			}
			IsMeshIsolated(e) {
				return this.meshesPanel.IsMeshIsolated(e)
			}
			IsolateMesh(e) {
				this.meshesPanel.IsolateMesh(e), this.callbacks.updateMeshesVisibility()
			}
			GetSelectedMeshId() {
				return this.tempSelectedMeshId !== null ? this.tempSelectedMeshId : this.selection === null || this.selection.type !== le.Mesh ? null : this.selection.meshInstanceId
			}
			SetSelection(e) {
				function t(n, s, l) {
					s.type === le.Material ? (l && n.panelSet.IsPanelsVisible() && n.panelSet.ShowPanel(n.materialsPanel), n.materialsPanel.SelectMaterialItem(s.materialIndex, l)) : s.type === le.Mesh && (l && n.panelSet.IsPanelsVisible() && n.panelSet.ShowPanel(n.meshesPanel), n.meshesPanel.GetMeshItem(s.meshInstanceId)
						.SetSelected(l))
				}

				function i(n, s) {
					n.selection = s, n.OnSelectionChanged()
				}
				let r = this.selection;
				r !== null && t(this, r, !1), i(this, e), this.tempSelectedMeshId = null, this.selection !== null && (r !== null && r.IsEqual(this.selection) ? (t(this, this.selection, !1), i(this, null)) : t(this, this.selection, !0)), this.callbacks.updateMeshesSelection()
			}
			OnSelectionChanged() {
				this.selection === null ? this.callbacks.onModelSelected() : this.selection.type === le.Material ? this.callbacks.onMaterialSelected(this.selection.materialIndex) : this.selection.type === le.Mesh && this.callbacks.onMeshSelected(this.selection.meshInstanceId), this.UpdatePanels()
			}
			UpdatePanels() {
				let e = null,
					t = null;
				this.selection !== null && (this.selection.type === le.Material ? e = this.selection.materialIndex : this.selection.type === le.Mesh && (t = this.selection.meshInstanceId));
				let i = this.callbacks.getMeshesForMaterial(e);
				this.materialsPanel.UpdateMeshList(i);
				let r = this.callbacks.getMaterialsForMesh(t);
				this.meshesPanel.UpdateMaterialList(r)
			}
			FitNodeToWindow(e) {
				let t = new Set;
				this.meshesPanel.GetNodeItem(e)
					.EnumerateMeshItems(r => {
						t.add(r.GetMeshInstanceId())
					}), this.callbacks.fitMeshesToWindow(t)
			}
			FitMeshToWindow(e) {
				this.callbacks.fitMeshToWindow(e)
			}
			Clear() {
				this.panelSet.Clear(), this.selection = null
			}
		};

	function it(o, e) {
		let t = new Date,
			i = 365;
		t.setTime(t.getTime() + i * 24 * 60 * 60 * 1e3), document.cookie = o + "=" + e + "; expires=" + t.toUTCString() + ";"
	}

	function rt(o, e) {
		let i = decodeURIComponent(document.cookie)
			.split(";");
		for (let r = 0; r < i.length; r++) {
			let n = i[r].trim();
			if (n.startsWith(o + "=")) return n.substring(o.length + 1)
		}
		return e
	}

	function _t(o, e) {
		let t = rt(o, null);
		return t === null ? e : t === "true"
	}

	function Pt(o, e) {
		it(o, e ? "true" : "false")
	}

	function sn(o, e) {
		let t = rt(o, null);
		return t === null ? e : parseInt(t, 10)
	}

	function on(o, e) {
		it(o, e.toString())
	}

	function Xi(o, e) {
		let t = rt(o, null);
		return t === null ? e : de.StringToColor(t)
	}

	function Yi(o, e) {
		it(o, de.ColorToString(e))
	}
	var ge = {
			Light: 1,
			Dark: 2
		},
		mi = class {
			constructor() {
				this.environmentMapName = "fishermans_bastion", this.backgroundIsEnvMap = !1, this.backgroundColor = new D(255, 255, 255), this.defaultColor = new D(200, 200, 200), this.showEdges = !1, this.edgeColor = new D(0, 0, 0), this.edgeThreshold = 1, this.themeId = ge.Light
			}
			LoadFromCookies() {
				this.environmentMapName = rt("ov_environment_map", "fishermans_bastion"), this.backgroundIsEnvMap = _t("ov_background_is_envmap", !1), this.backgroundColor = Xi("ov_background_color", new D(255, 255, 255)), this.defaultColor = Xi("ov_default_color", new D(200, 200, 200)), this.showEdges = _t("ov_show_edges", !1), this.edgeColor = Xi("ov_edge_color", new D(0, 0, 0)), this.edgeThreshold = sn("ov_edge_threshold", 1), this.themeId = sn("ov_theme_id", ge.Light)
			}
			SaveToCookies() {
				it("ov_environment_map", this.environmentMapName), Pt("ov_background_is_envmap", this.backgroundIsEnvMap), Yi("ov_background_color", this.backgroundColor), Yi("ov_default_color", this.defaultColor), Pt("ov_show_edges", this.showEdges), Yi("ov_edge_color", this.edgeColor), on("ov_edge_threshold", this.edgeThreshold), on("ov_theme_id", this.themeId)
			}
		};

	function To(o, e, t) {
		let i = Le(o, e),
			r = Le(e, t),
			n = Le(o, t),
			s = (i + r + n) / 2,
			l = s * (s - i) * (s - r) * (s - n);
		return l < 0 ? 0 : Math.sqrt(l)
	}

	function Mo(o, e, t) {
		return mr(o, Ze(e, t)) / 6
	}

	function qs(o) {
		let e = 0;
		return o.EnumerateTriangleVertices((t, i, r) => {
			e += Mo(t, i, r)
		}), e
	}

	function Xs(o) {
		let e = 0;
		return o.EnumerateTriangleVertices((t, i, r) => {
			e += To(t, i, r)
		}), e
	}
	var fi = class extends ai {
		constructor(e) {
			super(e);
			this.callbacks = null, this.titleDiv = null, this.HasTitle() && (this.titleDiv = v(this.panelDiv, "ov_sidebar_title"), v(this.titleDiv, "ov_sidebar_title_text", this.GetName()), this.titleDiv.setAttribute("title", this.GetName())), this.contentDiv = v(this.panelDiv, "ov_sidebar_content ov_thin_scrollbar")
		}
		GetName() {
			return null
		}
		HasTitle() {
			return !0
		}
		Clear() {
			Ce(this.contentDiv)
		}
		Init(e) {
			this.callbacks = e
		}
	};
	var ln = class extends fi {
		constructor(e) {
			super(e)
		}
		GetName() {
			return "Details"
		}
		GetIcon() {
			return "details"
		}
		AddObject3DProperties(e) {
			this.Clear();
			let t = v(this.contentDiv, "ov_property_table"),
				i = Cr(e),
				r = oe(i.max, i.min);
			if (this.AddProperty(t, new B(P.Integer, "Vertices", e.VertexCount())), this.AddProperty(t, new B(P.Integer, "Triangles", e.TriangleCount())), this.AddProperty(t, new B(P.Number, "Size X", r.x)), this.AddProperty(t, new B(P.Number, "Size Y", r.y)), this.AddProperty(t, new B(P.Number, "Size Z", r.z)), this.AddCalculatedProperty(t, "Volume", () => {
				if (!ls(e)) return null;
				let n = qs(e);
				return new B(P.Number, null, n)
			}), this.AddCalculatedProperty(t, "Surface", () => {
				let n = Xs(e);
				return new B(P.Number, null, n)
			}), e.PropertyGroupCount() > 0) {
				let n = v(this.contentDiv, "ov_property_table ov_property_table_custom");
				for (let s = 0; s < e.PropertyGroupCount(); s++) {
					let l = e.GetPropertyGroup(s);
					this.AddPropertyGroup(n, l);
					for (let a = 0; a < l.PropertyCount(); a++) {
						let h = l.GetProperty(a);
						this.AddPropertyInGroup(n, h)
					}
				}
			}
			this.Resize()
		}
		AddMaterialProperties(e) {
			function t(n, s, l, a) {
				if (a === null || a.name === null) return;
				let h = $(a.name);
				n.AddProperty(s, new B(P.Text, l, h))
			}
			this.Clear();
			let i = v(this.contentDiv, "ov_property_table"),
				r = null;
			e.type === K.Phong ? r = "Phong" : e.type === K.Physical && (r = "Physical"), this.AddProperty(i, new B(P.Text, "Source", e.isDefault ? "Default" : "Model")), this.AddProperty(i, new B(P.Text, "Type", r)), e.vertexColors ? this.AddProperty(i, new B(P.Text, "Color", "Vertex colors")) : (this.AddProperty(i, new B(P.Color, "Color", e.color)), e.type === K.Phong && (this.AddProperty(i, new B(P.Color, "Ambient", e.ambient)), this.AddProperty(i, new B(P.Color, "Specular", e.specular)))), e.type === K.Physical && (this.AddProperty(i, new B(P.Percent, "Metalness", e.metalness)), this.AddProperty(i, new B(P.Percent, "Roughness", e.roughness))), this.AddProperty(i, new B(P.Percent, "Opacity", e.opacity)), t(this, i, "Diffuse Map", e.diffuseMap), t(this, i, "Bump Map", e.bumpMap), t(this, i, "Normal Map", e.normalMap), t(this, i, "Emissive Map", e.emissiveMap), e.type === K.Phong ? t(this, i, "Specular Map", e.specularMap) : e.type === K.Physical && t(this, i, "Metallic Map", e.metalnessMap), this.Resize()
		}
		AddPropertyGroup(e, t) {
			v(e, "ov_property_table_row group", t.name)
				.setAttribute("title", t.name)
		}
		AddProperty(e, t) {
			let i = v(e, "ov_property_table_row"),
				r = v(i, "ov_property_table_cell ov_property_table_name", t.name + ":"),
				n = v(i, "ov_property_table_cell ov_property_table_value");
			return r.setAttribute("title", t.name), this.DisplayPropertyValue(t, n), i
		}
		AddPropertyInGroup(e, t) {
			this.AddProperty(e, t)
				.classList.add("ingroup")
		}
		AddCalculatedProperty(e, t, i) {
			let r = v(e, "ov_property_table_row"),
				n = v(r, "ov_property_table_cell ov_property_table_name", t + ":"),
				s = v(r, "ov_property_table_cell ov_property_table_value");
			n.setAttribute("title", t), v(s, "ov_property_table_button", "Calculate...")
				.addEventListener("click", () => {
					Ce(s), s.innerHTML = "Please wait...", Mt(() => {
						let a = i();
						a === null ? s.innerHTML = "-" : this.DisplayPropertyValue(a, s)
					})
				})
		}
		DisplayPropertyValue(e, t) {
			Ce(t);
			let i = null;
			if (e.type === P.Text) i = e.value;
			else if (e.type === P.Integer) i = e.value.toLocaleString();
			else if (e.type === P.Number) i = e.value.toLocaleString(void 0, {
				minimumFractionDigits: 2,
				maximumFractionDigits: 2
			});
			else if (e.type === P.Boolean) i = e.value ? "True" : "False";
			else if (e.type === P.Percent) i = parseInt(e.value * 100, 10)
				.toString() + "%";
			else if (e.type === P.Color) {
				let r = "#" + ue(e.value),
					n = Si(e.value);
				t.appendChild(n), X(t, "span", null, r)
			}
			i !== null && (t.innerHTML = i, t.setAttribute("title", i))
		}
	};
	var Ys = {
		EnvironmentMap: !1
	};

	function an(o, e, t, i) {
		let r = Pickr.create({
			el: o,
			theme: "monolith",
			position: "left-start",
			swatches: t,
			comparison: !1,
			default: "#" + ue(e),
			components: {
				preview: !1,
				opacity: !1,
				hue: !0,
				interaction: {
					hex: !1,
					rgba: !1,
					hsla: !1,
					hsva: !1,
					cmyk: !1,
					input: !0,
					clear: !1,
					save: !1
				}
			}
		});
		return r.on("change", (n, s, l) => {
			let a = n.toRGBA(),
				h = new D(parseInt(a[0], 10), parseInt(a[1], 10), parseInt(a[2], 10));
			i(h)
		}), r
	}
	var Ks = class extends ji {
			constructor() {
				super()
			}
			ShowPopup(e, t, i) {
				let r = super.Init(() => Us(e, r)),
					n = [{
						element: null,
						name: "fishermans_bastion"
					}, {
						element: null,
						name: "citadella"
					}, {
						element: null,
						name: "maskonaive"
					}, {
						element: null,
						name: "teide"
					}, {
						element: null,
						name: "ice_river"
					}, {
						element: null,
						name: "park"
					}];
				for (let l of n) l.element = X(r, "img", "ov_environment_map_preview"), l.element.setAttribute("src", "assets/envmaps/" + l.name + ".jpg"), l.name === t.environmentMapName && l.element.classList.add("selected"), l.element.addEventListener("click", () => {
					for (let a of n) a.element.classList.remove("selected");
					l.element.classList.add("selected"), t.environmentMapName = l.name, i.onEnvironmentMapChange()
				});
				let s = Ei(r, "use_as_background", "Use as background", t.backgroundIsEnvMap, () => {
					t.backgroundIsEnvMap = s.checked, i.onEnvironmentMapChange()
				});
				r.classList.add("sidebar"), this.Open()
			}
		},
		Ki = class {
			constructor(e, t) {
				this.parentDiv = e, this.contentDiv = v(this.parentDiv, "ov_sidebar_settings_section"), v(this.contentDiv, "ov_sidebar_title", t)
			}
			Init(e, t) {}
			Update(e) {}
			Clear() {}
		},
		Js = class extends Ki {
			constructor(e) {
				super(e, "Model Display");
				this.environmentMapButton = null, this.environmentMapPopup = null, this.backgroundColorPicker = null, this.edgeDisplayToggle = null, this.edgeColorPicker = null, this.thresholdSlider = null, this.thresholdSliderValue = null, this.edgeSettingsDiv = null
			}
			Init(e, t) {
				Ys.EnvironmentMap && (this.environmentMapButton = v(this.contentDiv, "ov_panel_button"), ne(this.environmentMapButton, "arrow_left", "ov_panel_button_left_icon"), v(this.environmentMapButton, "ov_panel_button_text", "Environment Map"), this.environmentMapButton.addEventListener("click", () => {
					this.environmentMapPopup = new Ks, this.environmentMapPopup.ShowPopup(this.environmentMapButton, e, {
						onEnvironmentMapChange: () => {
							t.onEnvironmentMapChange()
						}
					})
				}));
				let i = v(this.contentDiv, "ov_sidebar_parameter"),
					r = v(i, "ov_color_picker");
				v(i, null, "Background Color");
				let n = ["#ffffff", "#e3e3e3", "#c9c9c9", "#898989", "#5f5f5f", "#494949", "#383838", "#0f0f0f"];
				this.backgroundColorPicker = an(r, e.backgroundColor, n, d => {
					e.backgroundColor = d, t.onBackgroundColorChange()
				});
				let s = v(this.contentDiv, "ov_sidebar_parameter");
				this.edgeDisplayToggle = dr(s, "ov_sidebar_parameter_toggle"), v(s, "ov_sidebar_parameter_text", "Show Edges"), this.edgeSettingsDiv = v(this.contentDiv, "ov_sidebar_settings_padded"), this.edgeDisplayToggle.OnChange(() => {
					L(this.edgeSettingsDiv, this.edgeDisplayToggle.GetStatus()), e.showEdges = this.edgeDisplayToggle.GetStatus(), t.onShowEdgesChange()
				});
				let l = v(this.edgeSettingsDiv, "ov_sidebar_settings_row"),
					a = ["#ffffff", "#e3e3e3", "#c9c9c9", "#898989", "#5f5f5f", "#494949", "#383838", "#0f0f0f"],
					h = v(l, "ov_color_picker");
				this.edgeColorPicker = an(h, e.edgeColor, a, d => {
					e.edgeColor = d, t.onEdgeColorChange()
				}), v(l, null, "Edge Color");
				let u = v(this.edgeSettingsDiv, "ov_sidebar_settings_row large");
				this.thresholdSlider = Hn(u, 0, 90), this.thresholdSlider.setAttribute("title", "Edge Angle Threshold"), this.thresholdSliderValue = X(u, "span", "ov_slider_label"), this.thresholdSlider.addEventListener("input", () => {
					this.thresholdSliderValue.innerHTML = this.thresholdSlider.value
				}), this.thresholdSlider.addEventListener("change", () => {
					e.edgeThreshold = this.thresholdSlider.value, t.onEdgeThresholdChange()
				}), this.thresholdSlider.value = e.edgeThreshold, this.thresholdSliderValue.innerHTML = e.edgeThreshold, this.edgeDisplayToggle.SetStatus(e.showEdges), L(this.edgeSettingsDiv, e.showEdges)
			}
			UpdateVisibility(e) {
				this.environmentMapButton !== null && L(this.environmentMapButton, e)
			}
			Update(e) {
				this.backgroundColorPicker !== null && this.backgroundColorPicker.setColor("#" + ue(e.backgroundColor)), this.edgeDisplayToggle !== null && (this.edgeDisplayToggle.SetStatus(e.showEdges), L(this.edgeSettingsDiv, e.showEdges), this.edgeColorPicker.setColor("#" + ue(e.edgeColor)), this.thresholdSlider.value = e.edgeThreshold, this.thresholdSliderValue.innerHTML = e.edgeThreshold)
			}
			Clear() {
				this.environmentMapPopup !== null && (this.environmentMapPopup.Close(), this.environmentMapPopup = null), this.backgroundColorPicker !== null && this.backgroundColorPicker.hide(), this.edgeColorPicker !== null && this.edgeColorPicker.hide()
			}
		},
		Zs = class extends Ki {
			constructor(e) {
				super(e, "Import Settings");
				this.defaultColorPicker = null
			}
			Init(e, t) {
				let i = v(this.contentDiv, "ov_sidebar_parameter"),
					r = v(i, "ov_color_picker");
				v(i, null, "Default Color");
				let n = ["#ffffff", "#e3e3e3", "#cc3333", "#fac832", "#4caf50", "#3393bd", "#9b27b0", "#fda4b8"];
				this.defaultColorPicker = an(r, e.defaultColor, n, s => {
					e.defaultColor = s, t.onDefaultColorChange()
				})
			}
			Update(e) {
				this.defaultColorPicker !== null && this.defaultColorPicker.setColor("#" + ue(e.defaultColor))
			}
			UpdateVisibility(e) {
				this.contentDiv !== null && L(this.contentDiv, e)
			}
			Clear() {
				this.defaultColorPicker !== null && this.defaultColorPicker.hide()
			}
		},
		Qs = class extends Ki {
			constructor(e) {
				super(e, "Appearance");
				this.darkModeToggle = null
			}
			Init(e, t) {
				let i = v(this.contentDiv, "ov_sidebar_parameter");
				this.darkModeToggle = dr(i, "ov_sidebar_parameter_toggle"), this.darkModeToggle.OnChange(() => {
					e.themeId = this.darkModeToggle.GetStatus() ? ge.Dark : ge.Light, t.onThemeChange()
				}), v(i, null, "Dark Mode");
				let r = e.themeId === ge.Dark;
				this.darkModeToggle.SetStatus(r)
			}
			Update(e) {
				if (this.darkModeToggle !== null) {
					let t = e.themeId === ge.Dark;
					this.darkModeToggle.SetStatus(t)
				}
			}
		},
		hn = class extends fi {
			constructor(e, t) {
				super(e);
				this.settings = t, this.sectionsDiv = v(this.contentDiv, "ov_sidebar_settings_sections ov_thin_scrollbar"), this.modelDisplaySection = new Js(this.sectionsDiv), this.importParametersSection = new Zs(this.sectionsDiv), this.appearanceSection = new Qs(this.sectionsDiv), this.resetToDefaultsButton = v(this.contentDiv, "ov_button ov_panel_button outline", "Reset to Default"), this.resetToDefaultsButton.addEventListener("click", () => {
					this.ResetToDefaults()
				})
			}
			GetName() {
				return "Settings"
			}
			HasTitle() {
				return !1
			}
			GetIcon() {
				return "settings"
			}
			Clear() {
				this.modelDisplaySection.Clear(), this.importParametersSection.Clear(), this.appearanceSection.Clear()
			}
			Init(e) {
				super.Init(e), this.modelDisplaySection.Init(this.settings, {
					onEnvironmentMapChange: () => {
						e.onEnvironmentMapChange()
					},
					onBackgroundColorChange: () => {
						e.onBackgroundColorChange()
					},
					onShowEdgesChange: () => {
						e.onEdgeDisplayChange()
					},
					onEdgeColorChange: () => {
						e.onEdgeDisplayChange()
					},
					onEdgeThresholdChange: () => {
						e.onEdgeDisplayChange()
					}
				}), this.importParametersSection.Init(this.settings, {
					onDefaultColorChange: () => {
						e.onDefaultColorChange()
					}
				}), this.appearanceSection.Init(this.settings, {
					onThemeChange: () => {
						this.settings.themeId === ge.Light ? (this.settings.backgroundColor = new D(255, 255, 255), this.settings.defaultColor = new D(200, 200, 200)) : this.settings.themeId === ge.Dark && (this.settings.backgroundColor = new D(42, 43, 46), this.settings.defaultColor = new D(200, 200, 200)), this.modelDisplaySection.Update(this.settings), this.importParametersSection.Update(this.settings), e.onThemeChange()
					}
				})
			}
			UpdateSettings(e, t) {
				this.modelDisplaySection.UpdateVisibility(e), this.importParametersSection.UpdateVisibility(t), this.Resize()
			}
			ResetToDefaults() {
				let e = new mi;
				this.settings.environmentMapName = e.environmentMapName, this.settings.backgroundIsEnvMap = e.backgroundIsEnvMap, this.settings.backgroundColor = e.backgroundColor, this.settings.defaultColor = e.defaultColor, this.settings.showEdges = e.showEdges, this.settings.edgeColor = e.edgeColor, this.settings.edgeThreshold = e.edgeThreshold, this.settings.themeId = e.themeId, this.modelDisplaySection.Update(this.settings), this.importParametersSection.Update(this.settings), this.appearanceSection.Update(this.settings), this.callbacks.onEnvironmentMapChange(), this.callbacks.onThemeChange()
			}
			Resize() {
				let e = this.resetToDefaultsButton.offsetHeight,
					t = this.parentDiv.offsetHeight;
				st(this.sectionsDiv, t - e)
			}
		};
	var un = class {
		constructor(e, t, i) {
			this.mainDiv = e, this.splitterDiv = t, this.panelSet = new hi(e), this.detailsPanel = new ln(this.panelSet.GetContentDiv()), this.settingsPanel = new hn(this.panelSet.GetContentDiv(), i), this.panelSet.AddPanel(this.detailsPanel), this.panelSet.AddPanel(this.settingsPanel), this.panelSet.ShowPanel(this.detailsPanel)
		}
		IsPanelsVisible() {
			return this.panelSet.IsPanelsVisible()
		}
		ShowPanels(e) {
			this.panelSet.ShowPanels(e)
		}
		Init(e) {
			this.callbacks = e, this.panelSet.Init({
				onResize: () => {
					L(this.splitterDiv, this.panelSet.IsPanelsVisible()), this.callbacks.onResize()
				},
				onShowHidePanels: t => {
					this.callbacks.onShowHidePanels(t)
				}
			}), this.settingsPanel.Init({
				onEnvironmentMapChange: () => {
					this.callbacks.onEnvironmentMapChange()
				},
				onBackgroundColorChange: () => {
					this.callbacks.onBackgroundColorChange()
				},
				onDefaultColorChange: () => {
					this.callbacks.onDefaultColorChange()
				},
				onEdgeDisplayChange: () => {
					this.callbacks.onEdgeDisplayChange()
				},
				onThemeChange: () => {
					this.callbacks.onThemeChange()
				}
			}), wi(this.splitterDiv, this.mainDiv, !0, () => {
				this.callbacks.onResize()
			})
		}
		UpdateSettings(e, t) {
			this.settingsPanel.UpdateSettings(e, t)
		}
		Resize(e) {
			st(this.mainDiv, e), ve(this.splitterDiv, e), this.panelSet.Resize()
		}
		GetWidth() {
			let e = Ot(this.mainDiv),
				t = 0;
			return this.panelSet.IsPanelsVisible() && (t = this.splitterDiv.offsetWidth), e + t
		}
		DecreaseWidth(e) {
			let t = this.mainDiv.offsetWidth;
			Bt(this.mainDiv, t - e)
		}
		Clear() {
			this.panelSet.Clear()
		}
		AddObject3DProperties(e) {
			this.detailsPanel.AddObject3DProperties(e)
		}
		AddMaterialProperties(e) {
			this.detailsPanel.AddMaterialProperties(e)
		}
	};
	var dn = class {
		constructor() {
			this.css = {
				"--ov_foreground_color": {},
				"--ov_background_color": {},
				"--ov_button_color": {},
				"--ov_button_hover_color": {},
				"--ov_button_text_color": {},
				"--ov_outline_button_color": {},
				"--ov_outline_button_hover_color": {},
				"--ov_outline_button_text_color": {},
				"--ov_icon_color": {},
				"--ov_light_icon_color": {},
				"--ov_selected_icon_color": {},
				"--ov_disabled_icon_color": {},
				"--ov_hover_color": {},
				"--ov_hover_text_color": {},
				"--ov_logo_text_color": {},
				"--ov_logo_border_color": {},
				"--ov_toolbar_background_color": {},
				"--ov_toolbar_selected_color": {},
				"--ov_toolbar_separator_color": {},
				"--ov_treeview_selected_color": {},
				"--ov_dialog_foreground_color": {},
				"--ov_dialog_background_color": {},
				"--ov_border_color": {},
				"--ov_shadow": {}
			};
			let e = document.querySelector(":root"),
				t = window.getComputedStyle(e);
			for (let i in this.css) Object.prototype.hasOwnProperty.call(this.css, i) && (this.css[i].light = t.getPropertyValue(i), this.css[i].dark = t.getPropertyValue(i + "_dark"))
		}
		SwitchTheme(e) {
			let t = null;
			if (e === ge.Light) t = "light";
			else if (e === ge.Dark) t = "dark";
			else return;
			let i = document.querySelector(":root");
			for (let r in this.css)
				if (Object.prototype.hasOwnProperty.call(this.css, r)) {
					let n = this.css[r][t];
					n !== void 0 && i.style.setProperty(r, n)
				}
		}
	};
	var mn = class {
			constructor(e, t, i) {
				this.image = e, this.imageTitle = t, this.selected = !1, this.buttonDiv = Ie("ov_toolbar_button"), this.buttonImg = ne(this.buttonDiv, this.image), i !== null && this.buttonDiv.addEventListener("click", i), this.buttonDiv.setAttribute("alt", this.imageTitle), bi(this.buttonDiv, this.imageTitle)
			}
			AddDomElements(e) {
				e.appendChild(this.buttonDiv)
			}
			AddClass(e) {
				this.buttonDiv.classList.add(e)
			}
			RemoveClass(e) {
				this.buttonDiv.classList.remove(e)
			}
			AddImageClass(e) {
				this.buttonImg.classList.add(e)
			}
			RemoveImageClass(e) {
				this.buttonImg.classList.remove(e)
			}
			IsSelected() {
				return this.selected
			}
			SetSelected(e) {
				this.selected = e, this.selected ? this.buttonDiv.classList.add("selected") : this.buttonDiv.classList.remove("selected")
			}
		},
		fn = class {
			constructor(e) {
				this.mainDiv = v(e, "ov_toolbar")
			}
			AddImageButton(e, t, i) {
				let r = new mn(e, t, i);
				return r.AddDomElements(this.mainDiv), r
			}
			AddImagePushButton(e, t, i, r) {
				let n = new mn(e, t, () => {
					n.SetSelected(!n.IsSelected()), r(n.IsSelected())
				});
				return n.AddDomElements(this.mainDiv), n.SetSelected(i), n
			}
			AddImageRadioButton(e, t, i) {
				let r = [];
				for (let n = 0; n < e.length; n++) {
					let s = e[n],
						l = this.AddImageButton(s.image, s.title, () => {
							for (let a = 0; a < r.length; a++) {
								let h = r[a];
								a === n ? h.SetSelected(!0) : h.SetSelected(!1)
							}
							i(n)
						});
					t === n && l.SetSelected(!0), r.push(l)
				}
				return r
			}
			AddSeparator() {
				return v(this.mainDiv, "ov_toolbar_separator")
			}
		};
	var $s = class {
			constructor() {
				this.indices = [], this.vertices = [], this.colors = [], this.normals = [], this.uvs = [], this.material = null
			}
			GetBounds() {
				let e = [1 / 0, 1 / 0, 1 / 0],
					t = [-1 / 0, -1 / 0, -1 / 0];
				for (let i = 0; i < this.vertices.length / 3; i++)
					for (let r = 0; r < 3; r++) e[r] = Math.min(e[r], this.vertices[i * 3 + r]), t[r] = Math.max(t[r], this.vertices[i * 3 + r]);
				return {
					min: e,
					max: t
				}
			}
			GetByteLength(e, t) {
				let i = this.indices.length,
					r = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;
				return i * e + r * t
			}
		},
		eo = class {
			constructor() {
				this.primitives = []
			}
			PrimitiveCount() {
				return this.primitives.length
			}
			GetPrimitive(e) {
				return this.primitives[e]
			}
			GetByteLength(e, t) {
				let i = 0;
				for (let r = 0; r < this.primitives.length; r++) i += this.primitives[r].GetByteLength(e, t);
				return i
			}
		};

	function Ji(o) {
		function e(l, a, h, u) {
			function d(c, g, x) {
				return g !== null ? c.GetVertexColor(g) : x ? new D(0, 0, 0) : null
			}

			function m(c, g, x) {
				return g !== null ? c.GetTextureUV(g) : x ? new O(0, 0) : null
			}

			function f(c, g, x) {
				let C = c.VertexColorCount() > 0,
					M = c.TextureUVCount() > 0,
					I = c.GetVertex(g.vertex),
					b = c.GetNormal(g.normal),
					w = x.vertices.length / 3;
				x.indices.push(w), x.vertices.push(I.x, I.y, I.z);
				let y = d(c, g.color, C);
				y !== null && x.colors.push(y.r / 255, y.g / 255, y.b / 255), x.normals.push(b.x, b.y, b.z);
				let E = m(c, g.uv, M);
				return E !== null && x.uvs.push(E.x, E.y), {
					index: w,
					color: y,
					normal: b,
					uv: E
				}
			}

			function p(c, g, x) {
				function C(b, w, y) {
					if (y === null && w === null) return !0;
					let E = d(b, w, !0);
					return vt(y, E)
				}

				function M(b, w, y) {
					let E = b.GetNormal(w);
					return Ve(y, E)
				}

				function I(b, w, y) {
					if (y === null && w === null) return !0;
					let E = m(b, w, !0);
					return gt(y, E)
				}
				for (let b = 0; b < g.length; b++) {
					let w = g[b],
						y = C(c, x.color, w.color),
						E = M(c, x.normal, w.normal),
						S = I(c, x.uv, w.uv);
					if (y && E && S) return w
				}
				return null
			}
			if (u.has(a.vertex)) {
				let c = u.get(a.vertex),
					g = p(l, c, a);
				if (g !== null) h.indices.push(g.index);
				else {
					let x = f(l, a, h);
					c.push(x)
				}
			} else {
				let c = f(l, a, h);
				u.set(a.vertex, [c])
			}
		}
		let t = new eo,
			i = o.TriangleCount();
		if (i === 0) return null;
		let r = [];
		for (let l = 0; l < i; l++) r.push(l);
		r.sort((l, a) => {
			let h = o.GetTriangle(l),
				u = o.GetTriangle(a);
			return h.mat - u.mat
		});
		let n = null,
			s = null;
		for (let l = 0; l < r.length; l++) {
			let a = r[l],
				h = o.GetTriangle(a);
			(n === null || n.material !== h.mat) && (n = new $s, n.material = h.mat, s = new Map, t.primitives.push(n));
			let u = {
					vertex: h.v0,
					color: h.c0,
					normal: h.n0,
					uv: h.u0
				},
				d = {
					vertex: h.v1,
					color: h.c1,
					normal: h.n1,
					uv: h.u1
				},
				m = {
					vertex: h.v2,
					color: h.c2,
					normal: h.n2,
					uv: h.u2
				};
			e(o, u, n, s), e(o, d, n, s), e(o, m, n, s)
		}
		return t
	}
	var ee = class {
			constructor(e) {
				this.name = e, this.content = null
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			GetTextContent() {
				return re(this.content)
			}
			GetBufferContent() {
				return this.content
			}
			SetTextContent(e) {
				let t = Ti(e);
				this.content = t
			}
			SetBufferContent(e) {
				this.content = e
			}
		},
		Ae = class {
			constructor() {}
			CanExport(e, t) {
				return !1
			}
			Export(e, t, i) {
				let r = [];
				this.ExportContent(e, t, r, () => {
					i(r)
				})
			}
			ExportContent(e, t, i, r) {}
			GetExportedMaterialName(e) {
				return this.GetExportedName(e, "Material")
			}
			GetExportedMeshName(e) {
				return this.GetExportedName(e, "Mesh")
			}
			GetExportedName(e, t) {
				return e.length === 0 ? t : e
			}
		};
	var cn = class extends Ae {
		constructor() {
			super();
			this.rhino = null
		}
		CanExport(e, t) {
			return e === R.Binary && t === "3dm"
		}
		ExportContent(e, t, i, r) {
			this.rhino === null ? xe("loaders/rhino3dm.min.js")
				.then(() => {
					rhino3dm()
						.then(n => {
							this.rhino = n, this.ExportRhinoContent(e, i, r)
						})
				})
				.catch(() => {
					r()
				}) : this.ExportRhinoContent(e, i, r)
		}
		ExportRhinoContent(e, t, i) {
			function r(h) {
				return {
					r: h.r,
					g: h.g,
					b: h.b,
					a: 255
				}
			}
			let n = new ee("model.3dm");
			t.push(n);
			let s = new this.rhino.File3dm;
			e.EnumerateTransformedMeshes(h => {
				let u = Ji(h);
				for (let d = 0; d < u.PrimitiveCount(); d++) {
					let m = u.GetPrimitive(d),
						f = {
							data: {
								attributes: {
									position: {
										itemSize: 3,
										type: "Float32Array",
										array: m.vertices
									},
									normal: {
										itemSize: 3,
										type: "Float32Array",
										array: m.normals
									}
								},
								index: {
									type: "Uint16Array",
									array: m.indices
								}
							}
						},
						p = e.GetMaterial(m.material),
						c = new this.rhino.Material;
					c.name = this.GetExportedMaterialName(p.name), p.type === K.Phong && (c.ambientColor = r(p.ambient), c.specularColor = r(p.specular)), c.diffuseColor = r(p.color), c.transparency = 1 - p.opacity;
					let g = s.materials()
						.count();
					s.materials()
						.add(c);
					let x = new this.rhino.Mesh.createFromThreejsJSON(f),
						C = new this.rhino.ObjectAttributes;
					C.name = this.GetExportedMeshName(h.GetName()), C.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject, C.materialIndex = g, s.objects()
						.add(x, C)
				}
			});
			let l = new this.rhino.File3dmWriteOptions;
			l.version = 6;
			let a = s.toByteArray(l);
			n.SetBufferContent(a), i()
		}
	};
	var ft = class {
		constructor(e, t) {
			this.arrayBuffer = new ArrayBuffer(e), this.dataView = new DataView(this.arrayBuffer), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		GetBuffer() {
			return this.arrayBuffer
		}
		WriteArrayBuffer(e) {
			let t = new Uint8Array(e);
			new Uint8Array(this.arrayBuffer)
				.set(t, this.position), this.position += e.byteLength
		}
		WriteBoolean8(e) {
			this.dataView.setInt8(this.position, e ? 1 : 0), this.position = this.position + 1
		}
		WriteCharacter8(e) {
			this.dataView.setInt8(this.position, e), this.position = this.position + 1
		}
		WriteUnsignedCharacter8(e) {
			this.dataView.setUint8(this.position, e), this.position = this.position + 1
		}
		WriteInteger16(e) {
			this.dataView.setInt16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteUnsignedInteger16(e) {
			this.dataView.setUint16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteInteger32(e) {
			this.dataView.setInt32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteUnsignedInteger32(e) {
			this.dataView.setUint32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteFloat32(e) {
			this.dataView.setFloat32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteDouble64(e) {
			this.dataView.setFloat64(this.position, e, this.isLittleEndian), this.position = this.position + 8
		}
	};
	var pn = class extends Ae {
		constructor() {
			super();
			this.components = {
				index: {
					type: 5125,
					size: 4
				},
				number: {
					type: 5126,
					size: 4
				}
			}
		}
		CanExport(e, t) {
			return e === R.Text && t === "gltf" || e === R.Binary && t === "glb"
		}
		ExportContent(e, t, i, r) {
			t === R.Text ? this.ExportAsciiContent(e, i) : t === R.Binary && this.ExportBinaryContent(e, i), r()
		}
		ExportAsciiContent(e, t) {
			let i = new ee("model.gltf"),
				r = new ee("model.bin");
			t.push(i), t.push(r);
			let n = this.GetMeshData(e),
				s = this.GetMainBuffer(n),
				l = this.GetMainJson(n);
			l.buffers.push({
				uri: r.GetName(),
				byteLength: s.byteLength
			});
			let a = new Map;
			this.ExportMaterials(e, l, h => {
				let u = $(h.name);
				if (a.has(u)) return a.get(u); {
					let d = new ee(u);
					d.SetBufferContent(h.buffer), t.push(d);
					let m = l.textures.length;
					return a.set(u, m), l.images.push({
						uri: u
					}), l.textures.push({
						source: m
					}), m
				}
			}), i.SetTextContent(JSON.stringify(l, null, 4)), r.SetBufferContent(s)
		}
		ExportBinaryContent(e, t) {
			function i(I) {
				let b = I % 4;
				return b === 0 ? I : I + (4 - b)
			}

			function r(I, b, w) {
				for (let y = 0; y < w; y++) I.WriteUnsignedCharacter8(b)
			}
			let n = new ee("model.glb");
			t.push(n);
			let s = this.GetMeshData(e),
				l = this.GetMainBuffer(s),
				a = this.GetMainJson(s),
				h = [],
				u = l.byteLength,
				d = new Map;
			this.ExportMaterials(e, a, I => {
				let b = $(I.name),
					w = Be(I.name);
				if (d.has(b)) return d.get(b); {
					let y = a.bufferViews.length,
						E = a.textures.length;
					d.set(b, E);
					let S = I.buffer;
					return h.push(S), a.bufferViews.push({
						buffer: 0,
						byteOffset: u,
						byteLength: S.byteLength
					}), u += S.byteLength, a.images.push({
						bufferView: y,
						mimeType: "image/" + w
					}), a.textures.push({
						source: E
					}), E
				}
			});
			let m = l.byteLength;
			for (let I = 0; I < h.length; I++) m += h[I].byteLength;
			let f = i(m);
			a.buffers.push({
				byteLength: f
			});
			let p = JSON.stringify(a),
				c = Ti(p),
				g = c.byteLength,
				x = i(g),
				C = 12 + 8 + x + 8 + f,
				M = new ft(C, !0);
			M.WriteUnsignedInteger32(1179937895), M.WriteUnsignedInteger32(2), M.WriteUnsignedInteger32(C), M.WriteUnsignedInteger32(x), M.WriteUnsignedInteger32(1313821514), M.WriteArrayBuffer(c), r(M, 32, x - g), M.WriteUnsignedInteger32(f), M.WriteUnsignedInteger32(5130562), M.WriteArrayBuffer(l);
			for (let I = 0; I < h.length; I++) {
				let b = h[I];
				M.WriteArrayBuffer(b)
			}
			r(M, 0, f - m), n.SetBufferContent(M.GetBuffer())
		}
		GetMeshData(e) {
			let t = [];
			return e.EnumerateTransformedMeshes(i => {
				let r = Ji(i);
				t.push({
					name: i.GetName(),
					buffer: r,
					offsets: [],
					sizes: []
				})
			}), t
		}
		GetMainBuffer(e) {
			let t = 0;
			for (let r = 0; r < e.length; r++) t += e[r].buffer.GetByteLength(this.components.index.size, this.components.number.size);
			let i = new ft(t, !0);
			for (let r = 0; r < e.length; r++) {
				let n = e[r];
				for (let s = 0; s < n.buffer.PrimitiveCount(); s++) {
					let l = n.buffer.GetPrimitive(s),
						a = i.GetPosition();
					for (let h = 0; h < l.indices.length; h++) i.WriteUnsignedInteger32(l.indices[h]);
					for (let h = 0; h < l.vertices.length; h++) i.WriteFloat32(l.vertices[h]);
					for (let h = 0; h < l.colors.length; h++) i.WriteFloat32(ot(l.colors[h]));
					for (let h = 0; h < l.normals.length; h++) i.WriteFloat32(l.normals[h]);
					for (let h = 0; h < l.uvs.length; h++) {
						let u = l.uvs[h];
						h % 2 === 1 && (u *= -1), i.WriteFloat32(u)
					}
					n.offsets.push(a), n.sizes.push(i.GetPosition() - a)
				}
			}
			return i.GetBuffer()
		}
		GetMainJson(e) {
			class t {
				constructor(n, s) {
					this.mainJson = n, this.byteOffset = s
				}
				AddBufferView(n) {
					return this.mainJson.bufferViews.push({
						buffer: 0,
						byteOffset: this.byteOffset,
						byteLength: n
					}), this.byteOffset += n, this.mainJson.bufferViews.length - 1
				}
			}
			let i = {
				asset: {
					generator: "https://qt.cxcp.net",
					version: "2.0"
				},
				scene: 0,
				scenes: [{
					nodes: []
				}],
				nodes: [],
				materials: [],
				meshes: [],
				buffers: [],
				bufferViews: [],
				accessors: []
			};
			for (let r = 0; r < e.length; r++) {
				let n = e[r];
				i.scenes[0].nodes.push(r), i.nodes.push({
					mesh: r
				});
				let s = {
						name: this.GetExportedMeshName(n.name),
						primitives: []
					},
					l = n.buffer.primitives;
				for (let a = 0; a < l.length; a++) {
					let h = l[a],
						u = new t(i, n.offsets[a]),
						d = u.AddBufferView(h.indices.length * this.components.index.size),
						m = u.AddBufferView(h.vertices.length * this.components.number.size),
						f = null;
					h.colors.length > 0 && (f = u.AddBufferView(h.colors.length * this.components.number.size));
					let p = u.AddBufferView(h.normals.length * this.components.number.size),
						c = null;
					h.uvs.length > 0 && (c = u.AddBufferView(h.uvs.length * this.components.number.size));
					let g = {
							attributes: {},
							mode: 4,
							material: h.material
						},
						x = h.GetBounds();
					i.accessors.push({
						bufferView: d,
						byteOffset: 0,
						componentType: this.components.index.type,
						count: h.indices.length,
						type: "SCALAR"
					}), g.indices = i.accessors.length - 1, i.accessors.push({
						bufferView: m,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: h.vertices.length / 3,
						min: x.min,
						max: x.max,
						type: "VEC3"
					}), g.attributes.POSITION = i.accessors.length - 1, f !== null && (i.accessors.push({
						bufferView: f,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: h.colors.length / 3,
						type: "VEC3"
					}), g.attributes.COLOR_0 = i.accessors.length - 1), i.accessors.push({
						bufferView: p,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: h.normals.length / 3,
						type: "VEC3"
					}), g.attributes.NORMAL = i.accessors.length - 1, c !== null && (i.accessors.push({
						bufferView: c,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: h.uvs.length / 2,
						type: "VEC2"
					}), g.attributes.TEXCOORD_0 = i.accessors.length - 1), s.primitives.push(g)
				}
				i.meshes.push(s)
			}
			return i
		}
		ExportMaterials(e, t, i) {
			function r(n, s, l, a) {
				function h(g, x) {
					return [ot(g.r / 255), ot(g.g / 255), ot(g.b / 255), x]
				}

				function u(g) {
					return [ot(g.r / 255), ot(g.g / 255), ot(g.b / 255)]
				}

				function d(g, x, C) {
					if (x === null || !x.IsValid()) return null;
					g.images === void 0 && (g.images = []), g.textures === void 0 && (g.textures = []);
					let I = {
						index: C(x)
					};
					if (x.HasTransformation()) {
						let b = "KHR_texture_transform";
						g.extensionsUsed === void 0 && (g.extensionsUsed = []), g.extensionsUsed.indexOf(b) === -1 && g.extensionsUsed.push(b), I.extensions = {
							KHR_texture_transform: {
								offset: [x.offset.x, -x.offset.y],
								scale: [x.scale.x, x.scale.y],
								rotation: -x.rotation
							}
						}
					}
					return I
				}
				let m = {
					name: n.GetExportedMaterialName(l.name),
					pbrMetallicRoughness: {
						baseColorFactor: h(l.color, l.opacity)
					},
					emissiveFactor: u(l.emissive),
					doubleSided: !0,
					alphaMode: "OPAQUE"
				};
				l.transparent && (m.alphaMode = "BLEND");
				let f = d(s, l.diffuseMap, a);
				if (f !== null && (l.multiplyDiffuseMap || (m.pbrMetallicRoughness.baseColorFactor = h(new D(255, 255, 255), l.opacity)), m.pbrMetallicRoughness.baseColorTexture = f), l.type === K.Physical) {
					let g = d(s, l.metalnessMap, a);
					g !== null ? m.pbrMetallicRoughness.metallicRoughnessTexture = g : (m.pbrMetallicRoughness.metallicFactor = l.metalness, m.pbrMetallicRoughness.roughnessFactor = l.roughness)
				}
				let p = d(s, l.normalMap, a);
				p !== null && (m.normalTexture = p);
				let c = d(s, l.emissiveMap, a);
				c !== null && (m.emissiveTexture = c), s.materials.push(m)
			}
			for (let n = 0; n < e.MaterialCount(); n++) {
				let s = e.GetMaterial(n);
				r(this, t, s, i)
			}
		}
	};
	var Zi = class {
			constructor(e) {
				this.transformation = new q, this.isMeshVisible = t => !0, ki(e, this)
			}
		},
		ci = class {
			constructor(e, t) {
				this.model = e, this.settings = t || new Zi
			}
			MaterialCount() {
				return this.model.MaterialCount()
			}
			GetMaterial(e) {
				return this.model.GetMaterial(e)
			}
			VertexCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.VertexCount()
				}), e
			}
			TriangleCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.TriangleCount()
				}), e
			}
			MeshInstanceCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += 1
				}), e
			}
			EnumerateMeshInstances(e) {
				this.model.EnumerateMeshInstances(t => {
					this.settings.isMeshVisible(t.GetId()) && e(t)
				})
			}
			EnumerateTransformedMeshes(e) {
				this.EnumerateMeshInstances(t => {
					let i = t.GetTransformation();
					this.settings.transformation.IsIdentity() || i.Append(this.settings.transformation);
					let n = t.GetMesh()
						.Clone();
					i.IsIdentity() || at(n, i), e(n)
				})
			}
			EnumerateVerticesAndTriangles(e) {
				let t = [];
				this.EnumerateTransformedMeshes(r => {
					t.push(r)
				});
				for (let r of t) r.EnumerateVertices(n => {
					e.onVertex(n.x, n.y, n.z)
				});
				let i = 0;
				for (let r of t) r.EnumerateTriangleVertexIndices((n, s, l) => {
					e.onTriangle(n + i, s + i, l + i)
				}), i += r.VertexCount()
			}
			EnumerateTrianglesWithNormals(e) {
				this.EnumerateTransformedMeshes(t => {
					t.EnumerateTriangleVertices((i, r, n) => {
						let s = Qt(i, r, n);
						e(i, r, n, s)
					})
				})
			}
		};
	var Ue = class {
		constructor() {
			this.text = "", this.indentation = 0
		}
		GetText() {
			return this.text
		}
		Indent(e) {
			this.indentation += e
		}
		WriteArrayLine(e) {
			this.WriteLine(e.join(" "))
		}
		WriteLine(e) {
			this.WriteIndentation(), this.Write(e + `
`)
		}
		WriteIndentation() {
			for (let e = 0; e < this.indentation; e++) this.Write("  ")
		}
		Write(e) {
			this.text += e
		}
	};
	var gn = class extends Ae {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === R.Text && t === "obj"
		}
		ExportContent(e, t, i, r) {
			function n(p, c, g, x) {
				if (g === null || !g.IsValid()) return;
				let C = $(g.name);
				if (p.WriteArrayLine([c, C]), x.findIndex(I => I.GetName() === C) === -1) {
					let I = new ee(C);
					I.SetBufferContent(g.buffer), x.push(I)
				}
			}
			let s = new ee("model.mtl"),
				l = new ee("model.obj");
			i.push(s), i.push(l);
			let a = new Ue;
			a.WriteLine(this.GetHeaderText());
			for (let p = 0; p < e.MaterialCount(); p++) {
				let c = e.GetMaterial(p);
				a.WriteArrayLine(["newmtl", this.GetExportedMaterialName(c.name)]), a.WriteArrayLine(["Kd", c.color.r / 255, c.color.g / 255, c.color.b / 255]), a.WriteArrayLine(["d", c.opacity]), c.type === K.Phong && (a.WriteArrayLine(["Ka", c.ambient.r / 255, c.ambient.g / 255, c.ambient.b / 255]), a.WriteArrayLine(["Ks", c.specular.r / 255, c.specular.g / 255, c.specular.b / 255]), a.WriteArrayLine(["Ns", c.shininess * 1e3])), n(a, "map_Kd", c.diffuseMap, i), c.type === K.Phong && n(a, "map_Ks", c.specularMap, i), n(a, "bump", c.bumpMap, i)
			}
			s.SetTextContent(a.GetText());
			let h = new Ue;
			h.WriteLine(this.GetHeaderText()), h.WriteArrayLine(["mtllib", s.GetName()]);
			let u = 0,
				d = 0,
				m = 0,
				f = null;
			e.EnumerateTransformedMeshes(p => {
				h.WriteArrayLine(["g", this.GetExportedMeshName(p.GetName())]);
				for (let c = 0; c < p.VertexCount(); c++) {
					let g = p.GetVertex(c);
					h.WriteArrayLine(["v", g.x, g.y, g.z])
				}
				for (let c = 0; c < p.NormalCount(); c++) {
					let g = p.GetNormal(c);
					h.WriteArrayLine(["vn", g.x, g.y, g.z])
				}
				for (let c = 0; c < p.TextureUVCount(); c++) {
					let g = p.GetTextureUV(c);
					h.WriteArrayLine(["vt", g.x, g.y])
				}
				for (let c = 0; c < p.TriangleCount(); c++) {
					let g = p.GetTriangle(c),
						x = g.v0 + u + 1,
						C = g.v1 + u + 1,
						M = g.v2 + u + 1,
						I = g.n0 + d + 1,
						b = g.n1 + d + 1,
						w = g.n2 + d + 1;
					if (g.mat !== null) {
						let A = e.GetMaterial(g.mat),
							k = this.GetExportedMaterialName(A.name);
						k !== f && (h.WriteArrayLine(["usemtl", k]), f = k)
					}
					let y = "",
						E = "",
						S = "";
					g.HasTextureUVs() && (y = g.u0 + m + 1, E = g.u1 + m + 1, S = g.u2 + m + 1), h.WriteArrayLine(["f", [x, y, I].join("/"), [C, E, b].join("/"), [M, S, w].join("/")])
				}
				u += p.VertexCount(), d += p.NormalCount(), m += p.TextureUVCount()
			}), l.SetTextContent(h.GetText()), r()
		}
		GetHeaderText() {
			return "# exported by https://qt.cxcp.net"
		}
	};
	var xn = class extends Ae {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === R.Text && t === "off"
		}
		ExportContent(e, t, i, r) {
			let n = new ee("model.off");
			i.push(n);
			let s = new Ue;
			s.WriteLine("OFF"), s.WriteArrayLine([e.VertexCount(), e.TriangleCount(), 0]), e.EnumerateVerticesAndTriangles({
				onVertex: function(l, a, h) {
					s.WriteArrayLine([l, a, h])
				},
				onTriangle: function(l, a, h) {
					s.WriteArrayLine([3, l, a, h])
				}
			}), n.SetTextContent(s.GetText()), r()
		}
	};
	var Cn = class extends Ae {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === R.Text || e === R.Binary) && t === "ply"
		}
		ExportContent(e, t, i, r) {
			t === R.Text ? this.ExportText(e, i) : this.ExportBinary(e, i), r()
		}
		ExportText(e, t) {
			let i = new ee("model.ply");
			t.push(i);
			let r = new Ue,
				n = e.VertexCount(),
				s = e.TriangleCount(),
				l = this.GetHeaderText("ascii", n, s);
			r.Write(l), e.EnumerateVerticesAndTriangles({
				onVertex: function(a, h, u) {
					r.WriteArrayLine([a, h, u])
				},
				onTriangle: function(a, h, u) {
					r.WriteArrayLine([3, a, h, u])
				}
			}), i.SetTextContent(r.GetText())
		}
		ExportBinary(e, t) {
			let i = new ee("model.ply");
			t.push(i);
			let r = e.VertexCount(),
				n = e.TriangleCount(),
				s = this.GetHeaderText("binary_little_endian", r, n),
				l = s.length + r * 3 * 4 + n * (1 + 3 * 4),
				a = new ft(l, !0);
			for (let h = 0; h < s.length; h++) a.WriteUnsignedCharacter8(s.charCodeAt(h));
			e.EnumerateVerticesAndTriangles({
				onVertex: function(h, u, d) {
					a.WriteFloat32(h), a.WriteFloat32(u), a.WriteFloat32(d)
				},
				onTriangle: function(h, u, d) {
					a.WriteUnsignedCharacter8(3), a.WriteInteger32(h), a.WriteInteger32(u), a.WriteInteger32(d)
				}
			}), i.SetBufferContent(a.GetBuffer())
		}
		GetHeaderText(e, t, i) {
			let r = new Ue;
			return r.WriteLine("ply"), r.WriteLine("format " + e + " 1.0"), r.WriteLine("element vertex " + t), r.WriteLine("property float x"), r.WriteLine("property float y"), r.WriteLine("property float z"), r.WriteLine("element face " + i), r.WriteLine("property list uchar int vertex_index"), r.WriteLine("end_header"), r.GetText()
		}
	};
	var vn = class extends Ae {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === R.Text || e === R.Binary) && t === "stl"
		}
		ExportContent(e, t, i, r) {
			t === R.Text ? this.ExportText(e, i) : this.ExportBinary(e, i), r()
		}
		ExportText(e, t) {
			let i = new ee("model.stl");
			t.push(i);
			let r = new Ue;
			r.WriteLine("solid Model"), e.EnumerateTrianglesWithNormals((n, s, l, a) => {
				r.WriteArrayLine(["facet", "normal", a.x, a.y, a.z]), r.Indent(1), r.WriteLine("outer loop"), r.Indent(1), r.WriteArrayLine(["vertex", n.x, n.y, n.z]), r.WriteArrayLine(["vertex", s.x, s.y, s.z]), r.WriteArrayLine(["vertex", l.x, l.y, l.z]), r.Indent(-1), r.WriteLine("endloop"), r.Indent(-1), r.WriteLine("endfacet")
			}), r.WriteLine("endsolid Model"), i.SetTextContent(r.GetText())
		}
		ExportBinary(e, t) {
			let i = new ee("model.stl");
			t.push(i);
			let r = e.TriangleCount(),
				n = 80,
				s = n + 4 + r * 50,
				l = new ft(s, !0);
			for (let a = 0; a < n; a++) l.WriteUnsignedCharacter8(0);
			l.WriteUnsignedInteger32(r), e.EnumerateTrianglesWithNormals((a, h, u, d) => {
				l.WriteFloat32(d.x), l.WriteFloat32(d.y), l.WriteFloat32(d.z), l.WriteFloat32(a.x), l.WriteFloat32(a.y), l.WriteFloat32(a.z), l.WriteFloat32(h.x), l.WriteFloat32(h.y), l.WriteFloat32(h.z), l.WriteFloat32(u.x), l.WriteFloat32(u.y), l.WriteFloat32(u.z), l.WriteUnsignedInteger16(0)
			}), i.SetBufferContent(l.GetBuffer())
		}
	};
	var In = class {
		constructor() {
			this.exporters = [new gn, new vn, new Cn, new xn, new pn, new cn]
		}
		AddExporter(e) {
			this.exporters.push(e)
		}
		Export(e, t, i, r, n) {
			let s = null;
			for (let a = 0; a < this.exporters.length; a++) {
				let h = this.exporters[a];
				if (h.CanExport(i, r)) {
					s = h;
					break
				}
			}
			if (s === null) {
				n.onError();
				return
			}
			let l = new ci(e, t);
			s.Export(l, i, a => {
				a.length === 0 ? n.onError() : n.onSuccess(a)
			})
		}
	};
	var Xe = class {
			constructor(e, t, i) {
				this.name = e, this.format = t, this.extension = i, this.visibleOnlySelect = null, this.rotationSelect = null
			}
			GetName() {
				return this.name
			}
			GenerateParametersUI(e) {
				function t(i, r, n, s) {
					let l = v(i, "ov_dialog_row");
					v(l, "ov_dialog_row_name", r);
					let a = v(l, "ov_dialog_row_value");
					return ur(a, n, s)
				}
				this.visibleOnlySelect = t(e, "Scope", ["Entire Model", "Visible Only"], 1), this.rotationSelect = t(e, "Rotation", ["No Rotation", "-90 Degrees", "90 Degrees"], 0)
			}
			ExportModel(e, t) {
				let i = new Zi;
				if (this.visibleOnlySelect.selectedIndex === 1 && (i.isMeshVisible = s => t.isMeshVisible(s)), this.rotationSelect.selectedIndex === 1) {
					let s = new U()
						.CreateRotationAxisAngle(new T(1, 0, 0), -Math.PI / 2);
					i.transformation.SetMatrix(s)
				} else if (this.rotationSelect.selectedIndex === 2) {
					let s = new U()
						.CreateRotationAxisAngle(new T(1, 0, 0), Math.PI / 2);
					i.transformation.SetMatrix(s)
				}
				if (new ci(e, i)
					.MeshInstanceCount() === 0) {
					tt("Export Failed", "The model doesn't contain any meshes.", null);
					return
				}
				let n = new oi;
				n.Init("Exporting Model"), n.Open(), Mt(() => {
					new In()
						.Export(e, i, this.format, this.extension, {
							onError: () => {
								n.Close()
							},
							onSuccess: l => {
								if (l.length === 0) n.Close();
								else if (l.length === 1) {
									n.Close();
									let a = l[0];
									hr(a.GetBufferContent(), a.GetName())
								} else l.length > 1 && xe("loaders/fflate.min.js")
									.then(() => {
										let a = {};
										for (let d of l) a[d.name] = new Uint8Array(d.content);
										let u = fflate.zipSync(a)
											.buffer;
										n.Close(), hr(u, "model.zip")
									})
									.catch(() => {
										n.Close()
									})
							}
						})
				})
			}
		},
		to = class {
			constructor(e) {
				this.callbacks = e, this.selectedExporter = null, this.parametersDiv = null, this.exporters = [new Xe("Wavefront (.obj)", R.Text, "obj"), new Xe("Stereolithography Text (.stl)", R.Text, "stl"), new Xe("Stereolithography Binary (.stl)", R.Binary, "stl"), new Xe("Polygon File Format Text (.ply)", R.Text, "ply"), new Xe("Polygon File Format Binary (.ply)", R.Binary, "ply"), new Xe("glTF Text (.gltf)", R.Text, "gltf"), new Xe("glTF Binary (.glb)", R.Binary, "glb"), new Xe("Object File Format Text (.off)", R.Text, "off"), new Xe("Rhinoceros 3D (.3dm)", R.Binary, "3dm")]
			}
			Open(e, t) {
				let i = new Ee,
					r = i.Init("Export", [{
						name: "Close",
						subClass: "outline",
						onClick() {
							i.Close()
						}
					}, {
						name: "Export",
						onClick: () => {
							i.Close(), this.ExportFormat(e, t)
						}
					}]);
				v(r, "ov_dialog_section", "Select the format from the list below, and adjust the settings of the selected format.");
				let s = v(r, "ov_dialog_row");
				this.parametersDiv = v(r);
				let l = this.exporters.map(u => u.GetName()),
					a = rt("ov_last_export_format", "glTF Binary (.glb)"),
					h = l.indexOf(a);
				h === -1 && (h = 6), ur(s, l, h, u => {
					it("ov_last_export_format", l[u]), this.OnFormatSelected(u)
				}), this.OnFormatSelected(h), i.Open()
			}
			OnFormatSelected(e) {
				Ce(this.parametersDiv), this.selectedExporter = this.exporters[e], this.selectedExporter.GenerateParametersUI(this.parametersDiv)
			}
			ExportFormat(e, t) {
				this.selectedExporter.ExportModel(e, {
					isMeshVisible: i => this.callbacks.isMeshVisible(i)
				}), te("model_exported", this.selectedExporter.GetName())
			}
		};

	function io(o, e, t) {
		new to(t)
			.Open(o, e)
	}

	function ro(o) {
		function e(d, m, f, p, c) {
			let g = v(d, "ov_dialog_row");
			Un(g, m, "snapshot_size", f, p, c)
		}

		function t(d, m) {
			if (m.size === null) {
				let f = d.GetImageSize();
				return d.GetImageAsDataUrl(f.width, f.height)
			} else return d.GetImageAsDataUrl(m.size[0], m.size[1])
		}

		function i(d, m, f) {
			let p = t(d, f);
			m.src = p
		}
		let r = 0,
			n = [{
				name: "Current size",
				size: null
			}, {
				name: "1280 x 720",
				size: [1280, 720]
			}, {
				name: "1920 x 1080",
				size: [1920, 1080]
			}],
			s = new Ee,
			l = s.Init("Create Snapshot", [{
				name: "Cancel",
				subClass: "outline",
				onClick() {
					s.Close()
				}
			}, {
				name: "Create",
				onClick() {
					s.Close(), te("snapshot_created", n[r].name);
					let d = t(o, n[r]);
					ar(d, "model.png")
				}
			}]),
			a = v(l, "ov_snapshot_dialog_left"),
			h = nt("img", "ov_snapshot_dialog_preview"),
			u = rt("ov_last_snapshot_size", n[1].name);
		for (let d = 0; d < n.length; d++)
			if (u === n[d].name) {
				r = d;
				break
			} for (let d = 0; d < n.length; d++) {
			let m = n[d],
				f = d === r;
			e(a, "snapshot_" + d.toString(), m.name, f, () => {
				r = d, it("ov_last_snapshot_size", m.name), i(o, h, m)
			})
		}
		return l.appendChild(h), i(o, h, n[r]), s.Open(), s
	}

	function no(o) {
		let e = new Ee,
			t = nt("textarea", "ov_dialog_textarea"),
			i = e.Init("URL", [{
				name: "Cancel",
				subClass: "outline",
				onClick() {
					e.Close()
				}
			}, {
				name: "OK",
				onClick() {
					let n = [];
					Pe(t.value, s => {
						n.push(s)
					}), e.Close(), o(n)
				}
			}]);
		return v(i, "ov_dialog_section", "URL"), i.appendChild(t), e.Open(), t.focus(), e
	}

	function so(o, e, t) {
		function i(d, m, f, p) {
			let c = v(d, "ov_dialog_row"),
				g = Ei(c, f, m, !0, () => {
					p(g.checked)
				})
		}

		function r(d, m) {
			let f = "Copy",
				p = "Copied",
				c = v(d, "ov_dialog_copyable_input"),
				g = X(c, "input", "ov_dialog_text");
			g.readOnly = !0;
			let x = v(c, "ov_button outline ov_dialog_copyable_input_button", f);
			return x.addEventListener("click", () => {
				Bn(m()), x.innerHTML = p, setTimeout(() => {
					x.innerHTML = f
				}, 2e3)
			}), g
		}

		function n(d, m) {
			function f(g) {
				let x = Gi();
				x.AddModelUrls(g);
				let C = x.GetParameterList();
				return "https://qt.cxcp.net/onlinePrevieww?url=" + C
			}
			let p = v(d, "ov_dialog_section");
			v(p, "ov_dialog_inner_title", "Sharing Link");
			let c = r(p, () => (te("model_shared", "sharing_link"), f(m)));
			c.value = f(m)
		}

		function s(d, m, f, p) {
			function c(I, b, w, y) {
				let E = Gi();
				if (E.AddModelUrls(I), b) {
					E.AddCamera(y);
					let k = {
						environmentMapName: w.environmentMapName,
						backgroundIsEnvMap: w.backgroundIsEnvMap
					};
					E.AddEnvironmentSettings(k), E.AddBackgroundColor(w.backgroundColor), E.AddDefaultColor(w.defaultColor);
					let F = {
						showEdges: w.showEdges,
						edgeColor: w.edgeColor,
						edgeThreshold: w.edgeThreshold
					};
					E.AddEdgeSettings(F)
				}
				let S = E.GetParameterList(),
					A = "";
				return A += "<iframe", A += ' width="640" height="480"', A += ' style="border:1px solid #eeeeee;"', A += ' src="' + S + '">', A += "</iframe>", A
			}
			let g = !0,
				x = v(d, "ov_dialog_section");
			x.style.marginTop = "20px", v(x, "ov_dialog_inner_title", "Embedding Code");
			let C = v(x, "ov_dialog_section"),
				M = r(x, () => (te("model_shared", "embedding_code"), c(m, g, f, p)));
			i(C, "Use customized settings", "embed_current_settings", I => {
				g = I, M.value = c(m, g, f, p)
			}), M.value = c(m, g, f, p)
		}
		if (!o.IsOnlyUrlSource()) return tt("Sharing Failed", "Sharing works only if you load files by url. Please upload your model files to a web server, open them by url, and try embedding again.", null);
		let l = o.GetFiles(),
			a = [];
		for (let d = 0; d < l.length; d++) {
			let m = l[d];
			m.source === Z.Url && a.push(m.fileUrl)
		}
		let h = new Ee,
			u = h.Init("Share", [{
				name: "Close",
				onClick() {
					h.Close()
				}
			}]);
		return n(u, a), s(u, a, e, t), h.Open(), h
	}

	function Tn(o) {
		let e = new THREE.Matrix4;
		o.object.updateWorldMatrix(!0, !1), e.extractRotation(o.object.matrixWorld);
		let t = o.face.normal.clone();
		return t.applyMatrix4(e), t
	}

	function lo() {
		return new THREE.LineBasicMaterial({
			color: 2503224,
			depthTest: !1
		})
	}

	function Qi(o, e) {
		let t = new THREE.BufferGeometry()
			.setFromPoints(o);
		return new THREE.Line(t, e)
	}
	var ao = class {
		constructor(e, t) {
			this.intersection = null, this.markerObject = new THREE.Object3D;
			let i = lo(),
				r = new THREE.EllipseCurve(0, 0, t, t, 0, 2 * Math.PI, !1, 0);
			this.markerObject.add(Qi(r.getPoints(50), i)), this.markerObject.add(Qi([new THREE.Vector3(-t, 0, 0), new THREE.Vector3(t, 0, 0)], i)), this.markerObject.add(Qi([new THREE.Vector3(0, -t, 0), new THREE.Vector3(0, t, 0)], i)), this.UpdatePosition(e)
		}
		UpdatePosition(e) {
			this.intersection = e;
			let t = Tn(this.intersection);
			this.markerObject.updateMatrixWorld(!0), this.markerObject.position.set(0, 0, 0), this.markerObject.lookAt(t), this.markerObject.position.set(this.intersection.point.x, this.intersection.point.y, this.intersection.point.z)
		}
		Show(e) {
			this.markerObject.visible = e
		}
		GetIntersection() {
			return this.intersection
		}
		GetObject() {
			return this.markerObject
		}
	};

	function yo(o, e) {
		let t = o.GetIntersection(),
			i = e.GetIntersection(),
			r = {
				pointsDistance: null,
				parallelFacesDistance: null,
				facesAngle: null
			},
			n = Tn(t),
			s = Tn(i);
		if (r.pointsDistance = t.point.distanceTo(i.point), r.facesAngle = n.angleTo(s), ir(r.facesAngle, 0, 1e-4) || ir(r.facesAngle, Math.PI, 1e-4)) {
			let l = new THREE.Plane()
				.setFromNormalAndCoplanarPoint(n, t.point);
			r.parallelFacesDistance = Math.abs(l.distanceToPoint(i.point))
		}
		return r
	}
	var Mn = class {
		constructor(e, t) {
			this.viewer = e, this.settings = t, this.isActive = !1, this.markers = [], this.tempMarker = null, this.panel = null, this.button = null
		}
		SetButton(e) {
			this.button = e
		}
		IsActive() {
			return this.isActive
		}
		SetActive(e) {
			this.isActive !== e && (this.isActive = e, this.button.SetSelected(e), this.isActive ? (this.panel = v(document.body, "ov_measure_panel"), this.UpdatePanel(), this.Resize()) : (this.ClearMarkers(), this.panel.remove()))
		}
		Click(e) {
			let t = this.viewer.GetMeshIntersectionUnderMouse(e);
			if (t === null) {
				this.ClearMarkers(), this.UpdatePanel();
				return
			}
			this.markers.length === 2 && this.ClearMarkers(), this.AddMarker(t), this.UpdatePanel()
		}
		MouseMove(e) {
			let t = this.viewer.GetMeshIntersectionUnderMouse(e);
			if (t === null) {
				this.tempMarker !== null && (this.tempMarker.Show(!1), this.viewer.Render());
				return
			}
			this.tempMarker === null && (this.tempMarker = this.GenerateMarker(t)), this.tempMarker.UpdatePosition(t), this.tempMarker.Show(!0), this.viewer.Render()
		}
		AddMarker(e) {
			let t = this.GenerateMarker(e);
			if (this.markers.push(t), this.markers.length === 2) {
				let i = lo(),
					r = this.markers[0].GetIntersection()
					.point,
					n = this.markers[1].GetIntersection()
					.point;
				this.viewer.AddExtraObject(Qi([r, n], i))
			}
		}
		GenerateMarker(e) {
			let i = this.viewer.GetBoundingSphere(n => !0)
				.radius / 20,
				r = new ao(e, i);
			return this.viewer.AddExtraObject(r.GetObject()), r
		}
		UpdatePanel() {
			function e(t, i, r, n) {
				let s = ne(t, i, "left_inline");
				s.title = r, v(t, "ov_measure_value", n)
			}
			if (Ce(this.panel), On(this.settings.backgroundColor) ? this.panel.style.color = "#000000" : this.panel.style.color = "#ffffff", this.markers.length === 0) this.panel.innerHTML = "Select a point.";
			else if (this.markers.length === 1) this.panel.innerHTML = "Select another point.";
			else {
				let t = yo(this.markers[0], this.markers[1]);
				if (t.pointsDistance !== null && e(this.panel, "measure_distance", "Distance of points", t.pointsDistance.toFixed(3)), t.parallelFacesDistance !== null && e(this.panel, "measure_distance_parallel", "Distance of parallel faces", t.parallelFacesDistance.toFixed(3)), t.facesAngle !== null) {
					let i = t.facesAngle * Sn;
					e(this.panel, "measure_angle", "Angle of faces", i.toFixed(1) + "\xB0")
				}
			}
		}
		Resize() {
			if (!this.isActive) return;
			let t = this.viewer.GetCanvas()
				.getBoundingClientRect();
			this.panel.style.left = t.left + "px", this.panel.style.top = t.top + "px", this.panel.style.width = t.right - t.left + "px"
		}
		ClearMarkers() {
			this.viewer.ClearExtra(), this.markers = [], this.tempMarker = null
		}
	};
	var Ye = {
			Undefined: 0,
			Intro: 1,
			Model: 2,
			Loading: 3
		},
		yn = class {
			constructor(e) {
				this.parameters = e, this.settings = new mi, this.viewer = new ri, this.measureTool = new Mn(this.viewer, this.settings), this.hashHandler = new ni, this.toolbar = new fn(this.parameters.toolbarDiv), this.navigator = new nn(this.parameters.navigatorDiv, this.parameters.navigatorSplitterDiv), this.sidebar = new un(this.parameters.sidebarDiv, this.parameters.sidebarSplitterDiv, this.settings), this.modelLoaderUI = new li, this.themeHandler = new dn, this.highlightColor = new THREE.Color(9357808), this.uiState = Ye.Undefined, this.model = null
			}
			Load() {
				this.settings.LoadFromCookies(), this.SwitchTheme(this.settings.themeId, !1), te("theme_on_load", this.settings.themeId === ge.Light ? "light" : "dark"), this.InitViewer(), this.InitToolbar(), this.InitDragAndDrop(), this.InitSidebar(), this.InitNavigator(), this.viewer.SetMouseClickHandler(this.OnModelClicked.bind(this)), this.viewer.SetMouseMoveHandler(this.OnModelMouseMoved.bind(this)), this.viewer.SetContextMenuHandler(this.OnModelContextMenu.bind(this)), this.Resize(), this.SetUIState(Ye.Intro), this.hashHandler.SetEventListener(this.OnHashChange.bind(this)), this.OnHashChange(), Vn(() => {
					this.OnSmallWidthChanged()
				}), window.addEventListener("resize", () => {
					this.Resize()
				})
			}
			Resize() {
				let e = window.innerWidth,
					t = window.innerHeight,
					i = this.parameters.headerDiv.offsetHeight,
					r = 0,
					n = 0,
					s = 0;
				Ln() || (r = this.navigator.GetWidth(), n = this.sidebar.GetWidth(), s = 1);
				let l = 50,
					a = e - r - n;
				a < l && (this.sidebar.DecreaseWidth(l - a), a = l);
				let h = t - i;
				st(this.parameters.introDiv, h), this.navigator.Resize(h), this.sidebar.Resize(h), this.viewer.Resize(a - s, h), this.measureTool.Resize()
			}
			OnSmallWidthChanged() {
				this.uiState === Ye.Model && this.UpdatePanelsVisibility()
			}
			HasLoadedModel() {
				return this.model !== null
			}
			SetUIState(e) {
				function t(i) {
					document.querySelector(":root")
						.style.setProperty("--ov_only_on_model_display", i ? "inherit" : "none")
				}
				this.uiState !== e && (this.uiState = e, this.uiState === Ye.Intro ? (L(this.parameters.introDiv, !0), L(this.parameters.mainDiv, !1), t(!1)) : this.uiState === Ye.Model ? (L(this.parameters.introDiv, !1), L(this.parameters.mainDiv, !0), t(!0), this.UpdatePanelsVisibility()) : this.uiState === Ye.Loading && (L(this.parameters.introDiv, !1), L(this.parameters.mainDiv, !1), t(!1)), this.Resize())
			}
			ClearModel() {
				Xr(), this.model = null, this.viewer.Clear(), this.parameters.fileNameDiv.innerHTML = "", this.navigator.Clear(), this.sidebar.Clear(), this.measureTool.SetActive(!1)
			}
			OnModelLoaded(e, t) {
				this.model = e.model, this.parameters.fileNameDiv.innerHTML = e.mainFile, this.viewer.SetMainObject(t), this.viewer.SetUpVector(G.Y, !1), this.navigator.FillTree(e), this.UpdateSidebar(), this.FitModelToWindow(!0)
			}
			OnModelClicked(e, t) {
				if (e !== 1) return;
				if (this.measureTool.IsActive()) {
					this.measureTool.Click(t);
					return
				}
				let i = this.viewer.GetMeshUserDataUnderMouse(t);
				i === null ? this.navigator.SetSelection(null) : this.navigator.SetSelection(new Gt(le.Mesh, i.originalMeshId))
			}
			OnModelMouseMoved(e) {
				this.measureTool.IsActive() && this.measureTool.MouseMove(e)
			}
			OnModelContextMenu(e, t) {
				let i = this.viewer.GetMeshUserDataUnderMouse(t),
					r = [];
				if (i === null) r.push({
					name: "Fit model to window",
					icon: "fit",
					onClick: () => {
						this.FitModelToWindow(!1)
					}
				}), this.navigator.HasHiddenMesh() && r.push({
					name: "Show all meshes",
					icon: "visible",
					onClick: () => {
						this.navigator.ShowAllMeshes(!0)
					}
				});
				else if (r.push({
					name: "Hide mesh",
					icon: "hidden",
					onClick: () => {
						this.navigator.ToggleMeshVisibility(i.originalMeshId)
					}
				}), r.push({
					name: "Fit mesh to window",
					icon: "fit",
					onClick: () => {
						this.navigator.FitMeshToWindow(i.originalMeshId)
					}
				}), this.navigator.MeshItemCount() > 1) {
					let n = this.navigator.IsMeshIsolated(i.originalMeshId);
					r.push({
						name: n ? "Remove isolation" : "Isolate mesh",
						icon: n ? "deisolate" : "isolate",
						onClick: () => {
							n ? this.navigator.ShowAllMeshes(!0) : this.navigator.IsolateMesh(i.originalMeshId)
						}
					})
				}
				qt(r, {
					calculatePosition: n => Hs(e, n),
					onClick: n => {
						r[n].onClick()
					}
				})
			}
			OnHashChange() {
				if (this.hashHandler.HasHash()) {
					let e = this.hashHandler.GetModelFilesFromHash();
					if (e === null) return;
					Pi(e);
					let t = new jt;
					t.defaultColor = this.settings.defaultColor;
					let i = this.hashHandler.GetDefaultColorFromHash();
					i !== null && (t.defaultColor = i), te("model_load_started", "hash"), this.LoadModelFromUrlList(e, t)
				} else this.ClearModel(), this.SetUIState(Ye.Intro)
			}
			OpenFileBrowserDialog() {
				this.parameters.fileInput.click()
			}
			FitModelToWindow(e) {
				let t = !e,
					i = this.viewer.GetBoundingSphere(r => this.navigator.IsMeshVisible(r.originalMeshId));
				e && this.viewer.AdjustClippingPlanesToSphere(i), this.viewer.FitSphereToWindow(i, t)
			}
			FitMeshToWindow(e) {
				let t = this.viewer.GetBoundingSphere(i => i.originalMeshId.IsEqual(e));
				this.viewer.FitSphereToWindow(t, !0)
			}
			FitMeshesToWindow(e) {
				let t = new Set;
				for (let r of e) t.add(r.GetKey());
				let i = this.viewer.GetBoundingSphere(r => t.has(r.originalMeshId.GetKey()));
				this.viewer.FitSphereToWindow(i, !0)
			}
			UpdateSidebar() {
				let t = this.viewer.GetShadingType() === me.Physical,
					i = as(this.model);
				this.sidebar.UpdateSettings(t, i)
			}
			UpdateMeshesVisibility() {
				this.viewer.SetMeshesVisibility(e => this.navigator.IsMeshVisible(e.originalMeshId))
			}
			UpdateMeshesSelection() {
				let e = this.navigator.GetSelectedMeshId();
				this.viewer.SetMeshesHighlight(this.highlightColor, t => !!(e !== null && t.originalMeshId.IsEqual(e)))
			}
			LoadModelFromUrlList(e, t) {
				this.LoadModel(e, Z.Url, t), this.ClearHashIfNotOnlyUrlList()
			}
			LoadModelFromFileList(e) {
				let t = new jt;
				t.defaultColor = this.settings.defaultColor, this.LoadModel(e, Z.File, t), this.ClearHashIfNotOnlyUrlList()
			}
			LoadModel(e, t, i) {
				this.modelLoaderUI.LoadModel(e, t, i, {
					onStart: () => {
						this.SetUIState(Ye.Loading), this.ClearModel()
					},
					onFinish: (r, n) => {
						this.SetUIState(Ye.Model), this.OnModelLoaded(r, n);
						let s = Be(r.mainFile);
						te("model_loaded", s)
					},
					onRender: () => {
						this.viewer.Render()
					},
					onError: r => {
						this.SetUIState(Ye.Intro);
						let n = null;
						if (r.mainFile !== null) n = Be(r.mainFile);
						else {
							let s = [],
								a = this.modelLoaderUI.GetImporter()
								.GetFileList()
								.GetFiles();
							for (let h = 0; h < a.length; h++) {
								let u = a[h].extension;
								s.push(u)
							}
							n = s.join(",")
						}
						r.code === Re.NoImportableFile ? te("no_importable_file", n) : r.code === Re.FailedToLoadFile ? te("failed_to_load_file", n) : r.code === Re.ImportFailed && te("import_failed", n, {
							error_message: r.message
						})
					}
				})
			}
			ClearHashIfNotOnlyUrlList() {
				!this.modelLoaderUI.GetImporter()
					.GetFileList()
					.IsOnlyUrlSource() && this.hashHandler.HasHash() && (this.hashHandler.SkipNextEventHandler(), this.hashHandler.ClearHash())
			}
			UpdateEdgeDisplay() {
				this.settings.SaveToCookies(), this.viewer.SetEdgeSettings(this.settings.showEdges, this.settings.edgeColor, this.settings.edgeThreshold)
			}
			UpdateEnvironmentMap() {
				let e = "assets/envmaps/" + this.settings.environmentMapName + "/",
					t = [e + "posx.jpg", e + "negx.jpg", e + "posy.jpg", e + "negy.jpg", e + "posz.jpg", e + "negz.jpg"];
				this.viewer.SetEnvironmentMapSettings(t, this.settings.backgroundIsEnvMap)
			}
			SwitchTheme(e, t) {
				if (this.settings.themeId = e, this.themeHandler.SwitchTheme(this.settings.themeId), this.settings.SaveToCookies(), t) {
					this.viewer.SetBackgroundColor(this.settings.backgroundColor);
					let i = this.modelLoaderUI.GetModelLoader();
					i.GetDefaultMaterial() !== null && (vr(this.model, this.settings.defaultColor), i.ReplaceDefaultMaterialColor(this.settings.defaultColor))
				}
			}
			InitViewer() {
				let e = X(this.parameters.viewerDiv, "canvas");
				this.viewer.Init(e), this.viewer.SetEdgeSettings(this.settings.showEdges, this.settings.edgeColor, this.settings.edgeThreshold), this.viewer.SetBackgroundColor(this.settings.backgroundColor), this.UpdateEnvironmentMap()
			}
			InitToolbar() {
				function e(l, a, h, u, d) {
					let m = l.AddImageButton(a, h, () => {
						d()
					});
					for (let f of u) m.AddClass(f);
					return m
				}

				function t(l, a, h, u, d) {
					let m = l.AddImagePushButton(a, h, !1, f => {
						d(f)
					});
					for (let f of u) m.AddClass(f);
					return m
				}

				function i(l, a, h, u, d, m) {
					let f = [];
					for (let c = 0; c < a.length; c++) {
						let g = a[c],
							x = h[c];
						f.push({
							image: g,
							title: x
						})
					}
					let p = l.AddImageRadioButton(f, u, c => {
						m(c)
					});
					for (let c of d)
						for (let g of p) g.AddClass(c)
				}

				function r(l, a) {
					let h = l.AddSeparator();
					if (a !== null)
						for (let u of a) h.classList.add(u)
				}
				let n = this.modelLoaderUI.GetImporter();
				e(this.toolbar, "open", "", [], () => {
					this.OpenFileBrowserDialog()
				}), e(this.toolbar, "open_url", "URL", [], () => {
					no(l => {
						l.length > 0 && this.hashHandler.SetModelFilesToHash(l)
					})
				}), r(this.toolbar, ["only_on_model"]), e(this.toolbar, "fit", "Fit model to window", ["only_on_model"], () => {
					this.FitModelToWindow(!1)
				}), e(this.toolbar, "up_y", "Set Y axis as up vector", ["only_on_model"], () => {
					this.viewer.SetUpVector(G.Y, !0)
				}), e(this.toolbar, "up_z", "Set Z axis as up vector", ["only_on_model"], () => {
					this.viewer.SetUpVector(G.Z, !0)
				}), e(this.toolbar, "flip", "Flip up vector", ["only_on_model"], () => {
					this.viewer.FlipUpVector()
				}), r(this.toolbar, ["only_on_model"]), i(this.toolbar, ["fix_up_on", "fix_up_off"], ["Fixed up vector", "Free orbit"], 0, ["only_on_model"], l => {
					l === 0 ? this.viewer.SetFixUpVector(!0) : l === 1 && this.viewer.SetFixUpVector(!1)
				}), r(this.toolbar, ["only_full_width", "only_on_model"]);
				let s = t(this.toolbar, "measure", "Measure", ["only_full_width", "only_on_model"], l => {
					te("measure_tool_activated", l ? "on" : "off"), this.navigator.SetSelection(null), this.measureTool.SetActive(l)
				});
				this.measureTool.SetButton(s), r(this.toolbar, ["only_full_width", "only_on_model"]), e(this.toolbar, "snapshot", "Create snapshot", ["only_full_width", "only_on_model"], () => {
					ro(this.viewer)
				}), e(this.toolbar, "export", "Export model", ["only_full_width", "only_on_model"], () => {
					io(this.model, this.viewer, {
						isMeshVisible: l => this.navigator.IsMeshVisible(l)
					})
				}), this.parameters.fileInput.addEventListener("change", l => {
					l.target.files.length > 0 && (te("model_load_started", "open_file"), this.LoadModelFromFileList(l.target.files))
				})
			}
			InitDragAndDrop() {
				window.addEventListener("dragstart", e => {
					e.preventDefault()
				}, !1), window.addEventListener("dragover", e => {
					e.stopPropagation(), e.preventDefault(), e.dataTransfer.dropEffect = "copy"
				}, !1), window.addEventListener("drop", e => {
					e.stopPropagation(), e.preventDefault(), kn(e.dataTransfer, t => {
						t.length > 0 && (te("model_load_started", "drop"), this.LoadModelFromFileList(t))
					})
				}, !1)
			}
			InitSidebar() {
				this.sidebar.Init({
					onEnvironmentMapChange: () => {
						this.settings.SaveToCookies(), this.UpdateEnvironmentMap()
					},
					onBackgroundColorChange: () => {
						this.settings.SaveToCookies(), this.viewer.SetBackgroundColor(this.settings.backgroundColor), this.measureTool.IsActive() && this.measureTool.UpdatePanel()
					},
					onDefaultColorChange: () => {
						this.settings.SaveToCookies();
						let e = this.modelLoaderUI.GetModelLoader();
						e.GetDefaultMaterial() !== null && (vr(this.model, this.settings.defaultColor), e.ReplaceDefaultMaterialColor(this.settings.defaultColor)), this.viewer.Render()
					},
					onEdgeDisplayChange: () => {
						te("edge_display_changed", this.settings.showEdges ? "on" : "off"), this.UpdateEdgeDisplay()
					},
					onThemeChange: () => {
						te("theme_changed", this.settings.themeId === ge.Light ? "light" : "dark"), this.SwitchTheme(this.settings.themeId, !0)
					},
					onResize: () => {
						this.Resize()
					},
					onShowHidePanels: e => {
						Pt("ov_show_sidebar", e)
					}
				})
			}
			InitNavigator() {
				function e(n, s) {
					let l = null;
					return n.EnumerateMeshesUserData(a => {
						a.originalMeshId.IsEqual(s) && (l = a)
					}), l
				}

				function t(n, s, l) {
					let a = [];
					return n.EnumerateMeshesUserData(h => {
						if (l === null || h.originalMaterials.indexOf(l) !== -1) {
							let u = s.GetMesh(h.originalMeshId.meshIndex);
							a.push({
								meshId: h.originalMeshId,
								name: u.GetName()
							})
						}
					}), a
				}

				function i(n, s) {
					let l = n.GetMaterial(s);
					return {
						index: s,
						name: l.name,
						color: l.color.Clone()
					}
				}

				function r(n, s, l) {
					let a = [];
					if (l === null)
						for (let h = 0; h < s.MaterialCount(); h++) a.push(i(s, h));
					else {
						let h = e(n, l);
						for (let u = 0; u < h.originalMaterials.length; u++) {
							let d = h.originalMaterials[u];
							a.push(i(s, d))
						}
					}
					return a.sort((h, u) => h.index - u.index), a
				}
				this.navigator.Init({
					openFileBrowserDialog: () => {
						this.OpenFileBrowserDialog()
					},
					updateMeshesVisibility: () => {
						this.UpdateMeshesVisibility()
					},
					updateMeshesSelection: () => {
						this.UpdateMeshesSelection()
					},
					fitMeshToWindow: n => {
						this.FitMeshToWindow(n)
					},
					fitMeshesToWindow: n => {
						this.FitMeshesToWindow(n)
					},
					getMeshesForMaterial: n => t(this.viewer, this.model, n),
					getMaterialsForMesh: n => r(this.viewer, this.model, n),
					onModelSelected: () => {
						this.sidebar.AddObject3DProperties(this.model)
					},
					onMeshSelected: n => {
						let s = this.model.GetMeshInstance(n);
						this.sidebar.AddObject3DProperties(s)
					},
					onMaterialSelected: n => {
						this.sidebar.AddMaterialProperties(this.model.GetMaterial(n))
					},
					onResize: () => {
						this.Resize()
					},
					onShowHidePanels: n => {
						Pt("ov_show_navigator", n)
					}
				})
			}
			UpdatePanelsVisibility() {
				let e = _t("ov_show_navigator", !0),
					t = _t("ov_show_sidebar", !0);
				this.navigator.ShowPanels(e), this.sidebar.ShowPanels(t)
			}
			
		};

	function bo(o) {
		zn(o)
	}

	function So(o) {
		er(o), window.addEventListener("load", () => {
			new yn({
					headerDiv: document.getElementById("header"),
					toolbarDiv: document.getElementById("toolbar"),
					mainDiv: document.getElementById("main"),
					introDiv: document.getElementById("intro"),
					fileNameDiv: document.getElementById("main_file_name"),
					navigatorDiv: document.getElementById("main_navigator"),
					navigatorSplitterDiv: document.getElementById("main_navigator_splitter"),
					sidebarDiv: document.getElementById("main_sidebar"),
					sidebarSplitterDiv: document.getElementById("main_sidebar_splitter"),
					viewerDiv: document.getElementById("main_viewer"),
					fileInput: document.getElementById("open_file")
				})
				.Load()
		})
	}

	function wo(o) {
		er(o), window.addEventListener("load", () => {
			new Kr({
					viewerDiv: document.getElementById("embed_viewer"),
					websiteLinkDiv: document.getElementById("website_link")
				})
				.Load()
		})
	}

	function Eo(o, e, t, i) {
		let r = nt("a");
		return r.setAttribute("href", i), r.setAttribute("target", "_blank"), r.setAttribute("rel", "noopener noreferrer"), bi(r, t), ne(r, e, "header_button"), o.appendChild(r), r
	}
	return po(Ao);
})();